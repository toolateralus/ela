// Using 'type' keyword has a few benefits:
// - It makes the code easier to read & grep.
// - It removes the need for an #alias keyword 
// - I like it.

// alias
type FunctionPointer :: fn *() -> int;

// union, struct, enum of course.
type Union :: union {
  variant_a: int;
  variant_b: float;
}

type Enum :: enum {
  A,
  B,
  C,
  D
}

type Vector2 :: struct {
  x: s32;
  y: s32;
}

// Seperating the methods from the type does a few things for us
// - COMPILER:      It makes it easier to emit them seperately, and output them as free functions.
// - USER/COMPILER: It allows the addition of Interfaces to be more succint and sensible, since we can `impl Interface for Type`
// - USER:          It makes the code easier to read, without putting a ton of free functions floating around like Go's methods.
// - USER:          It makes struct / union declarations much easier to read, since data and methods are very clearly seperated.
// - USER/COMPILER: It makes it so we can implement methods for ANY type, not just unions & structs.

// Additionally, we'd have an explicit 'self' parameter, albeit inferred type.
// - This allows us to not limit the user to using pointer semantics for 'self' pointer.
// - 'const' functions are trivial because you just omit the 'mut' instead of C++'s ugly decorations.
// - static functions no longer need #static, you just don't take a 'self' parameter.
// - it's much easier for us to compile to a free function, since we don't have to infer what type the Self parameter is, and rectify any use of 'implicit this', as seen in c++, where
// a method body can act as though it's within the struct, ('this.a =' vs 'a =');

impl Vector2 {
  // Method, takes self as a value.
  add :: fn(self, other: #self) -> #self {
    // named init list.
    return { 
      x: self.x + other.x,
      y: self.y + other.y,
    };
  }

  // Method, takes a mutable pointer to self.
  normalize :: fn(mut self*) {
    length := sqrt(self.x * self.x + self.y * self.y);
    if length != 0 {
      self.x /= length;
      self.y /= length;
    }
  }

  // Static method.
  zero :: fn() -> #self {
    return {};
  }
}




