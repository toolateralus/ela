#import core
#import directory
#import dlfcn
#import file
#import raylib
#import gl
#import interned_string
#import json
#import memory
#import net
#import pthread
#import reflection

#compiler_flags "-g -fsanitize=address,leak"

XaryuStruct :: struct {
  f: float ;
}

InitListTestCtorStruct :: struct {
  z : int;
  #ctor :: (n : int, f: int) {
    z = n * f;
  }
}

Reflector :: struct {
  n: int;
}

InitListStruct :: struct {
  a: int;
  b: int;
  c: int;
}

Union :: union {
  a: int;
  b: int;
  c: int;
  method :: (n: int) {
    assert("union equality check in method failed", n == a && n == b && n == c);
  }
  #ctor :: () {
    a = -1;
  }
  #dtor :: () {
  }
}
_Vec2 :: union {
  #anon :: struct {
    x: int;
    y: int;
    z: int;
  };
  values: int[3] ;

  method :: (n: int) {
    assert("union equality check in method failed", n == x && n == y && n == z);
    assert("union equality check in method failed", n == values[0] && n == values[1] && n == values[2]);
  }

  something :: () -> #self {
    return #make(#self);
  }

  #ctor :: (_x : int, _y, _z) {
    x = _x;
    y = _y;
    z = _z;
  }

  #ctor :: () {
    memset(#make(void*, values), 0, sizeof(int) * 3);
    x=0;
    y=0;
    z=0;
  }

  #dtor :: () {
  }
}

CustomIteratorStruct :: struct {
  value: int*;

  #ctor :: () {
    value = malloc(sizeof(int) * 10);
    memset(value, 0, sizeof(int) * 10);
  }

  begin :: () -> int * {
    return value;
  }
  end :: () -> int * {
    return value + 10;
  }
  #dtor :: () {
    free(value);
  }
}

Constructible :: struct {
  x: float32;
  #ctor :: (_x: float32) {
      x = _x;
  }
  #ctor :: (other: Constructible) {
      x = other.x;
  }
  #ctor :: () {
    x = 10.0;
  }
}

JVector2 :: struct {
  x: float32;
  y: float32;
}

JVector3 :: struct {
  vec2: JVector2;
  z: float32;
}

Node :: struct {
  next: Node*;
}

Array :: struct {
  ptr: Node[10];
}

IHaveAMethod :: struct {
  method :: () -> float32 {
      return 0.0;
  }
  parameter_method :: (x: float32) -> float32 {
      return x;
  }
}

InitListTest :: struct {
  n : int;
}
XarBarInitListTestStruct :: struct {
  x: float;
  y: float;
}
Xaryu :: struct {
  value: int;
  to_string :: () -> string {
    return "XarBar";
  }
}
OperatorOverloadTest :: struct {
  value: int = 0;

  #operator(+) :: (something: OperatorOverloadTest) -> int {
    return value + something.value;
  }
  #operator(-) :: (something: OperatorOverloadTest) -> int {
    return value - something.value;
  }
  #operator(*) :: (something: OperatorOverloadTest) -> int {
    return value * something.value;
  }
  #operator(/) :: (something: OperatorOverloadTest) -> int {
    return value / something.value;
  }
  #operator(%) :: (something: OperatorOverloadTest) -> int {
    return value % something.value;
  }
  #operator(&) :: (something: OperatorOverloadTest) -> int {
    return value & something.value;
  }
  #operator(|) :: (something: OperatorOverloadTest) -> int {
    return value | something.value;
  }
  #operator(^) :: (something: OperatorOverloadTest) -> int {
    return value ^ something.value;
  }
  #operator(~) :: () -> int {
    return ~value;
  }
  #operator(<<) :: (something: OperatorOverloadTest) -> int {
    return value << something.value;
  }
  #operator(>>) :: (something: OperatorOverloadTest) -> int {
    return value >> something.value;
  }
  #operator(+=) :: (something: OperatorOverloadTest) -> int {
    value += something.value;
    return value;
  }
  #operator(-=) :: (something: OperatorOverloadTest) -> int {
    value -= something.value;
    return value;
  }
  #operator(*=) :: (something: OperatorOverloadTest) -> int {
    value *= something.value;
    return value;
  }
  #operator(/=) :: (something: OperatorOverloadTest) -> int {
    value /= something.value;
    return value;
  }
  #operator(%=) :: (something: OperatorOverloadTest) -> int {
    value %= something.value;
    return value;
  }
  #operator(&=) :: (something: OperatorOverloadTest) -> int {
    value &= something.value;
    return value;
  }
  #operator(|=) :: (something: OperatorOverloadTest) -> int {
    value |= something.value;
    return value;
  }
  #operator(^=) :: (something: OperatorOverloadTest) -> int {
    value ^= something.value;
    return value;
  }
  #operator(<<=) :: (something: OperatorOverloadTest) -> int {
    value <<= something.value;
    return value;
  }
  #operator(>>=) :: (something: OperatorOverloadTest) -> int {
    value >>= something.value;
    return value;
  }
  #operator(++) :: () -> int {
    return ++value;
  }
  #operator(--) :: () -> int {
    return --value;
  }
  #operator(==) :: (something: OperatorOverloadTest) -> bool {
    return value == something.value;
  }
  #operator(!=) :: (something: OperatorOverloadTest) -> bool {
    return value != something.value;
  }
  #operator(<) :: (something: OperatorOverloadTest) -> bool {
    return value < something.value;
  }
  #operator(<=) :: (something: OperatorOverloadTest) -> bool {
    return value <= something.value;
  }
  #operator(>) :: (something: OperatorOverloadTest) -> bool {
    return value > something.value;
  }
  #operator(>=) :: (something: OperatorOverloadTest) -> bool {
    return value >= something.value;
  }
  #operator([]) :: (n: int) -> int {
    base: int = 10;
    return n + base;
  }
  to_string :: () -> char *  {
    str: char* = malloc(sizeof(char *) * 1);
    sprintf(str, "%d", value);
    return str;
  }
}

#flags Banana :: enum  {
  Unripe,
  Ripe,
  Overripe,
  Rotten,
}

MyEnum :: enum {
  Some,
  Other,
  Value = 100 * 2,
}

MakeStruct2 :: struct {
  f: float;
  n: int;
}

SwitchCaseEnum :: enum {
  SwitchVariant0,
  SwitchVariant1,
}

EnumOfStrings :: enum {
  A = string{"Hello"},
  B = string{"Goodbye"}
};


#test test_for :: () {
  for i in 0..10 {
    assert("i should be less than 10", i < 10);
    return;
  }

  for i in 10..0 {
    assert("i should be greater than 0", i > 0);
    return;
  }

  arr: s32[];
  for v in arr {
      assert("Unexpected case in array loop", false);
      return;
  }
  assert("End of test_for reached", true);
}

#test test_while :: () {
  b: bool = true;
  while b {
      assert("while condition == true", b == true);
      return;
  }
  assert("End of test_while reached", true);
}

#test test_if_1 :: () {
  v: bool = true;
  hit: bool = false;
  if v {
      assert("v should be true", v == true);
      hit = true;
  } else {
      assert("Unexpected case", false);
  }
  assert("failed to fall through if statement", hit);
}

#test test_if_2 :: () {
  v: bool = false;
  hit: bool = true;
  if v {
      assert("Unexpected case", false);
  } else if !v {
      hit = true;
  }
  assert("fell through if else, but didn't set the variable", hit);
}

#test test_if_3 :: () {
  v: bool = false;
  hit: bool = true;
  if v {
      assert("Unexpected case", false);
  } else if v {
      assert("Unexpected case", false);
  } else {
      hit = true;
  }
  assert("fell though if,if_else,else but didn't set the variable", hit);
}

#test test_comp_assign :: () {
  deref: s32 = 1;
  deref += deref;
  assert("+=", deref == 2);
  deref -= deref;
  assert("-=", deref == 0);
  deref *= deref;
  assert("*=)", deref == 0);
  deref = 2;
  deref /= deref;
  assert("/=", deref == 1);
  deref = 2;
  deref %= deref;
  assert("%=", deref == 0);
  deref &= deref;
  assert("&=", deref == 0);
  deref |= deref;
  assert("|=", deref == 0);
  deref ^= deref;
  assert("^=", deref == 0);
  deref <<= deref;
  assert("<<=", deref == 0);
  deref >>= deref;
  assert(">>=", deref == 0);
}

#test test_operators :: () {
  left: s32 = 1;
  right: s32 = 1;
  result: s32;
  result_bool: bool;
  result_bool = left == right;
  assert("left should equal right", result_bool == true);
  result_bool = left != right;
  assert("left should not equal right", result_bool == false);
  result_bool = left < right;
  assert("left should not be less than right", result_bool == false);
  result_bool = left > right;
  assert("left should not be greater than right", result_bool == false);
  result_bool = left <= right;
  assert("left should be less than or equal to right", result_bool == true);
  result_bool = left >= right;
  assert("left should be greater than or equal to right", result_bool == true);
  result_bool = left && right;
  assert("left and right should be true", result_bool == true);
  result_bool = left || right;
  assert("left or right should be true", result_bool == true);

  result = left + right;
  assert("left + right should be 2", result == 2);
  result = left - right;
  assert("left - right should be 0", result == 0);
  result = left * right;
  assert("left * right should be 1", result == 1);
  result = left / right;
  assert("left / right should be 1", result == 1);
  result = left % right;
  assert("left % right should be 0", result == 0);
  result = left & right;
  assert("left & right should be 1", result == 1);
  result = left | right;
  assert("left | right should be 1", result == 1);
  result = left ^ right;
  assert("left ^ right should be 0", result == 0);
  result = left << right;
  assert("left << right should be 2", result == 2);
  result = left >> right;
  assert("left >> right should be 0", result == 0);
}

#test test_relational_results :: () {
  test1: bool = (1 == 1 + 2) || 1 == 2;
  test2: bool = (3 > 2) && (2 < 4);
  test3: bool = !(5 <= 5) || (6 >= 6);
  test4: bool = (7 != 8) && (9 == 9);
  assert("test1 should be false", test1 == false);
  assert("test2 should be true", test2 == true);
  assert("test3 should be true", test3 == true);
  assert("test4 should be true", test4 == true);
}

#test test_address_of :: () {
  v: s32 = 0;
  addr_of_v: s32* = &v;
  assert("address of grabbed a non-null ptr", addr_of_v != null);
  v = *addr_of_v;
  assert("deref'ing a ptr grabbed with &v failed to == the same value as when it was defined.", v == 0);
}

#test test_malloc :: () {
  ptr: s32* = malloc(4);
  assert("malloc'd pointer was null", ptr != null);
  free(ptr);
  ptr = null;
  assert("freed ptr and set to null was not == null", ptr == null);
}

many_params :: (a: float32, b, c, d) -> float32 {
  return a * b * c * d;
}

mul_params :: (n: float32, f) -> float32 {
  return n * f;
}

#test test_param :: () {
  assert("params of 1.5 * 2.0 expected to equal 3.0", mul_params(1.5, 2.0) == 3.0);
  assert("multiplying many params failed, or default param", many_params(1.0, 2.0, 4.0, 1.0) == 8.0);
}

returns :: () -> s32  {
  return 1;
}

#test test_implicit_numerical_casting :: () {
  u1: u8;
  u2: u16 = u1;
  u3: u32 = u2;
  u4: u64 = u3;
  assert("unable to upcast successfully", u4 == u1);

  s1: s8;
  s2: s16 = s1;
  s3: s32 = s2;
  s4: s64 = s3;
  assert("unable to upcast successfully", s1 == s4);

  f: float;
  f1: float64 = f;
  assert("unable to upcast successfully", f == f1);
}

#test test_return_value :: () {
  assert("function expected to return 1", returns() == 1);
}

#test test_struct_single_level :: () {
  v: JVector2;
  assert("v.x != 0.0", v.x == 0.0);
  assert("v.y != 0.0", v.y == 0.0);
}

#test test_struct_nested_once :: () {
  v: JVector3;
  assert("v.vec2.x != 0.0", v.vec2.x == 0.0);
  assert("v.vec2.y != 0.0", v.vec2.y == 0.0);
  assert("v.z != 0.0", v.z == 0.0);
}

#test test_struct_assign_member :: () {
  v: JVector2;
  v.x = 10.0;
  v.y = 10.0;
  assert("assigning v.x = 10.0 failed", v.x == 10.0);
  assert("assigning v.y = 10.0 failed", v.y == 10.0);
}

#test test_struct_assign_nested_member :: () {
  v: JVector3;
  v.vec2.x = 1.0;
  v.vec2.y = 2.0;
  v.z = 3.0;
  assert("assigning v.vec2.x = 1.0 failed", v.vec2.x == 1.0);
  assert("assigning v.vec2.y = 1.0 failed", v.vec2.y == 2.0);
  assert("assigning v.z = 3.0 failed", v.z == 3.0);
}

struct_as_param :: (v: JVector2)  -> float32 {
  return v.x;
}

#test test_struct_as_param :: () {
  v: JVector2;
  assert("", struct_as_param(v) == 0.0);
}

something :: (f: float32) -> float32 {
  return f;
}

#test test_struct_member_as_param :: () {
  v: JVector2;
  assert("passing dot expr struct member as param failed", something(v.x) == 0.0);
}

#test test_local_function :: () {
  local_function :: () -> s32 {
      return 0;
  }
  assert("failed to get 0 from local function call", local_function() == 0);
}

#test test_chained_dot_subscript :: () {
  a: Array;
  a.ptr[0].next = null;
  assert("failure: a.ptr[0].next != null", a.ptr[0].next == null);

  n: Node ;
  a.ptr[0].next = &n;
  assert("failure: a.ptr[0].next != null", a.ptr[0].next != null);
}

#test test_subscript :: () {
  arr: s32[100];
  arr[50] = 0;
  assert("subscript 50 on s32[100] failed to == 0", arr[50] == 0);
  n: int;
  ++n;
}

#test test_referencing_pointer :: () {
  node: Node;
  node.next = malloc(sizeof(Node));
  other: Node;
  node.next.next = &other;
  assert("mallocing 'next' of 'Node' failed.", node.next != null);
  assert("dereferencing other into node.next failed.", node.next.next != null);
  free(node.next);
}

// testing conflicting definitons. expected: compiler error if failed.
#test for_loop_2 :: () {
  for i in 0..10 {
      i = i;
  }
  for i in 0..10 {
    i = i;
  }

  array: int[];

  for k in array {
    k = k;
  }
  for *k in array {
    k = k;
  }
}

#test make_parameterless :: () {
  n := #make(Constructible);
  assert("default construction failed.", n.x == 10.0);
}

#test test_copy_make :: () {
  c: Constructible;
  c1: Constructible = #make(Constructible, c);
  assert("failed to copy construct Constructible (struct)", c1.x == c.x);
}


#test test_make :: () {
  c := Constructible{10.0};
  ms2 := MakeStruct2{0.0, 10};
  assert("failed to construct", c.x == 10.0);
}

#test test_make_cast :: () {
  big: u16 = #make(u16, 65365);
  small: u8 = #make(u8, big);
  assert("failed to down cast", small == (big % 255));
}

#test test_method :: () {
  owner: IHaveAMethod ;
  assert("failed to get 0.0 from method.", owner.method() == 0.0);
  assert("failed to get 0.0 from method (passing back param).", owner.parameter_method(0.0) == 0.0);
}

#test test_enum_flags :: () {
  flags := Banana.Unripe | Banana.Overripe;
  assert("flags & Banana.Unripe failed.", (flags & Banana.Unripe) != 0);
}

// TODO(Josh) 10/1/2024, 10:08:18 AM :: we need to allow declarations of variables with their enum type.
// Right now we just cast enums to int always.
// We should be able to do MyEnum value = MyEnum.Some;
// This will also allow us to do other stuff, like type safe enums.

#test test_regular_enum :: () {
  value := MyEnum.Some;
  value1 := MyEnum.Value;
  assert("MyEnum.Value failed to == 100 * 2", value1 == 100 * 2);
  assert("Zero case of enum did not equal 0", value == 0);
}

#test test_type_alias :: () {
  #alias XaryuBarSchnar :: int;
  i: XaryuBarSchnar = 0;
  assert("type alias failed", i == 0);
}

#test test_comp_assign_non_iden :: () {
  arr: float32[12];
  arr[0] = 10;
  arr[0] += 10;
  assert("comp assign arr[0] += 10 failed to == 20.", arr[0] == 20);

  xarbars:  XaryuStruct[1];
  xarbars[0].f = 10.0;
  xarbars[0].f += 10.0;
  assert("comp assign xarbars[0].f += 10.0; failed to == 20.0", xarbars[0].f == 20.0);
}

#test test_union_type :: () {
  test_union: Union;
  test_union.a = 10;
  assert("union variants failed to equal each other", test_union.a == test_union.b && test_union.b == test_union.c);
  test_union.method(10);
}

#test test_two_way_implicit_conversion_bin_ops :: () {
  v: s32;
  v1: s8;
  f: float32;
  assert("failed to convert both ways", v + v1 == 0 && v1 + v == 0);
}

#test test_union_type_anonymous_sub_struct :: () {
  vec: _Vec2;
  vec.method(0); // this does the assertions
}

#test test_new :: () {
  vec: _Vec2* = new _Vec2(10, 10, 10);
  vec1: _Vec2* = new _Vec2(10, 10, 10);
  assert("new allocated structs using ctor failed to equal each other", vec.x == vec1.x && vec.y == vec1.y && vec.z == vec1.z);
  delete (vec, vec1);
}

#test custom_iterator_increment :: () {
  for i in #make(Range, 0, 10, 2) {
    assert("iter increment failed to be divisible by 2", i % 2 == 0);
  }
  for i in #make(Range, 0, 10, 3) {
    assert("iter increment failed to be divisible by 3", i % 3 == 0);
  }
}

#test ptr_iter_range_base :: () {
  array: s8[] = {0,1,2,3};
  n: int ;
  for *v in array {
    assert("", n == *v);
    ++n;
  }

  n = 0;
  // TODO: tidy up the confusing and often strangely inconsistent semantics around construction of types.
  arr : s8[]* = new s8[] ({0,1,2,3});
  for v in *arr {
    assert("", n == v);
    ++n;
  }
  delete(arr);
}

#test test_custom_iterator :: () {
  iter: CustomIteratorStruct;
  n: int;
  for k in iter {
    assert("iterator value failed to equal 0", k == 0);
    n++;
  }
  assert("failed to iterate the appropriate number of times", n == 10);
}

#test test_string :: () {
  my_string : string = "Xaryu Baryu";
  assert("string length failed to equal expected value", my_string.length == 11);
}

#test test_array :: () {
  array : int[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  assert("array length failed to equal expected value", array.length == 11);
  // !BUG: we need to fix this.
  // !This throws C++ errors during compilation
  // !because initializer lists have strangely strict typing
  // !compared to normal narrowing rules.
  // !bool[] arr = {0,1,2,3,4,5};
}

#test test_aliasing :: () {
  #alias int_ptr :: int*;
  p: int* = malloc(sizeof(int));
  other: int_ptr  = p;
  assert("alias failed to equal pointed to type field.", p == other);
  free(p);

  pp: int** = #make(int**, malloc(sizeof(int*)));
  other1: int_ptr* = pp;
  assert("alias failed to equal pointed to type field.", pp == other1);

  free(pp);
}

#test test_string_interpolation :: () {
  xarbar: Xaryu;
  interp: string = $"{xarbar}";
  assert("unexpected interpolated string value", strcmp(interp.data, "XarBar") == 0);
  interp = $"{(1 + 1) * 2}";
  assert("unexpected interpolated string value", strcmp(interp.data, "4") == 0);
}

overloaded :: (n: int , y) -> int {
  return n * y;
}

overloaded :: (n: int) -> int {
  return n;
}

overloaded :: (n: int, y: float) -> float {
  return n * y;
}

overloaded :: (f: float ) -> float {
  return f;
}

overloaded :: (xaryu: Xaryu ) -> Xaryu {
  return xaryu;
}


#test test_operator_overload :: () {
  opstr1: OperatorOverloadTest;
  opstr2: OperatorOverloadTest;
  opstr1.value = 10;
  opstr2.value = 5;
  assert("Addition operator overload failed",                   opstr1 + opstr2 == 15);
  assert("Subtraction operator overload failed",                opstr1 - opstr2 == 5);
  assert("Multiplication operator overload failed",             opstr1 * opstr2 == 50);
  assert("Division operator overload failed",                   opstr1 / opstr2 == 2);
  assert("Modulus operator overload failed",                    opstr1 % opstr2 == 0);
  assert("Bitwise AND operator overload failed",                opstr1 & opstr2 == 0);
  assert("Bitwise OR operator overload failed",                 opstr1 | opstr2 == 15);
  assert("Bitwise XOR operator overload failed",                opstr1 ^ opstr2 == 15);
  assert("Bitwise NOT operator overload failed",                ~opstr1 == -11);
  assert("Left shift operator overload failed",                 opstr1 << opstr2 == 320);
  assert("Right shift operator overload failed",                opstr1 >> opstr2 == 0);
  ++opstr1;
  assert("Increment operator overload failed",                  opstr1.value == 11);
  --opstr1;
  assert("Decrement operator overload failed",                  opstr1.value == 10);
  assert("Equality operator overload failed",                   opstr1 == opstr2 == false);
  assert("Inequality operator overload failed",                 opstr1 != opstr2 == true);
  assert("Less than operator overload failed",                  opstr1 < opstr2 == false);
  assert("Less than or equal operator overload failed",         opstr1 <= opstr2 == false);
  assert("Greater than operator overload failed",               opstr1 > opstr2 == true);
  assert("Greater than or equal operator overload failed",      opstr1 >= opstr2 == true);
  assert("Subscript operator didn't return '30'",               opstr1[20] == 30);
}
#test test_comp_assign_overloads :: () {
  opstr1: OperatorOverloadTest;
  opstr2: OperatorOverloadTest;
  opstr1.value = 10;
  opstr2.value = 5;
  opstr1 += opstr2;
  assert("Addition assignment operator overload failed",        opstr1.value == 15);
  opstr1 -= opstr2;
  assert("Subtraction assignment operator overload failed",     opstr1.value == 10);
  opstr1 *= opstr2;
  assert("Multiplication assignment operator overload failed",  opstr1.value == 50);
  opstr1 /= opstr2;
  assert("Division assignment operator overload failed",        opstr1.value == 10);
  opstr1 %= opstr2;
  assert("Modulus assignment operator overload failed",         opstr1.value == 0);
  opstr1 &= opstr2;
  assert("Bitwise AND assignment operator overload failed",     opstr1.value == 0);
  opstr1 |= opstr2;
  assert("Bitwise OR assignment operator overload failed",      opstr1.value == 5);
  opstr1 ^= opstr2;
  assert("Bitwise XOR assignment operator overload failed",     opstr1.value == 0);
  opstr1 <<= opstr2;
  assert("Left shift assignment operator overload failed",      opstr1.value == 0);
  opstr1 >>= opstr2;
  assert("Right shift assignment operator overload failed",     opstr1.value == 0);
}

#test test_initializer_lists :: () {
    scalar: int = {0};
    arr: int[]  = {0, 1, 2};
    fixed: int[3] = {0, 1, 2};
    str: InitListStruct = {0, 0, 0};

    //! BUG This thing is broken because we provide too many elements to the init list, however our type checker fails to catch it and you get a C++ massive annoying errer.
    //! This line causes a segfault:
    //  InitListStruct[] strArr = {{0, 0, 0, 4}, {0, 0, 0}, {0, 0, 0}};

    strArr: InitListStruct[]  = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}; // ! Comment this out to test.
    strArr1: InitListStruct[3] = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};

    expected_arr: int[] = {0, 1, 2};
    for i in 0..arr.length {
      assert("Array element mismatch", arr[i] == expected_arr[i]);
    }

    expected_fixed: int[3] = {0, 1, 2};
    for i in 0..3 {
      assert("Fixed array element mismatch", fixed[i] == expected_fixed[i]);
    }

    assert("Struct element mismatch", str.a == 0);
    assert("Struct element mismatch", str.b == 0);
    assert("Struct element mismatch", str.c == 0);

    expected_strArr: InitListStruct[]  = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};
    for i in 0..strArr.length {
      assert("Struct array element mismatch", strArr[i].a == expected_strArr[i].a);
      assert("Struct array element mismatch", strArr[i].b == expected_strArr[i].b);
      assert("Struct array element mismatch", strArr[i].c == expected_strArr[i].c);
    }

    // Assertions for strArr1
    expected_strArr1: InitListStruct[3]  = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};
    for i in 0..3 {
      assert("Fixed struct array element mismatch", strArr1[i].a == expected_strArr1[i].a);
      assert("Fixed struct array element mismatch", strArr1[i].b == expected_strArr1[i].b);
      assert("Fixed struct array element mismatch", strArr1[i].c == expected_strArr1[i].c);
    }
}

#test test_cast :: () {
  n: int = 10;
  f: float  = (float)n;
  assert("Cast failed", f == 10.0);
}

#test test_underscores_in_number_literals :: () {
  n: int = 1_000_000;
  assert("number literal with underscores failed to equal expected value", n == 1000000)
}

#test test_array_concat_operator :: () {
  array: int[];
  array ~= 10;
  assert("concat operator failed", array.length == 1);
}

#test test_array_pop_operator :: () {
  array: int[];
  for i in 0..100 {
    array ~= 10;
  }
  n: int;
  for i in 0..100 {
    n = ~array;
  }
  assert("pop operator failed", array.length == 0 && n == 10);
}

#test test_array_erase_operator :: () {
  array: int[] ;
  array ~= 10;
  array ~~ 10;
  assert("failed to erase element from array with ~~", array.length == 0);
}

New :: (v: XarBarInitListTestStruct) -> XarBarInitListTestStruct {
  return v;
}

#test test_init_list_as_implicit_parameter :: () {
  v := New({0.0, 0.0});
  assert("failed", v.x == 0.0 && v.y == 0.0);
}

#test test_range_based_for_loop_exclusive :: () {
  n: int;
  ten := 10;
  zero := 0;

  for i in 0..10 {
    n = i;
  }

  for i in 0..ten {
    n = i;
  }

  for i in zero..ten {
    n = i;
  }

  for i in zero..10 {
    n = i;
  }

  assert("Range based for loop failed.", n == 9);
}

#alias FunctionPointer :: int(int, int)*;

function_pointer_helper :: (x: int, y: int) -> int { return x * y; }

#test test_multidimensional_arrays :: () {
  array: int[5][5];
  for x in 0..5 {
    for y in 0..5 {
      array[x][y] = x * y;
    }
  }

  for x in 0..5 {
    for y in 0..5 {
      assert("multidimensional failure", array[x][y] == x * y);
    }
  }

  dynamic : s64[][];
  for x in 0..5 {
    dynamic ~= #make(s64[]);
    for y in 0..5 {
      dynamic[x] ~= x * y;
    }
  }

  assert("length failed", dynamic.length == 5);

  for x in 0..5 {
    for y in 0..5 {
      assert("multidimensional failure", dynamic[x][y] == x * y);
    }
  }
}

#test test_function_pointer_alias :: () {
  ptr := &function_pointer_helper;
  assert("Function pointer call", ptr(2, 3) == 6);

  array: FunctionPointer[] = {&function_pointer_helper};
  from_arr : FunctionPointer = array[0];
  assert("Array of function pointers", from_arr(2, 3) == 6);

  fixed: FunctionPointer[12];
  fixed[0] = &function_pointer_helper;
  from_fixed : FunctionPointer = fixed[0];

  assert("Fixed array of function pointers", from_fixed(2, 3) == 6);

  function :: () -> FunctionPointer {
    return &function_pointer_helper;
  }

  returned_ptr : FunctionPointer = function();
  assert("Function returning function pointer", returned_ptr(2, 3) == 6);
}

#test test_map_aka_associative_array :: () {
  variables: int[string];
  map1: int*[char*];

  str1 := #make(string, "Key1");
  str2 := #make(string, "Key2");
  str3 := #make(string, "shouldn't exist");

  variables[str1] = 100;
  variables[str2] = 200;

  assert("Expected: 100", variables[str1] == 100);
  assert("Expected: 200", variables[str2] == 200);

  assert("Didn't contain known key.", variables.contains(str1));
  assert("Map contained incorrect key.", !variables.contains(str3));

  variables[str1] = 300;
  assert("Expected: 300", variables[str1] == 300);

  variables[str1] = 0;
  assert("Expected: 0", variables[str1] == 0);

  map1["Something"] = new int(200);
  assert("Expected: 200", *map1["Something"] == 200);

  *map1["Something"] = 400;
  assert("Expected: 400", *map1["Something"] == 400);

  map1["Another"] = new int(500);
  assert("Expected: 500", *map1["Another"] == 500);

  delete(map1["Something"]);
  delete(map1["Another"]);

  // ! BUG : Cannot use multi-dimensional maps. It's terribly designed and needs a rework.
  // ! really, maps should be eliminated and be replaced once generics are back in the language.
}

returns_an_init_list  :: () -> InitListTest {
  return {0};
}

infers_argument_from_init_list :: (t: InitListTest) -> InitListTest {
  return t;
}

#test test_init_list_comprehensive :: () {
  assert("Init list failed to return from function", returns_an_init_list().n == 0);
  assert("Init list failed to infer from parameter signature", infers_argument_from_init_list({0}).n == 0);
  empty_init_list := InitListTest{};

}

#test subscript_string :: () {
  s: string = #make(string, "0,1,2,3");
  s[0] = 10;
}

switch_helper :: () -> int {
  number := 5;
  switch number {
    0: { return 0; }
    5: { return 5; }
  }
  return 1;
}

#test test_switch_statements :: () {
  integer: int;

  passed := false;
  switch integer {
    0: { passed = true; }
    1: { assert("Switch on int case failed", false);  }
  }

  assert("Failed to hit positive switch case for integer", passed);
  str: string = "Hello!";

  passed = false;
  switch str {
    string{"Hello"}: { assert("Switch case on string failed", false); }
    string{"Hello!"}: { passed = true; }
  }
  assert("Failed to hit positive switch case for string", passed);

  passed = false;
  switch .SwitchVariant0 {
    .SwitchVariant0: {
      passed = true;
    }
    .SwitchVariant1: {
      assert("Switch on enum value failed", false);
    }
  }
  assert("Failed to hit positive switch case for enum", passed);

  /*  With return value as expression :  */

  new_int := switch integer {
    0: { return integer; }
    1: { return -1; }
  }

  assert("Return value of switch statement failed", new_int == integer);

  // test range based shiz.
  passed = false;
  switch 0 {
    0..10: {
      passed = true;
    }
    10..20: {
      assert("switch on range passing in number failed", false);
    }
  }
  assert("Failed to pass range based switch statement", passed);

  assert("Returns in switched failed", switch_helper() == 5);
}

#test test_range_var :: () {
  r : Range = 0..10;
  assert("range variable failed", r.first == 0 && r.last == 10);

  i: int;
  for z in r {
    assert("range iteration failed", i == z);
    i++;
  }
}

#test test_string_enum :: () {
  b: bool = EnumOfStrings.A == string{"Hello"};
  assert("String enum failed", b);
}

#test test_slicing_array :: () {
  arr := #make(s64[], 1000);
  assert("Length", arr.length == 1000);

  /*
    Ranges are always max-exclusive right now.
    0..10 == 0->9;
    We don't currently have a way to represent max inclusive ranges.
  */
  for i in 0..10 {
    arr[i] = 100;
  }

  subarr := arr[0..10];

  for i in 0..10 {
    assert("Slice failed", subarr[i] == arr[i]);
  }

  assert("Slice failed", subarr.length == 10);
}

#test test_switch_statement :: () {
  arr := #make(s64[], 1000);
  assert("Length", arr.length == 1000);

  /*
    Ranges are always max-exclusive right now.
    0..10 == 0->9;
    We don't currently have a way to represent max inclusive ranges.
  */
  for i in 0..10 {
    arr[i] = 100;
  }

  subarr := arr[0..10];

  for i in 0..10 {
    assert("Slice failed", subarr[i] == arr[i]);
  }

  assert("Slice failed", subarr.length == 10);
}

#test test_init_list_ctor :: () {
  i : InitListTestCtorStruct = {5, 5};
  assert("init list calling ctor failed", i.z == 25);
}

func_returns_tuple :: () -> <int, int> {
  return <10, 10>;
}

func_takes_tuple_arg :: (tuple: <int, int>) -> <int, int> {
  a, b := tuple;
  return <a + 10, b + 10>;
}

#test test_tuples :: () {
  t1 : <int, int, int> = <0, 1, 2>;
  {
    a,b,c := t1;
    assert("Declaring typed tuple failed.", a == 0 && b == 1 && c == 2);
  }

  t2 := <3, 2, 1, 0>;

  {
    a,b,c,d := t2;
    assert("Destructuring inferred tuple failed.", a == 3 && b == 2 && c == 1 && d == 0);
  }

  array : <int, int>[] = {<10, 10>};
  //array ~= <10, 10>;

  {
    a, b := array[0];
    assert("Storing tuple in array failed", a == 10 && b == 10);
  }

  ptr : <int, int>* = new <int, int>(10, 10);
  {
    a, b := *ptr;
    assert("Calling new with tuple failed", a == 10 && b == 10);
  }
  delete(ptr);

  // ! Bug: This just completely fails. The type ends up being null during the subscript.
  // ! Really every line here is bugged. No idea why, I wish we had generics so we didn't have to do this hackiness.
  //! map : <int, int>[string];
  //! {
  //!   map["Hi"] = <10, 10>;
  //!   a, b := map["Hi"];
  //!   assert("tuple in map failed", a == 10 && b == 10);
  //! }

  ptr_arr: <int, int>*[];
  ptr_arr ~= new <int, int>(10, 10);

  {
    a, b := *(ptr_arr[0]);
    assert("Calling new with tuple failed", a == 10 && b == 10);
  }

  delete(ptr_arr[0]);

  {
    a, b := func_returns_tuple();
    assert("returning tuple from function failed", a == 10 && b == 10);
  }

  {
    tuple := <0, 0>;
    a, b := func_takes_tuple_arg(tuple);
    assert("returning tuple from function that took it as arg and mutated it failed", a == 10 && b == 10);
  }
}

#test test_set_field_with_reflection :: () {
 reflector: Reflector;
 type := #type(Reflector);
 field := type.fields[0];
 integer: int = 100;
 field.set(&reflector, integer);
 assert("reflection field.set() failed.", reflector.n == 100);
}

#test test_get_field_with_reflection :: () {
 reflector: Reflector;
 reflector.n = 100;
 type := #type(Reflector);
 field := type.fields[0];
 n := *(int*)field.get(&reflector);
 assert("reflection field.set() failed.", n == 100);
}

#test test_function_overloads :: () {
  t := #type(overloaded(10));
  assert("overload with integer arg failed to call", strcmp(t.name, "int") == 0);
  t = #type(overloaded(12.5));
  assert("overload with float arg failed to call", strcmp(t.name, "float") == 0);
  xaryu: Xaryu;
  xaryu.value = 100;
  t = #type(overloaded(xaryu));
  assert("overload with float arg failed to call", strcmp(t.name, "Xaryu") == 0);

  assert("overload with different number of parameters failed", overloaded(1, 2) == 2);

  /*
    ! Bug. Overloads fail to get the actual correct overload often when theres a similar first parameter,
    ! But there's a different following parameter. There's probably a repro on this.
  */
  //! assert("overload with different number of parameters failed", overloaded(1, 2.0) == 2);

}

JsonValueDeleter :: struct {
  vals: JsonValue*[];
  add ::(val: JsonValue*) {
    vals ~= val;
  }
  #dtor :: () {
    for val in vals {
      delete(val);
    }
  }
}

#test test_json_types :: () {
  deleter: JsonValueDeleter;
  val : JsonValue*;

  val = json_parse_string("true");
  deleter.add(val);
  assert("bool", val.is_boolean());

  val = json_parse_string("32.1");
  deleter.add(val);
  assert("number", val.is_number());

  val = json_parse_string("\"hello\"");
  deleter.add(val);
  assert("string", val.is_string());

  val = json_parse_string("[1, 2, 3]");
  deleter.add(val);
  assert("array", val.is_array());

  val = json_parse_string("{\"key\": \"value\"}");
  deleter.add(val);
  assert("object", val.is_object());

  val = json_parse_string("null");
  deleter.add(val);
  assert("null", val.is_null());
}

#test test_json_values :: () {
  deleter: JsonValueDeleter;
  val : JsonValue*;

  val = json_parse_string("true");
  deleter.add(val);
  assert("bool", val.as_boolean() == true);

  val = json_parse_string("32.1");
  deleter.add(val);
  assert("number", val.as_number() == atof("32.1"));

  val = json_parse_string("\"hello\"");
  deleter.add(val);
  assert("string", val.as_string() == "hello");

  val = json_parse_string("[1, 2, 3]");
  deleter.add(val);
  assert("array length", val.as_array().length == 3);
  assert("array element 0", val.get(0).as_number() == 1);
  assert("array element 1", val.get(1).as_number() == 2);
  assert("array element 2", val.get(2).as_number() == 3);

  val = json_parse_string("{\"key\": \"value\"}");
  deleter.add(val);
  assert("object key", val.get("key").as_string() == "value");
}

#test test_json_comprehensive :: () {
  deleter: JsonValueDeleter;
  val : JsonValue*;

  val = json_parse_file("test.json");
  deleter.add(val);
  assert("string", val.get("string").as_string() == "Hello, World!");
  assert("number", val.get("number").as_number() == 42);
  assert("boolean", val.get("boolean").as_boolean() == true);
  assert("null_value", val.get("null_value").is_null());

  array_val := val.get("array");
  assert("array length", array_val.as_array().length == 4);
  assert("array element 0", array_val.get(0).as_number() == 1);
  assert("array element 1", array_val.get(1).as_string() == "two");
  assert("array element 2", array_val.get(2).as_boolean() == false);
  assert("array element 3", array_val.get(3).is_null());

  object_val := val.get("object");
  assert("nested_string", object_val.get("nested_string").as_string() == "Nested Hello");
  assert("nested_number", object_val.get("nested_number").as_number() == atof("3.14"));
  assert("nested_boolean", object_val.get("nested_boolean").as_boolean() == false);

  nested_array_val := object_val.get("nested_array");
  assert("nested_array length", nested_array_val.as_array().length == 3);
  assert("nested_array element 0", nested_array_val.get(0).as_string() == "a");
  assert("nested_array element 1", nested_array_val.get(1).as_string() == "b");
  assert("nested_array element 2", nested_array_val.get(2).as_string() == "c");

  nested_object_val := object_val.get("nested_object");
  assert("deeply_nested_key", nested_object_val.get("deeply_nested_key").as_string() == "Deep Value");
}


#test test_array_reflection :: () {
  fixed: int[3] = {1, 2, 3};
  fixed_type := #type(fixed);
  index: int = 0;
  fixed_elements := fixed_type.elements((char*)&fixed);
  assert("Fixed array length mismatch", fixed_elements.length == 3);
  for elem in fixed_elements {
    assert("Fixed array element mismatch", (*(int*)elem.data) == fixed[index]);
    ++index;
  }

  dynamic: int[] = {3, 2, 1};
  dynamic_type := #type(dynamic);
  index = 0;
  dynamic_elements := dynamic_type.elements((char*)&dynamic);
  assert("Dynamic array length mismatch", dynamic_elements.length == 3);
  for elem in dynamic_elements {
    assert("Dynamic array element mismatch", (*(int*)elem.data) == dynamic[index]);
    ++index;
  }
}

BitfieldTest :: struct {
  #bitfield(1) i : u32 = 0;
  #bitfield(2) z: u32 = 3;
}

#test test_bitfield_in_struct :: () {
  test: BitfieldTest;
  assert("bitfield failed to equal 0", test.i == 0);
  assert("bitfield z failed to equal 3", test.z == 3);
}



/*
  Finally function overloading seems to be done! Or so it seems.
  Please test.
*/

add :: (a: s32, b: s32) -> s32 { return a + b; }
add :: (a: float, b: s32) -> s32 { return ((s32)a) + b; }
add :: (a: s32, b: float) -> s32 { return a + ((s32)b); }
add :: (a: s32, b: u32) -> s32 { return a + ((s32)b); }
add :: (a: s32) -> s32 { return a + 2; }
add :: (a: s32, b: s32, c: s32) -> s32 { return a + b + c; }

#test test_function_overload :: () {
  a := add(1, 1);
  assert("expected 2",   a == 2);
  a = add(1.0, 1);
  assert("expected 2",   a == 2);
  a = add(1, 1.0);
  assert("expected {2}", a == 2);
  a = add(1, (u32)1);
  assert("expected {2}", a == 2);
  a = add(1);
  assert("expected {3}", a == 3);
  a = add(1, 2, 3);
  assert("expected {6}", a == 6);

}

#test test_call_statics :: () {
  Static :: struct {
    #static counter :: () -> s32 {
      #static i: s32 = 0;
      return i++;
    }
  }
  for i in 0..10 {
    assert("Static member method with static local failed", Static::counter() == i);
  }
}


#test test_conditional_compilation :: () {
  #def CHEESE;

  #ifdef HAMBURGER {
    CONSTANT0 :: 100;
  } else ifdef CHEESE {
    CONSTANT0 :: 20;
  } else if true {
    CONSTANT0 :: 10;
  }
  
  assert("ifdef failed", CONSTANT0 == 20);
  #undef CHEESE;

  #def HAMBURGER;

  #ifdef HAMBURGER {
    CONSTANT1 :: 100;
  } else ifdef CHEESE {
    CONSTANT1 :: 20;
  } else if true {
    CONSTANT1 :: 10;
  }
  
  assert("ifdef failed", CONSTANT1 == 100);

  #undef HAMBURGER;
  
  #ifdef HAMBURGER {
    CONSTANT2 :: 100;
  } else ifdef CHEESE {
    CONSTANT2 :: 20;
  } else if true {
    CONSTANT2 :: 10;
  }
  
  assert("ifdef failed", CONSTANT2 == 10);

}
