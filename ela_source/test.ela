#import core
// #import directory
// #import dlfcn
// #import file
// #import raylib
// #import gl
// #import interned_string
// #import json
// #import memory
// #import net
// #import pthread
#import reflection

#c_flags "-fsanitize=address,leak,undefined"

XaryuStruct :: struct {
  f: float ;
}

Reflector :: struct {
  n: int;
}

#ifdef INIT_LIST_CONSTRUCTOR {
  InitListTestCtorStruct :: struct {
    z : int;
    #ctor :: fn(n : int, f: int) {
      z = n * f;
    }
  }

  #test test_init_list_ctor :: fn() {
    i : InitListTestCtorStruct = {5, 5};
    assert("init list calling ctor failed", i.z == 25);
  }
}

InitListStruct :: struct {
  a: int;
  b: int;
  c: int;
}

Union :: union {
  a: int = -1;
  b: int;
  c: int;
}

impl Union {
  method :: fn(self*, n: int) {
    assert("union equality check in method failed", n == self.a && n == self.b && n == self.c);
  }
}

_Vec2 :: union {
  #anon :: struct {
    x: int;
    y: int;
    z: int;
  };
  values: int[3];
}

impl _Vec2 {
  method :: fn(self*, n: int) {
    assert("union equality check in method failed", n == self.x && n == self.y && n == self.z);
    assert("union equality check in method failed", n == self.values[0] && n == self.values[1] && n == self.values[2]);
  }
  something :: fn() -> #self {
    return {};
  }
}

JVector2 :: struct {
  x: float32;
  y: float32;
}

JVector3 :: struct {
  vec2: JVector2;
  z: float32;
}

Node :: struct {
  next: Node*;
}

Array :: struct {
  ptr: Node[10];
}

IHaveAMethod :: struct {}

impl IHaveAMethod {
  method :: fn(self*) -> float32 {
    return 0.0;
  }
  parameter_method :: fn(self*, x: float32) -> float32 {
      return x;
  }
}


Xaryu :: struct {
  value: int;
}

impl Xaryu {
  to_string :: fn(self) -> string {
    return "XarBar";
  }
}



#flags Banana :: enum  {
  Unripe,
  Ripe,
  Overripe,
  Rotten,
}

MyEnum :: enum {
  Some,
  Other,
  Value = 100 * 2,
}

MakeStruct2 :: struct {
  f: float;
  n: int;
}

SwitchCaseEnum :: enum {
  SwitchVariant0,
  SwitchVariant1,
}



#test test_for :: fn() {
  for i in 0..10 {
    assert("i should be less than 10", i < 10);
    return;
  }

  for i in 10..0 {
    assert("i should be greater than 0", i > 0);
    return;
  }

  arr: s32[];
  for v in arr {
      assert("Unexpected case in array loop", false);
      return;
  }
  assert("End of test_for reached", true);
}

#test test_while :: fn() {
  b: bool = true;
  while b {
      assert("while condition == true", b == true);
      return;
  }
  assert("End of test_while reached", true);
}

#test test_if_1 :: fn() {
  v: bool = true;
  hit: bool = false;
  if v {
      assert("v should be true", v == true);
      hit = true;
  } else {
      assert("Unexpected case", false);
  }
  assert("failed to fall through if statement", hit);
}

#test test_if_2 :: fn() {
  v: bool = false;
  hit: bool = true;
  if v {
      assert("Unexpected case", false);
  } else if !v {
      hit = true;
  }
  assert("fell through if else, but didn't set the variable", hit);
}

#test test_if_3 :: fn() {
  v: bool = false;
  hit: bool = true;
  if v {
      assert("Unexpected case", false);
  } else if v {
      assert("Unexpected case", false);
  } else {
      hit = true;
  }
  assert("fell though if,if_else,else but didn't set the variable", hit);
}

#test test_comp_assign :: fn() {
  deref: s32 = 1;
  deref += deref;
  assert("+=", deref == 2);
  deref -= deref;
  assert("-=", deref == 0);
  deref *= deref;
  assert("*=)", deref == 0);
  deref = 2;
  deref /= deref;
  assert("/=", deref == 1);
  deref = 2;
  deref %= deref;
  assert("%=", deref == 0);
  deref &= deref;
  assert("&=", deref == 0);
  deref |= deref;
  assert("|=", deref == 0);
  deref ^= deref;
  assert("^=", deref == 0);
  deref <<= deref;
  assert("<<=", deref == 0);
  deref >>= deref;
  assert(">>=", deref == 0);
}

#test test_operators :: fn() {
  left: s32 = 1;
  right: s32 = 1;
  result: s32;
  result_bool: bool;
  result_bool = left == right;
  assert("left should equal right", result_bool == true);
  result_bool = left != right;
  assert("left should not equal right", result_bool == false);
  result_bool = left < right;
  assert("left should not be less than right", result_bool == false);
  result_bool = left > right;
  assert("left should not be greater than right", result_bool == false);
  result_bool = left <= right;
  assert("left should be less than or equal to right", result_bool == true);
  result_bool = left >= right;
  assert("left should be greater than or equal to right", result_bool == true);
  result_bool = left && right;
  assert("left and right should be true", result_bool == true);
  result_bool = left || right;
  assert("left or right should be true", result_bool == true);

  result = left + right;
  assert("left + right should be 2", result == 2);
  result = left - right;
  assert("left - right should be 0", result == 0);
  result = left * right;
  assert("left * right should be 1", result == 1);
  result = left / right;
  assert("left / right should be 1", result == 1);
  result = left % right;
  assert("left % right should be 0", result == 0);
  result = left & right;
  assert("left & right should be 1", result == 1);
  result = left | right;
  assert("left | right should be 1", result == 1);
  result = left ^ right;
  assert("left ^ right should be 0", result == 0);
  result = left << right;
  assert("left << right should be 2", result == 2);
  result = left >> right;
  assert("left >> right should be 0", result == 0);
}

#test test_relational_results :: fn() {
  test1: bool = (1 == 1 + 2) || 1 == 2;
  test2: bool = (3 > 2) && (2 < 4);
  test3: bool = !(5 <= 5) || (6 >= 6);
  test4: bool = (7 != 8) && (9 == 9);
  assert("test1 should be false", test1 == false);
  assert("test2 should be true", test2 == true);
  assert("test3 should be true", test3 == true);
  assert("test4 should be true", test4 == true);
}

#test test_address_of :: fn() {
  v: s32 = 0;
  addr_of_v: s32* = &v;
  assert("address of grabbed a non-null ptr", addr_of_v != null);
  v = *addr_of_v;
  assert("deref'ing a ptr grabbed with &v failed to == the same value as when it was defined.", v == 0);
}

#test test_malloc :: fn() {
  ptr: s32* = malloc(4);
  assert("malloc'd pointer was null", ptr != null);
  free(ptr);
  ptr = null;
  assert("freed ptr and set to null was not == null", ptr == null);
}

many_params :: fn(a: float32, b, c, d) -> float32 {
  return a * b * c * d;
}

mul_params :: fn(n: float32, f) -> float32 {
  return n * f;
}

#test test_param :: fn() {
  assert("params of 1.5 * 2.0 expected to equal 3.0", mul_params(1.5, 2.0) == 3.0);
  assert("multiplying many params failed, or default param", many_params(1.0, 2.0, 4.0, 1.0) == 8.0);
}

returns :: fn() -> s32  {
  return 1;
}

#test test_implicit_numerical_casting :: fn() {
  u1: u8;
  u2: u16 = u1;
  u3: u32 = u2;
  u4: u64 = u3;
  assert("unable to upcast successfully", u4 == u1);

  s1: s8;
  s2: s16 = s1;
  s3: s32 = s2;
  s4: s64 = s3;
  assert("unable to upcast successfully", s1 == s4);

  f: float;
  f1: float64 = f;
  assert("unable to upcast successfully", f == f1);
}

#test test_return_value :: fn() {
  assert("function expected to return 1", returns() == 1);
}

#test test_struct_single_level :: fn() {
  v: JVector2;
  assert("v.x != 0.0", v.x == 0.0);
  assert("v.y != 0.0", v.y == 0.0);
}

#test test_struct_nested_once :: fn() {
  v: JVector3;
  assert("v.vec2.x != 0.0", v.vec2.x == 0.0);
  assert("v.vec2.y != 0.0", v.vec2.y == 0.0);
  assert("v.z != 0.0", v.z == 0.0);
}

#test test_struct_assign_member :: fn() {
  v: JVector2;
  v.x = 10.0;
  v.y = 10.0;
  assert("assigning v.x = 10.0 failed", v.x == 10.0);
  assert("assigning v.y = 10.0 failed", v.y == 10.0);
}

#test test_struct_assign_nested_member :: fn() {
  v: JVector3;
  v.vec2.x = 1.0;
  v.vec2.y = 2.0;
  v.z = 3.0;
  assert("assigning v.vec2.x = 1.0 failed", v.vec2.x == 1.0);
  assert("assigning v.vec2.y = 1.0 failed", v.vec2.y == 2.0);
  assert("assigning v.z = 3.0 failed", v.z == 3.0);
}

struct_as_param :: fn(v: JVector2)  -> float32 {
  return v.x;
}

#test test_struct_as_param :: fn() {
  v: JVector2;
  assert("", struct_as_param(v) == 0.0);
}

something :: fn(f: float32) -> float32 {
  return f;
}

#test test_struct_member_as_param :: fn() {
  v: JVector2;
  assert("passing dot expr struct member as param failed", something(v.x) == 0.0);
}

#test test_local_function :: fn() {
  local_function :: fn() -> s32 {
      return 0;
  }
  assert("failed to get 0 from local function call", local_function() == 0);
}

#test test_chained_dot_subscript :: fn() {
  a: Array;
  a.ptr[0].next = null;
  assert("failure: a.ptr[0].next != null", a.ptr[0].next == null);

  n: Node ;
  a.ptr[0].next = &n;
  assert("failure: a.ptr[0].next != null", a.ptr[0].next != null);
}

#test test_subscript :: fn() {
  arr: s32[100];
  arr[50] = 0;
  assert("subscript 50 on s32[100] failed to == 0", arr[50] == 0);
  n: int;
  ++n;
}

#test test_referencing_pointer :: fn() {
  node: Node;
  node.next = malloc(sizeof(Node));
  other: Node;
  node.next.next = &other;
  assert("mallocing 'next' of 'Node' failed.", node.next != null);
  assert("dereferencing other into node.next failed.", node.next.next != null);
  free(node.next);
}

// testing conflicting definitons. expected: compiler error if failed.
#test for_loop_2 :: fn() {
  for i in 0..10 {
      i = i;
  }
  for i in 0..10 {
    i = i;
  }

  array: int[];

  for k in array {
    k = k;
  }
  for *k in array {
    k = k;
  }
}

#test test_make_cast :: fn() {
  big: u16 = #make(u16, 65365);
  small: u8 = #make(u8, big);
  assert("failed to down cast", small == (big % 255));
}

#test test_method :: fn() {
  owner: IHaveAMethod ;
  assert("failed to get 0.0 from method.", owner.method() == 0.0);
  assert("failed to get 0.0 from method (passing back param).", owner.parameter_method(0.0) == 0.0);
}

#test test_enum_flags :: fn() {
  flags := Banana::Unripe | Banana::Overripe;
  assert("flags & Banana::Unripe failed.", (flags & Banana::Unripe) != 0);
}

#test test_regular_enum :: fn() {
  value := MyEnum::Some;
  value1 := MyEnum::Value;
  assert("MyEnum::Value failed to == 100 * 2", value1 == 100 * 2);
  assert("Zero case of enum did not equal 0", value == 0);
}

#test test_type_alias :: fn() {
  #alias XaryuBarSchnar :: int;
  i: XaryuBarSchnar = 0;
  assert("type alias failed", i == 0);
}

#test test_comp_assign_non_iden :: fn() {
  arr: float32[12];
  arr[0] = 10;
  arr[0] += 10;
  assert("comp assign arr[0] += 10 failed to == 20.", arr[0] == 20);

  xarbars:  XaryuStruct[1];
  xarbars[0].f = 10.0;
  xarbars[0].f += 10.0;
  assert("comp assign xarbars[0].f += 10.0; failed to == 20.0", xarbars[0].f == 20.0);
}

#test test_union_type :: fn() {
  test_union: Union;
  test_union.a = 10;
  assert("union variants failed to equal each other", test_union.a == test_union.b && test_union.b == test_union.c);
  test_union.method(10);
}

#test test_two_way_implicit_conversion_bin_ops :: fn() {
  v: s32;
  v1: s8;
  f: float32;
  assert("failed to convert both ways", v + v1 == 0 && v1 + v == 0);
}

#test test_union_type_anonymous_sub_struct :: fn() {
  vec: _Vec2;
  vec.method(0); // this does the assertions
}

#test test_new :: fn() {
  vec: _Vec2* = new _Vec2(10, 10, 10);
  vec1: _Vec2* = new _Vec2(10, 10, 10);
  assert("new allocated structs using ctor failed to equal each other", vec.x == vec1.x && vec.y == vec1.y && vec.z == vec1.z);
  delete (vec, vec1);
}

#test test_delete :: fn() {
	arr := new int;
	arr2 := new int;
	delete(arr, arr2);
  assert("delete", arr == null && arr2 == null);
}

#ifdef TEST_ITERATOR_MOJ_STRUKT {
  MojStruktIter :: struct{
    data: int[10];
    
    begin :: fn() -> int* {
      return (int*)data;
    }
    end :: fn() -> int* {
      return (int*)data + 10;
    }
  }

  #test test_defined_iterator ::fn() {
    count := 0;
    new_struct : MojStruktIter;
    for item in new_struct {
      count += 1;
    }
    assert("custom iterator failed to iterate correctly", count == 10);
  }
}

#test custom_iterator_increment :: fn() {
  for i in #make(Range, 0, 10, 2) {
    assert("iter increment failed to be divisible by 2", i % 2 == 0);
  }
  for i in #make(Range, 0, 10, 3) {
    assert("iter increment failed to be divisible by 3", i % 3 == 0);
  }
}

#test ptr_iter_range_base :: fn() {
  array: s8[] = {0,1,2,3};
  n: int ;
  for *v in array {
    assert("", n == *v);
    ++n;
  }

  n = 0;
  // TODO: tidy up the confusing and often strangely inconsistent semantics around construction of types.
  arr : s8[]* = new s8[] ({0,1,2,3});
  for v in *arr {
    assert("", n == v);
    ++n;
  }
  delete(arr);
}

#ifdef CUSTOM_ITERATOR_TEST {
  CustomIteratorStruct :: struct {
    value: int*;
  }

  impl CustomIteratorStruct {
    create :: fn() -> #self {
      self: #self;
      self.value = malloc(sizeof(int) * 10);
      memset(self.value, 0, sizeof(int) * 10);
      return self;
    }

    // These aren't going to work with C++ iterators anymore, because of the way we compile methods now.
    // We will just have to implement our own iterator system, preferably with an interface.
    begin :: fn(self*) -> int * {
      return value;
    }
    end :: fn(self*) -> int * {
      return value + 10;
    }

    // TODO: re-add this.
    #dtor :: fn() {
      free(value);
    }
  }

  #test test_custom_iterator :: fn() {
    iter: CustomIteratorStruct;
    n: int;
    for k in iter {
      assert("iterator value failed to equal 0", k == 0);
      n++;
    }
    assert("failed to iterate the appropriate number of times", n == 10);
  }
}



#test test_string :: fn() {
  my_string : string = "Xaryu Baryu";
  assert("string length failed to equal expected value", my_string.length == 11);
}

#test test_array :: fn() {
  array : int[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  assert("array length failed to equal expected value", array.length == 11);
  // !BUG: we need to fix this.
  // !This throws C++ errors during compilation
  // !because initializer lists have strangely strict typing
  // !compared to normal narrowing rules.
  // !bool[] arr = {0,1,2,3,4,5};
}

#test test_aliasing :: fn() {
  #alias int_ptr :: int*;
  p: int* = malloc(sizeof(int));
  other: int_ptr  = p;
  assert("alias failed to equal pointed to type field.", p == other);
  free(p);
}

#test test_string_interpolation :: fn() {
  xarbar: Xaryu;
  interp: string = $"{xarbar}";
  assert("unexpected interpolated string value", strcmp(interp.data, "XarBar") == 0);
  interp = $"{(1 + 1) * 2}";
  assert("unexpected interpolated string value", strcmp(interp.data, "4") == 0);
}

#test test_initializer_lists :: fn() {
  scalar: int;
  arr: int[]  = {0, 1, 2};
  fixed: int[3] = {0, 1, 2};
}

#test test_cast :: fn() {
  n: int = 10;
  f: float  = n as float;
  assert("Cast failed", f == 10.0);
}

#test test_underscores_in_number_literals :: fn() {
  n: int = 1_000_000;
  assert("number literal with underscores failed to equal expected value", n == 1000000)
}

#test test_array_concat_operator :: fn() {
  array: int[];
  array ~= 10;
  assert("concat operator failed", array.length == 1);
}

#test test_array_pop_operator :: fn() {
  array: int[];
  for i in 0..100 {
    array ~= 10;
  }
  n: int;
  for i in 0..100 {
    n = ~array;
  }
  assert("pop operator failed", array.length == 0 && n == 10);
}

#test test_array_erase_operator :: fn() {
  array: int[] ;
  array ~= 10;
  array ~~ 10;
  assert("failed to erase element from array with ~~", array.length == 0);
}

XarBarInitListTestStruct :: struct {
  x: float;
  y: float;
}

New :: fn(v: XarBarInitListTestStruct) -> XarBarInitListTestStruct {
  return v;
}

#test test_init_list_as_implicit_parameter :: fn() {
  v := New(XarBarInitListTestStruct{x: 0.0, y: 0.0});
  assert("failed", v.x == 0.0 && v.y == 0.0);
}

#test test_range_based_for_loop_exclusive :: fn() {
  n: int;
  ten := 10;
  zero := 0;

  for i in 0..10 {
    n = i;
  }

  for i in 0..ten {
    n = i;
  }

  for i in zero..ten {
    n = i;
  }

  for i in zero..10 {
    n = i;
  }

  assert("Range based for loop failed.", n == 9);
}

#test test_multidimensional_arrays :: fn() {
  array: int[5][5];
  for x in 0..5 {
    for y in 0..5 {
      array[x][y] = x * y;
    }
  }

  for x in 0..5 {
    for y in 0..5 {
      assert("multidimensional failure", array[x][y] == x * y);
    }
  }

  dynamic : s64[][];
  for x in 0..5 {
    dynamic ~= #make(s64[]);
    for y in 0..5 {
      dynamic[x] ~= x * y;
    }
  }

  assert("length failed", dynamic.length == 5);

  for x in 0..5 {
    for y in 0..5 {
      assert("multidimensional failure", dynamic[x][y] == x * y);
    }
  }
}

#test test_map_aka_associative_array :: fn() {
  variables: int[string];
  map1: int*[char*];

  str1 := #make(string, "Key1");
  str2 := #make(string, "Key2");
  str3 := #make(string, "shouldn't exist");

  variables[str1] = 100;
  variables[str2] = 200;

  assert("Expected: 100", variables[str1] == 100);
  assert("Expected: 200", variables[str2] == 200);

  // assert("Didn't contain known key.", variables.contains(str1));
  // assert("Map contained incorrect key.", !variables.contains(str3));

  variables[str1] = 300;
  assert("Expected: 300", variables[str1] == 300);

  variables[str1] = 0;
  assert("Expected: 0", variables[str1] == 0);

  map1["Something"] = new int(200);
  assert("Expected: 200", *map1["Something"] == 200);

  *map1["Something"] = 400;
  assert("Expected: 400", *map1["Something"] == 400);

  map1["Another"] = new int(500);
  assert("Expected: 500", *map1["Another"] == 500);

  delete(map1["Something"]);
  delete(map1["Another"]);

  // ! BUG : Cannot use multi-dimensional maps. It's terribly designed and needs a rework.
  // ! really, maps should be eliminated and be replaced once generics are back in the language.
}

InitListTest :: struct {
  n : int;
}

returns_an_init_list  :: fn() -> InitListTest {
  return {n: 0};
}

infers_argument_from_init_list :: fn(t: InitListTest) -> InitListTest {
  return t;
}


#test test_init_list_comprehensive :: fn() {
  assert("Init list failed to return from function", returns_an_init_list().n == 0);
  assert("Init list failed to infer from parameter signature", infers_argument_from_init_list(InitListTest{n: 0}).n == 0);
  empty_init_list := InitListTest{};
}

#test subscript_string :: fn() {
  s: string = #make(string, "0,1,2,3");
  s[0] = 10;
}

switch_helper :: fn() -> int {
  number := 5;
  switch number {
    0: { return 0; }
    5: { return 5; }
  }
  return 1;
}

#test test_switch_statements :: fn() {
  integer: int;

  passed := false;
  switch integer {
    0: { passed = true; }
    1: { assert("Switch on int case failed", false);  }
  }

  assert("Failed to hit positive switch case for integer", passed);
  str: string = "Hello!";

  passed = false;
  switch str {
    string::from("Hello"): { assert("Switch case on string failed", false); }
    string::from("Hello!"): { passed = true; }
  }
  assert("Failed to hit positive switch case for string", passed);

  passed = false;
  switch SwitchCaseEnum::SwitchVariant0 {
    SwitchCaseEnum::SwitchVariant0: {
      passed = true;
    }
    SwitchCaseEnum::SwitchVariant1: {
      assert("Switch on enum value failed", false);
    }
  }
  assert("Failed to hit positive switch case for enum", passed);

  /*  With return value as expression :  */

  new_int := switch integer {
    0: { return integer; }
    1: { return -1; }
  }

  assert("Return value of switch statement failed", new_int == integer);

  // test range based shiz.
  passed = false;
  switch 0 {
    0..10: {
      passed = true;
    }
    10..20: {
      assert("switch on range passing in number failed", false);
    }
  }
  assert("Failed to pass range based switch statement", passed);

  assert("Returns in switched failed", switch_helper() == 5);
}

#test test_range_var :: fn() {
  r : Range = 0..10;
  assert("range variable failed", r.first == 0 && r.last == 10);

  i: int;
  for z in r {
    assert("range iteration failed", i == z);
    i++;
  }
}

#test test_slicing_array :: fn() {
  arr := #make(s64[], 1000);
  assert("Length", arr.length == 1000);

  /*
    Ranges are always max-exclusive right now.
    0..10 == 0->9;
    We don't currently have a way to represent max inclusive ranges.
  */
  for i in 0..10 {
    arr[i] = 100;
  }

  subarr := arr[0..10];

  for i in 0..10 {
    assert("Slice failed", subarr[i] == arr[i]);
  }

  assert("Slice failed", subarr.length == 10);
}

#test test_switch_statement :: fn() {
  arr := #make(s64[], 1000);
  assert("Length", arr.length == 1000);

  /*
    Ranges are always max-exclusive right now.
    0..10 == 0->9;
    We don't currently have a way to represent max inclusive ranges.
  */
  for i in 0..10 {
    arr[i] = 100;
  }

  subarr := arr[0..10];

  for i in 0..10 {
    assert("Slice failed", subarr[i] == arr[i]);
  }

  assert("Slice failed", subarr.length == 10);
}


func_returns_tuple :: fn() -> (int, int) {
  return (10, 10);
}

func_takes_tuple_arg :: fn(tuple: (int, int)) -> (int, int) {
  a, b := tuple;
  return (a + 10, b + 10);
}

#test test_tuples :: fn() {
  t1 : (int, int, int) = (0, 1, 2);
  {
    a,b,c := t1;
    assert("Declaring typed tuple failed.", a == 0 && b == 1 && c == 2);
  }

  t2 := (3, 2, 1, 0);

  {
    a,b,c,d := t2;
    assert("Destructuring inferred tuple failed.", a == 3 && b == 2 && c == 1 && d == 0);
  }

  array : (int, int)[] = {(10, 10)};
  array ~= (10, 10);

  {
    a, b := array[0];
    assert("Storing tuple in array failed", a == 10 && b == 10);
  }

  ptr : (int, int)* = new (int, int)(10, 10);
  {
    a, b := *ptr;
    assert("Calling new with tuple failed", a == 10 && b == 10);
  }
  delete(ptr);

  ptr_arr: (int, int)*[];
  ptr_arr ~= new (int, int)(10, 10);

  {
    a, b := *(ptr_arr[0]);
    assert("Calling new with tuple failed", a == 10 && b == 10);
  }

  delete(ptr_arr[0]);

  {
    a, b := func_returns_tuple();
    assert("returning tuple from function failed", a == 10 && b == 10);
  }

  {
    tuple := (0, 0);
    a, b := func_takes_tuple_arg(tuple);
    assert("returning tuple from function that took it as arg and mutated it failed", a == 10 && b == 10);
  }

  nested := (1, (2, 3));

  {
    _, tup := nested;
    a, b := tup;
    assert("nested tup failed", a == 2 && b == 3 && _ == 1);
  }

}

#test test_set_field_with_reflection :: fn() {
 reflector: Reflector;
 type := #type(Reflector);
 field := type.fields[0];
 integer: int = 100;
 field.set(&reflector, integer);
 assert("reflection field.set() failed.", reflector.n == 100);
}

#test test_get_field_with_reflection :: fn() {
 reflector: Reflector;
 reflector.n = 100;
 type := #type(Reflector);
 field := type.fields[0];
 n := *(field.get(&reflector) as int*);
 assert("reflection field.set() failed.", n == 100);
}

#ifdef JSON_TESTS {
  JsonValueDeleter :: struct {
    vals: JsonValue*[];
  }

  impl JsonValueDeleter {
    add :: fn(self*, val: JsonValue*) {
      self.vals ~= val;
    }
    #dtor :: fn(self*) {
      for val in self.vals {
        delete(val);
      }
    }
  }

  #test test_json_types :: fn() {
    deleter: JsonValueDeleter;
    val : JsonValue*;

    val = json_parse_string("true");
    deleter.add(val);
    assert("bool", val.is_boolean());

    val = json_parse_string("32.1");
    deleter.add(val);
    assert("number", val.is_number());

    val = json_parse_string("\"hello\"");
    deleter.add(val);
    assert("string", val.is_string());

    val = json_parse_string("[1, 2, 3]");
    deleter.add(val);
    assert("array", val.is_array());

    val = json_parse_string("{\"key\": \"value\"}");
    deleter.add(val);
    assert("object", val.is_object());

    val = json_parse_string("null");
    deleter.add(val);
    assert("null", val.is_null());
  }

  #test test_json_values :: fn() {
    deleter: JsonValueDeleter;
    val : JsonValue*;

    val = json_parse_string("true");
    deleter.add(val);
    assert("bool", val.as_boolean() == true);

    val = json_parse_string("32.1");
    deleter.add(val);
    assert("number", val.as_number() == atof("32.1"));

    val = json_parse_string("\"hello\"");
    deleter.add(val);
    assert("string", val.as_string() == "hello");

    val = json_parse_string("[1, 2, 3]");
    deleter.add(val);
    assert("array length", val.as_array().length == 3);
    assert("array element 0", val.get(0).as_number() == 1);
    assert("array element 1", val.get(1).as_number() == 2);
    assert("array element 2", val.get(2).as_number() == 3);

    val = json_parse_string("{\"key\": \"value\"}");
    deleter.add(val);
    assert("object key", val.get("key").as_string() == "value");
  }

  #test test_scalar_deserialization :: fn() {
    n : int = 100;
    json := json_serialize(&n, #type(int));
    deleter: JsonValueDeleter;
    deleter.add(json);
    n = 0;
    assert("json  serialize  scalar", json.is_number());
    err := json_deserialize_scalar(json, &n, #type(int));
    assert("json error", !err.has_value);
    assert("json deserialize scalar", n == 100);
  }

  MyJsonStruct :: struct {
    n: s64;
    b: float32;
  }
  impl MyJsonStruct {
    to_string ::fn(self*) -> string {
      return $"MyJsonStruct [n: {self.n}, b: {self.b}]";
    }
  }

  #test test_struct_deserialization :: fn() {
    n : MyJsonStruct = {
      100,
      200.0
    };
    json := json_serialize(&n, #type(MyJsonStruct));
    deleter: JsonValueDeleter;
    deleter.add(json);
    n = {};
    assert("json  serialize  object", json.is_object());
    err := json_deserialize(json, &n, #type(MyJsonStruct));
    assert("json error", !err.has_value);
    assert("json deserialize object", n.n == 100 && n.b == 200.0);
  }

  #test test_json_comprehensive :: fn() {
    deleter: JsonValueDeleter;
    val : JsonValue*;

    val = json_parse_file("test.json");
    deleter.add(val);
    assert("string", val.get("string").as_string() == "Hello, World!");
    assert("number", val.get("number").as_number() == 42);
    assert("boolean", val.get("boolean").as_boolean() == true);
    assert("null_value", val.get("null_value").is_null());

    array_val := val.get("array");
    assert("array length", array_val.as_array().length == 4);
    assert("array element 0", array_val.get(0).as_number() == 1);
    assert("array element 1", array_val.get(1).as_string() == "two");
    assert("array element 2", array_val.get(2).as_boolean() == false);
    assert("array element 3", array_val.get(3).is_null());

    object_val := val.get("object");
    assert("nested_string", object_val.get("nested_string").as_string() == "Nested Hello");
    assert("nested_number", object_val.get("nested_number").as_number() == atof("3.14"));
    assert("nested_boolean", object_val.get("nested_boolean").as_boolean() == false);

    nested_array_val := object_val.get("nested_array");
    assert("nested_array length", nested_array_val.as_array().length == 3);
    assert("nested_array element 0", nested_array_val.get(0).as_string() == "a");
    assert("nested_array element 1", nested_array_val.get(1).as_string() == "b");
    assert("nested_array element 2", nested_array_val.get(2).as_string() == "c");

    nested_object_val := object_val.get("nested_object");
    assert("deeply_nested_key", nested_object_val.get("deeply_nested_key").as_string() == "Deep Value");
  } 

}

#test test_array_reflection :: fn() {
  fixed: int[3] = {1, 2, 3};
  fixed_type := #type(fixed);
  index: int = 0;
  fixed_elements := fixed_type.elements((&fixed) as char*);
  assert("Fixed array length mismatch", fixed_elements.length == 3);
  for elem in fixed_elements {
    assert("Fixed array element mismatch", *(elem.data as int*) == fixed[index]);
    ++index;
  }

  dynamic: int[] = {3, 2, 1};
  dynamic_type := #type(dynamic);
  index = 0;
  dynamic_elements := dynamic_type.elements((&dynamic) as char*);
  assert("Dynamic array length mismatch", dynamic_elements.length == 3);
  for elem in dynamic_elements {
    assert("Dynamic array element mismatch", *(elem.data as int*) == dynamic[index]);
    ++index;
  }
}

BitfieldTest :: struct {
  #bitfield(1) i : u32 = 0;
  #bitfield(2) z: u32 = 3;
}

#test test_bitfield_in_struct :: fn() {
  test: BitfieldTest;
  assert("bitfield failed to equal 0", test.i == 0);
  assert("bitfield z failed to equal 3", test.z == 3);
}

Static :: struct;
impl Static {
  counter :: fn() -> s32 {
    #static i: s32 = 0;
    return i++;
  }
}

#test test_call_statics :: fn() {
  for i in 0..10 {
    assert("Static member method with static local failed", Static::counter() == i);
  }
}

#test test_conditional_compilation :: fn() {
  #def CHEESE;

  #ifdef HAMBURGER {
    CONSTANT0 :: 100;
  } else ifdef CHEESE {
    CONSTANT0 :: 20;
  } else {
    CONSTANT0 :: 10;
  }
  
  assert("ifdef failed", CONSTANT0 == 20);
  #undef CHEESE;

  #def HAMBURGER;

  #ifdef HAMBURGER {
    CONSTANT1 :: 100;
  } else ifdef CHEESE {
    CONSTANT1 :: 20;
  } else if true {
    CONSTANT1 :: 10;
  }
  
  assert("ifdef failed", CONSTANT1 == 100);

  #undef HAMBURGER;
  
  #ifdef HAMBURGER {
    CONSTANT2 :: 100;
  } else ifdef CHEESE {
    CONSTANT2 :: 20;
  } else  {
    CONSTANT2 :: 10;
  }

  
  assert("ifdef failed", CONSTANT2 == 10);

  #ifndef HAMBURGER {
    CONSTANT3 :: 100;
  } 

  assert("ifndef failed", CONSTANT3 == 100);

  #def thing

  #ifndef thing {
    for i in 0..100 {
      n := i;
      if i % 3 == 1 {
        n -= 2;
      }
    }
    assert("ndef", false);
  } else {
    for i in 0..100 {
      n := i;
      if i % 3 == 1 {
        n -= 2;
      }
    }
    assert("ndef", true);
  }

  #undef thing;
  
  #ifndef thing {
    for i in 0..100 {
      n := i;
      if i % 3 == 1 {
        n -= 2;
      }
    }
    assert("ndef", true);
  } else {
    for i in 0..100 {
      n := i;
      if i % 3 == 1 {
        n -= 2;
      }
    }
    assert("ndef", false);
  }
}

#test test_scope_resolution_statement :: fn() {
  // (string::from("Hi!").contains("H"));
}


add_generic :: fn![T](a: T, b: T) -> T {
  return a + b;
}

#test test_generic_add :: fn() {
  assert("generic_add_float failed", add_generic![float](100.0, 100.0) == 200.0);
  assert("generic_add_int failed", add_generic![int](5, 6) == 11);
}

#ifdef GENERIC_STRUCT_WITH_FUNCTIONS {
  GenericStruct :: struct![T] {
    a: T;
    b: T;
  }

  impl GenericStruct {
    run :: fn(self*) -> T {
      return self.a + self.b;
    }
  }

  #test test_generic_struct :: fn() {
    int_adder: GenericStruct![int] = {5, 6};
    assert("generic type failure", int_adder.run() == 5 + 6);
    float_adder: GenericStruct![float] = {1.23, 4.56};
    assert("generic type failure", float_adder.run() == 1.23 + 4.56);
  }
}

// ! Todo fix this.
#ifdef TEST_GENERIC_UNION {
  GenericUnion :: union![T, T1] {
    a: T;
    b: T1;
  }

  #test test_generic_union :: fn() {
    int_adder: GenericUnion![int, float];
    int_adder.a = 11;
    assert("generic type failure", int_adder.a == 5 + 6);
    int_adder.b = 1.23 + 4.56;
    assert("generic type failure", int_adder.b == 1.23 + 4.56);
  }
}

#ifdef FUNCTION_POINTER_TEST {
  function_pointer_helper :: fn(x: int, y: int) -> int { return x * y; }
  //! See emitter 'get_function_pointer_dynamic_array_declaration', this is super bugged.
  //! particularly, lists/ dynamic arrays of function pointers are super shoddy.
  #test test_function_pointer_alias :: fn() {
    #alias FunctionPointer :: fn* (int, int) -> int;
    ptr := &function_pointer_helper;
    assert("Function pointer call", ptr(2, 3) == 6);
  // ! This works (compiles), but it causes a 'wild jump' aka the PC goes to non-executable memory region..
  // ! Wtf?
    // array: FunctionPointer[] = {&function_pointer_helper};
    // from_arr : FunctionPointer = &array[0];
    // assert("Array of function pointers", from_arr(2, 3) == 6);
  // ! 
    // fixed: FunctionPointer[12];
    // fixed[0] = &function_pointer_helper;
    // from_fixed : FunctionPointer = &fixed[0];

    // assert("Fixed array of function pointers", from_fixed(2, 3) == 6);

    // function :: fn() -> FunctionPointer {
    //   return &function_pointer_helper;
    // }

    // returned_ptr : FunctionPointer = function();
    // assert("Function returning function pointer", returned_ptr(2, 3) == 6);
  }
}


AnonSubUnion :: struct {
  #anon :: union {
    a: int;
  }
}

#test test_anon_union_in_struct :: fn() {
  anon: AnonSubUnion;
  anon.a = 100;
  assert("Anon sub union failed", anon.a == 100);
}
