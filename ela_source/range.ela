
_Range_Iterator :: struct {
  current:   u64;
  end_value: u64;
  increment: u64;
  is_reverse: bool;

  #ctor :: fn(start: u64, end_value: u64, is_reverse: bool, increment: u64) {
    current = start;
    this.end_value = end_value;
    this.is_reverse = is_reverse;
    this.increment = increment;
  }

  #operator(*) :: fn() -> u64 { return current; }

  #operator(++) :: fn() -> _Range_Iterator  {
    if (is_reverse) {
      current -= increment;
    } else {
      current += increment;
    }
    return *this;
  }

  #operator(!=) :: fn(other: _Range_Iterator) -> bool  {
    if (is_reverse) {
      return current > other.end_value;
    } else {
      return current < other.end_value;
    }
  }
}

Range :: struct {
  #alias u64 :: u64;
  #ctor :: fn() {}
  #ctor :: (first: u64, last: u64, increment: u64 = 1) {
    : first(first), last(last), span(last - first), is_reverse(first > last),
        increment(increment)

    this.first = first;
    this.last = last;
    this.increment = increment;
    if (is_reverse) {
      first--;
      span = first - last;
    }
  }
  Range(const Range &other) {
    first = other.first;
    last = other.last;
    span = other.span;
    is_reverse = other.is_reverse;
    increment = other.increment;
  }
  u64 first = 0, last = 0, span = 0, increment = 1;
  bool is_reverse = false;


  _Range_Iterator begin() const {
    return _Range_Iterator(first, last, is_reverse, increment);
  }
  _Range_Iterator end() const { return _Range_Iterator(first, last, is_reverse, increment); }
  _Range_Iterator begin() { return _Range_Iterator(first, last, is_reverse, increment); }
  _Range_Iterator end() { return _Range_Iterator(first, last, is_reverse, increment); }

  #operator(==) :: fn(number: u64) -> bool {
    return number >= first && number <= last;
  }

  contains :: fn(number: u64) -> bool {
    return number >= first && number <= last;
  }

  string to_string() {}
};