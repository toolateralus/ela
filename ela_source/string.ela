#import core;

// For now, we'll just use a simple null terminated string.
struct string {
  char *data;
  length: s32;
  is_view: bool;
  #ctor :: () {}
  #ctor :: (str: char*) {
    if str == null then return;
    length = 0;
    while (str[length] != '\0') {
      length++;
    }
    data = malloc(sizeof(char) * length + 1);
    data[length] = '\0';
    memcpy(data, str, length);
  }
  #ctor :: (begin: char*, end: char*, is_view: bool = false) {
    this.is_view = is_view;
    length = end - begin;
    if (is_view) {
      data = begin;
    } else {
      data = malloc(sizeof(char) * length + 1);
      memcpy(data, begin, length);
      data[length] = '\0';
    }
  }
  #dtor :: () {
    if (data && !is_view) then free(data);
  }

  #operator([]) :: (n: int) -> char {
    return data[n];
  }

  // Slicing a view.
  #operator([])(range: Range) -> string {
    return {data + range.first, data + range.last, true};
  }

  substr :: (start: int , end: int) -> string {
    // TODO: clamp here? instead of returning empty?.
    if start < 0 || end > length || start > end then return {};
    return {data + start, data + end, false};
  }

  substr :: (Range r) -> string { return substr(r.first, r.last); }

  push :: (value : char) {
    new_data: char* = malloc(sizeof(char) * length + 2);
    memcpy(new_data, data, length);
    new_data[length] = value;
    new_data[length + 1] = '\0';
    free(data);
    data = new_data;
    length++;
  }

  erase_at :: (index: int) {
    if (index < 0 || index >= length || length <= 0) then return;
    new_data: char* = malloc(sizeof(char) * length);
    memcpy(new_data, data, index * sizeof(char));
    memcpy(new_data + index, data + index + 1, (length - index - 1) * sizeof(char));
    free(data);
    data = new_data;
    length++;
    data[length] = '\0';
  }

  insert_at :: (index: int, value: char) {
    if (data == null) {
      data = malloc(2);
      data[0] = value;
      data[1] = '\0';
      length = 1;
      return;
    }
    new_data: char* = malloc(sizeof(char) * length + 2);
    memcpy(new_data, data, index * sizeof(char));
    new_data[index] = value;
    memcpy(new_data + index + 1, data + index, (length - index) * sizeof(char));
    free(data);
    data = new_data;
    length++;
    data[length] = '\0';
  }
  insert_substr_at :: (index: int, substr: string) {
    if (data == null) {
      data = malloc(substr.length + 1);
      memcpy(data, substr.data, substr.length);
      data[substr.length] = '\0';
      length = substr.length;
      return;
    }
    substr_length: int = substr.length;
    new_data: char* = malloc(length + substr_length + 1);
    memcpy(new_data, data, index * sizeof(char));
    memcpy(new_data + index, substr.data, substr_length * sizeof(char));
    memcpy(new_data + index + substr_length, data + index, (length - index) * sizeof(char));
    free(data);
    data = new_data;
    length += substr_length;
    data[length] = '\0';
  }

  pop :: () -> char {
    if (length <= 0) {
      return 0;
    }
    value: char = data[length - 1];
    new_data: char* = malloc(length);
    memcpy(new_data, data, (length - 1) * sizeof(char));
    new_data[length - 1] = '\0';
    free(data);
    data = new_data;
    length--;
    return value;
  }

  #copy :: (other: string) {
    if (other.data) {
      length = other.length;
      data = malloc(length + 1);
      memcpy(data, other.data, length);
      data[length] = '\0';
    }
  }

  #operator(=) :: (other: string) -> string {
    if (this != &other) {
      if (data) free(data);
      if (other.data) {
        length = other.length;
        data = malloc(length + 1);
        memcpy(data, other.data, length);
        data[length] = '\0';
      } else {
        data = null;
        length = 0;
      }
    }
    return *this;
  }

  begin :: () -> char* { return data; }
  end :: () -> char* { return data + length; }

  #operator(==) :: (other: string) -> bool {
    if length != other.length then return false;
    for i in 0..length {
      if data[i] != other.data[i] then return false;
    }
    return true;
  }

  #operator(!=) :: (other: string) -> bool { return !(*this == other); }

  begin :: () -> char* { return data; }
  end :: () -> char* { return data + length; }
};