#import core;
#import raylib;

#compiler_flags "-g"

#foreign usleep :: (c: int);

playing := false;
timer: Timer;

get_seconds :: (f: float32) -> int {
  return (int)(f * 1_000_000);
}

bpm_slider : SliderF = {
  "bpm", // text
  Rectangle{0,0, 150, 40}, // rectangle
  Style { WHITE.with_alpha(75), BLACK, GREEN, 16, false, 0.0, 0.0 }, // style
  30,  // min
  240,   // max
  null,  // value
  false, // held
};

subdivision_slider : SliderI = {
  string{"subdivisions"}, // text
  Rectangle{0, 110, 150, 40}, // rectangle
  Style { WHITE.with_alpha(75), BLACK, GREEN, 16, false, 0.0, 0.0 }, // style
  1,  // min
  20,   // max
  null,  // value
  false // held
};

play_button_style : Style = {
  WHITE,
  CLEAR,
  GREEN,
  16,
  true,
  5.0,
  2.0,
};


subdivisions: int = 4;
check_buttons: CheckButton[];

check_button_style: Style = {
  WHITE,
  RED,
  GREEN,
  16,
  false,
  5.0,
  2.0,
}

index : s32 = 0;

play_callback :: () {
  playing = !playing;
  timer.last_tick_time = 0;
  index = 0;
}

SequenceChannel :: struct {
  check_buttons: CheckButton[];
  sound: Sound;
  active: bool;
  y_offset: float;
  
  draw :: () {
    if subdivisions != check_buttons.length {
      while subdivisions > check_buttons.length {
        x : float = (float)(check_buttons.length * 40);
        y : float = GetScreenHeight() / 2.0 + y_offset;
        println($"Addd button {check_buttons.length} at: {x}, {y}");
        check_buttons ~= {
          false,
          Rectangle{x, y, 35, 35},
          check_button_style,
          string{null},
        }
      }
      while check_buttons.length > subdivisions {
        button := ~check_buttons;
        println($"Removed button {check_buttons.length} at {button.rect.x}, {button.rect.y}");
      }
    }
    for *button; check_buttons {
      button.draw();
    }
  }
  update :: (index: int) {
    if check_buttons[index].value {
      PlaySound(sound);
    }
  }
}

channels: SequenceChannel[];

sequencer :: () {
  if playing && timer.tick() {
    for *channel; channels {
      channel.update(index);
    }
    index = (index + 1 % subdivisions) % subdivisions;
  }
}

bpm : float = 120;

main :: () {
  InitAudioDevice();
  InitWindow(800, 600, "Sequencer");
  
  channels ~= #make(SequenceChannel, {
    CheckButton[]{},
    LoadSound("snare.wav"),
    true,
    0.0
  });
  
  while !WindowShouldClose() {
    ClearBackground(BLACK);
    BeginDrawing();
      sequencer();
      bpm_slider.value = &bpm;
      bpm_slider.draw();

      timer.interval = 1 / (bpm / 60);
      
      subdivision_slider.value = &subdivisions;
      subdivision_slider.draw();
      
      for *channel; channels {
        channel.draw();
      }
      
      {
        if playing {
          play_button_style.highlighted = RED;
        } else {
          play_button_style.highlighted = GREEN;
        }
        draw_button("play", {0, 50, 100, 40}, play_button_style, &play_callback);
      }
    EndDrawing();
  }
}