#include "interfaces.ela";

// libc allocators
#foreign free :: fn(ptr: void*) -> void;
#foreign malloc :: fn(nbytes: u64) -> void*;
#foreign calloc :: fn(num: u64, size: u64) -> void*;
#foreign realloc :: fn(ptr: void*, size: u64) -> void*;

// libc memory functions
#foreign memcpy :: fn(dest: void*, src: void*, n: u64) -> void*;
#foreign memset :: fn(dest: void*, c: int, n: u64) -> void*;

// libc io
#foreign printf :: fn(format: c_string, ...) -> int;
#foreign exit :: fn(code: int);

#static print :: fn![T](str: T) {
  printf("%s", $"{str}".data);
}

#static println :: fn![T](str: T) {
  printf("%s\n", $"{str}".data);
}

// TODO: we could have a panic_handler function pointer so you can have more refined control,
// and then you'd be able to handle recovering from a panic as well.
#static panic :: fn(msg: string) {
  println(msg);
  exit(1);
}

Dynamic_Array :: struct![T] {
  data:     T*;
  length:   u64;
  capacity: u64;
}

impl![T] Dynamic_Array![T] {
  // You should probably not call this function, and you do not need to for normal push operations.
  // In the case you want to shrink your array, you can pass in array.length or whatever you want to shrink to,
  // and this will set your length appropriately.
  resize :: fn(self*, new_capacity: u64) {
    if new_capacity < self.capacity && new_capacity < self.length then self.length = new_capacity; // Truncating.

    self.capacity = new_capacity;
    self.data = realloc(self.data, #type(T).size * self.capacity);
    if !self.data then panic("Failed to allocate in Dynamic_Array![{#type(T).name}]");
  }

  push   :: fn(self*, v: T) {
    if self.length + 1 >= self.capacity {
      if self.capacity == 0 then self.capacity = 4;
      self.resize(self.capacity * 2);
    }
    self.data[self.length] = v;
    self.length++;
  }

  pop    :: fn(self*) -> T {
    if self.length == 0 then panic("Attempted to pop from an empty Dynamic_Array![{#type(T).name}]");
    value := self.data[self.length - 1];
    self.length -= 1;
    return value;
  }

  deinit :: fn(self*) {
    free(self.data);
    self.data = null;
    self.length = 0;
  }

  at :: fn(self*, index: u64) -> T {
    return self.data[index];
  }
}

impl![T] Clone for Dynamic_Array![T] {
  clone :: fn(self*) -> #self {
    new_data := malloc(#type(T).size * self.capacity);
    if !new_data then panic("Failed to allocate in Dynamic_Array clone");
    memcpy(new_data, self.data, #type(T).size * self.length);
    return {
      data: new_data,
      length: self.length,
      capacity: self.capacity,
    }
  } 
}

impl![T] Iterable![T] for Dynamic_Array![T] {
  iter :: fn(self*) -> Iter![T] {
    return {
      ptr: self.data,
      end: self.data + self.length-1 // TODO; verify -1 is correct
    }
  }
}

#test test_Dynamic_Array_push_at :: fn() {
  array : Dynamic_Array![int];

  {
    defer array.deinit();
    for i in 0..100 {
      array.push(i);
    }
    assert("Array push failed to meet expected length", array.length == 100);
    for i in 0..100 {
      assert("array.at(i) != i", array.at(i) == i);
    }
  }

  assert("Dynamic_Array failed to deinit", array.data == null && array.length == 0);  
}

#test test_Dynamic_Array_pop :: fn() {
  array : Dynamic_Array![int];

  {
    defer array.deinit();
    for i in 0..100 {
      array.push(i);
    }
    for i in 0..100 {
      value := array.pop();
      assert("array.pop() != 99 - i", value == 99 - i);
    }
    assert("Array pop failed to meet expected length", array.length == 0);
  }

  assert("Dynamic_Array failed to deinit", array.data == null && array.length == 0);
}

#test test_Dynamic_Array_resize :: fn() {
  array : Dynamic_Array![int];

  {
    defer array.deinit();
    array.resize(2);
    assert("Array resize failed to set capacity", array.capacity == 2);
    for i in 0..2 {
      array.push(i);
    }
    assert("Array resize failed to meet expected length", array.length == 2);
  }

  assert("Dynamic_Array failed to deinit", array.data == null && array.length == 0);
}

#test test_Dynamic_Array_shrink :: fn() {
  array : Dynamic_Array![int];

  {
    defer array.deinit();
    for i in 0..100 {
      array.push(i);
    }
    assert("Array push failed to meet expected length", array.length == 100);

    array.resize(50);
    assert("Array shrink failed to meet expected length", array.length == 50);
    assert("Array shrink failed to set capacity", array.capacity == 50);

    for i in 0..50 {
      assert("array.at(i) != i", array.at(i) == i);
    }
  }

  assert("Dynamic_Array failed to deinit", array.data == null && array.length == 0);
}

#test test_Dynamic_Array_clone :: fn() {
  array : Dynamic_Array![int];
  clone : Dynamic_Array![int];
  {
    defer array.deinit();
    for i in 0..100 {
      array.push(i);
    }

    clone = array.clone();
    defer clone.deinit();


    assert("Array clone failed to meet expected length", clone.length == 100);
    for i in 0..100 {
      assert("lone.at(i) != i", clone.at(i) == i);
    }

    // Modify the original array and check if the clone does not reflect the changes
    array.push(100);
    assert("Clone should not reflect changes in the original array", clone.length == 100);
    assert("lone.at(100) should not exist", clone.length == 100);
  }

  assert("Dynamic_Array failed to deinit", array.data == null && array.length == 0);
  assert("Clone Dynamic_Array failed to deinit", clone.data == null && clone.length == 0);
}

#test test_Dynamic_Array_view :: fn() {
  array : Dynamic_Array![int];
  view  : Dynamic_Array![int];
  {
    defer array.deinit();
    for i in 0..100 {
      array.push(i);
    }

    // Take a view of the array
    view = array;

    assert("Array view failed to meet expected length", view.length == 100);
    for i in 0..100 {
      assert("view.at(i) != i", view.at(i) == i);
    }

    // ! Document me or change me somehow::
    // ! If we take a view by simple assignment, when me mutate a view, it only changes the T*,
    // ! but obviously not the length nor capacity of the original.
    // ! How do we want to handle this?

    // ! We could have a slice type like rust?
    // ! We could allow it even though it's quite bug prone.
    // ! We could enforce .clone() on non-ptr assignment?

    array.push(100);
    assert("View should reflect changes in the original array", view.length == 100);
    assert("view.at(100) != 100", view.at(100) == 100);
  }

  assert("Dynamic_Array failed to deinit", array.data == null && array.length == 0);
}
