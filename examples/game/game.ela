#import core;

#import gl;

#compiler_flags "-g";

intensity := 0.12;
vertexCount := 36;
indexCount := 36;

WINDOW_WIDTH := 800;
WINDOW_HEIGHT := 600;

u32 ebo;
u32 vbo;
u32 vao;

Vertex :: struct {
  Vec2 position;
  Vec2 normal;
  Vec2 uv;
  #ctor :: () {}
  #ctor :: (Vec2 _position, _normal, _uv) {
    position = _position;
    normal = _normal;
    uv = _uv;
  }
}

Window window = #make(Window, WINDOW_WIDTH, WINDOW_HEIGHT, "Xaryu's Banana");
Shader shader = #make(Shader, #read "../res/shader.vert", #read "../res/shader.frag");

Vertex[6] vertices;

Vec2[] positions = {
  #make(Vec2, -1.0, -1.0), #make(Vec2, 1.0, -1.0),
  #make(Vec2, 1.0,  1.0), #make(Vec2, -1.0,  1.0)
};

Vec2 normal = #make(Vec2, 0.0, 0.0);

Vec2[] uvs = {
  #make(Vec2, 0.0, 0.0), #make(Vec2, 1.0, 0.0),
  #make(Vec2, 1.0, 1.0), #make(Vec2, 0.0, 1.0)
};

int[] indices = {
  0, 1, 2, 2, 3, 0
};

generate_quad_vertices :: () {
  len := 6;
  for int i; i < len; ++i {
    idx := indices[i];
    uv := uvs[idx];
    vertices[i].position = positions[idx];
    vertices[i].normal = normal;
    vertices[i].normal = uv;
  }
}

run_game :: () -> s8 {
  if window.handle == null { return 1; }
  generate_quad_vertices();
  glClearColor(0.0, intensity, intensity, 1.0);
  glViewport(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);
  glfwSwapInterval(1);
  // TODO: future:
  // use a polymorphic function to take any Vertex type and use CTTI/RTTI to
  // build buffers based on field order and size and offset etc.
  {
    // xaryu's banana
    glGenBuffers(1, &ebo);
    glGenVertexArrays(1, &vao);
    glGenBuffers(1, &vbo);
    glBindVertexArray(vao);
    glBindBuffer(GL.ARRAY_BUFFER, vbo);

    stride := sizeof(Vertex);

    glVertexAttribPointer(0, 2, GL.FLOAT, false, stride, #make(void*, 0));
    glEnableVertexAttribArray(0);

    glVertexAttribPointer(1, 2, GL.FLOAT, false, stride, #make(void*, sizeof(float) * 2));
    glEnableVertexAttribArray(1);

    glVertexAttribPointer(2, 2, GL.FLOAT, false, stride, #make(void*, sizeof(float) * 4));
    glEnableVertexAttribArray(2);

    glBufferData(GL.ARRAY_BUFFER, sizeof(Vertex) * vertexCount, #make(void*, vertices), GL.STATIC_DRAW);
  }

  shader.use();
  Vec2 modelPosition;
  viewProjectionMatrix := Mat4_identity();

  is_key_down :: (int key) -> bool  {
    state := glfwGetKey(window.handle, key);
    return state == KeyPress.Pressed || state == KeyPress.Repeating;
  }

  take_input :: (Vec2* position) {
    old_pos := *position;
    Vec2 move_vec;

    if is_key_down(Key.W) { move_vec.y -= 0.1; }
    if is_key_down(Key.S) { move_vec.y += 0.1; }
    if is_key_down(Key.A) { move_vec.x += 0.1; }
    if is_key_down(Key.D) { move_vec.x -= 0.1; }

    if move_vec.sqr_mag() != 0 {
      *position = *position + move_vec;
    }
  }

  while !window.should_close() {
    window.clear();
    if is_key_down(Key.ESCAPE) { break; }
    shader.set_Mat4("viewProjectionMatrix", &viewProjectionMatrix);
    shader.set_Vec2("modelPosition", &modelPosition);
    take_input(&modelPosition);
    glDrawArrays(GL.TRIANGLES, 0, vertexCount);
    window.present();
  }

  glfwTerminate();
  return 0;
}

main :: ()  {
  matrix := Mat4_identity();
  run_game();
}