// assert that --freestanding was used in compiler invocation.
#ifndef FREESTANDING { #error "This is only supposed to be used freestanding. don't use `ela r`, use `run.sh`!" }

// specify 
// -fPIC  :: position independent code,
// -c for :: compiling to object files.
// -m64   :: 64 bit architecture
#c_flags "-fPIC -c -m64 -o main.o"

// our function declared in print.s
#foreign print :: fn(f: char *);
#foreign exit :: fn(code: int);

memset :: fn(p: char *, value: u64, len: u64) {
  for i in 0..len {
    p[i] = value;
  }
}

memcpy :: fn(dest: char**, src: char*, len: u64) {
  for i in 0..len {
    (*dest)[i] = src[i];
  }
}

// used from 'print' in print.s
// just easier to write in ela.
#export strlen :: fn(s: char*) -> int {
  i: int;
  while s[i] != '\0' {
    ++i;
  }
  return i;
}

// A simple linear allocator (aka arena) 
// for a freestanding environment without allocations.
LinearAlloc :: struct {
  mem : char[1024 * 24],
  ptr : u64,
  size: u64,
}

impl LinearAlloc {
  create :: fn() -> #self {
    self: #self;
    self.size = 1024 * 24;
    memset(self.mem as char*, 0, self.size);
    return self;
  }

  alloc :: fn(self*, size: u64) -> char* {
    data := &self.mem[self.ptr];
    self.ptr += size;
    
    if (self.ptr > self.size) {
      print("\e[031mLinear allocator ran out of memory \e[033m(expected for demo)\n");
      exit(1);
    }

    return data;
  }
}

Vector2 :: struct {
  x: float,
  y: float,
}

// declare main as 'export' (much like 'extern "C"' in cpp) so our assembly program can find it.
// 'export' differs from foreign, because foreign is an external dependency we're importing,
// and 'export' is declaring an externally visible symbol.

// Unlike a normal Ela program, 'main' always has to return an int in a freestanding environment.
// Also, `Env::args()` and other utilities are not immediately available, because of the complete lack of our
// runtime. instead, you may just take `argc` and `argv` in your main, as if it's a C main function.
#export main :: fn(argc: int, argv: c_string*) -> int {

  // create our 'linear allocator' which is just a piece of memory sitting on the stack.
  allocator := LinearAlloc::create();

  // say hello!
  print("\e[1;4;32mHello (free-standing) World!\e[0m\n");
  
  // example of getting a 'dynamically allocated' struct.
  // intentionally run the allocator out of memory, so we can 'panic' with exit(1);
  while {
    v: Vector2* = allocator.alloc(sizeof(Vector2));
    v1: Vector2* = allocator.alloc(sizeof(Vector2));
    memcpy((&v1) as char**, v as char*, sizeof(Vector2));
  }
  
  return 0;
}
