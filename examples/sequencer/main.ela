#import core;
#import raylib;

#import directory;
#import file;

#compiler_flags "-g"


playing := false;
timer: Timer;
bpm : float = 120;
subdivisions: int = 1;
beats: int = 4;
total_notes: int = 4;

bpm_slider : SliderF = {
  "bpm", // text
  Rectangle{0,0, 150, 40}, // rectangle
  Style { WHITE.with_alpha(75), BLACK, GREEN, 16, false, 0.0, 0.0 }, // style
  30,  // min
  240,   // max
  &bpm,  // value
  false, // held
};

subdivision_slider : SliderI = {
  string{"subdivisions"}, // text
  Rectangle{0, 110, 150, 40}, // rectangle
  Style { WHITE.with_alpha(75), BLACK, GREEN, 16, false, 0.0, 0.0 }, // style
  1,  // min
  20,   // max
  &subdivisions,  // value
  false // held
};

bg_color := LIGHTCYAN;

beats_slider : SliderI = {
  string{"beats"}, // text
  Rectangle{150, 110, 150, 40}, // rectangle
  Style { WHITE.with_alpha(75), BLACK, GREEN, 16, false, 0.0, 0.0 }, // style
  1,  // min
  20,   // max
  &beats,  // value
  false // held
};

play_button_style : Style = {
  WHITE,
  CLEAR,
  GREEN,
  16,
  true,
  5.0,
  2.0,
};

file_dropdown_style : Style = {
  WHITE,
  GRAY,
  GREEN,
  16,
  true,
  5.0,
  2.0,
}

sequence_channel_style : Style = {
  WHITE,
  GRAY,
  GREEN,
  16,
  true,
  5.0,
  2.0,
}

check_buttons: CheckButton[];

check_button_style: Style = {
  WHITE,
  RED,
  GREEN,
  16,
  false,
  5.0,
  2.0,
}

reset_button_style : Style = {
  WHITE,
  RED,
  GREEN,
  16,
  false,
  5.0,
  2.0,
};

index : s32 = 0;

play_callback :: () {
  playing = !playing;
  timer.last_tick_time = 0;
  index = 0;
}

color_index: s32;

get_sequencer_style :: (style: Style) -> Style {
  color_index++;
  index := color_index % All_Colors.length;
  index_1 := index + 2 % All_Colors.length;
  
  style.foreground = All_Colors[index];
  style.background = All_Colors[index_1].with_alpha(75);
  style.highlighted = style.background.with_alpha(255);
  return style;
}

SequenceChannel :: struct {
  check_buttons: CheckButton[];
  sound: Sound;
  active: bool;
  style: Style;
  volume : int = 50;
  old_volume : int = 50;
  volume_slider: SliderI;
  #ctor :: () {}
  #ctor :: (_sound: Sound, _style: Style, name: string) {
    sound = _sound;
    style = _style;
    volume_slider = {
      name, // text
      Rectangle{0, 0, 146, 36}, // rectangle
      style, // style
      0,  // min
      100,   // max
      null,  // value
      false, // held
    }
  }
  draw :: (x: float, y: float) {
    if total_notes != check_buttons.length {
      while total_notes > check_buttons.length {
        _x : float = x + 150 + (float)(check_buttons.length * 40) + 2;
        check_buttons ~= {
          false,
          Rectangle{_x, y, 36, 36},
          style,
          string{null},
          true,
        }
      }
      while check_buttons.length > total_notes {
        button := ~check_buttons;
      }
    }
    volume_slider.value = &volume;
    volume_slider.rect.x = x + 2;
    volume_slider.rect.y = y + 2;
    volume_slider.draw();
    index := 0;
    for *button; check_buttons {
      button.rect.x = x + 150 + index * 40 + 2;
      button.rect.y = y + 2;
      index++;
      button.draw();
    }
  }
  
  update :: (index: int) {
    if volume != old_volume {
      old_volume = volume;
      SetSoundVolume(sound, (float)volume / 100.0);
    }
    if check_buttons[index].value {
      PlaySound(sound);
    }
  }
}

channels: SequenceChannel[];

on_remove_channel :: () {
  if channels.length > 0 then _ := ~channels;
}

on_reset :: () {
  while channels.length > 0 {
    _ := ~channels;
  }
}

on_file_selected :: (index: int);

file_dropdown : DropDown = {
  string[]{},
  Rectangle{0, 250, 125, 30},
  file_dropdown_style,
  -1,
  false,
  &on_file_selected
};

on_file_selected :: (index: int) {
  fileName := file_dropdown.options[index];
  channels ~= #make(SequenceChannel, 
    LoadSound(fileName.data),
    get_sequencer_style(check_button_style),
    fileName
  );
}

sequencer :: () {
  if playing && timer.tick() {
    for *channel; channels {
      channel.update(index);
    }
    index = (index + 1 % total_notes) % total_notes;
  }
}

main :: () {
  bg_color.r -= 175;
  bg_color.g -= 175;
  bg_color.b -= 175;
  
  dir := directory_open(".");
  
  InitAudioDevice();
  InitWindow(0, 0, "Sequencer");
  
  SetWindowState(.WindowResizable);
  SetTargetFPS(1000);
  
  for file; dir.files {
    if string_ends_with(file.data, ".wav") || string_ends_with(file.data, ".mp3") || string_ends_with(file.data, ".ogg") {
      file_dropdown.options ~= string{file.data};
    }
  }
  
  while !WindowShouldClose() {
    ClearBackground(bg_color);
    BeginDrawing();
      if IsKeyPressed(.Space) then play_callback();

      seq_y := GetScreenHeight() / 3.0;
      seq_x := 0.0
      for note in 0..total_notes {
        label_x := seq_x + 150.0 + note * 40.0;
        beat := (note * beats) / total_notes + 1;
        subdiv := note % subdivisions + 1;
        str : string = $"{beat}.{subdiv}";
        DrawText(str.data, (int)label_x, (int)(seq_y - 40.0), 12, WHITE);
      }
      if playing {
        cursor_x := seq_x + 150.0 + (index - 1 + total_notes) % total_notes * 40.0
        DrawRectangleLines((int)cursor_x, seq_y, 40, (int)channels.length * 40, ORANGE);
      }

      sequencer();
      bpm_slider.draw();
      bpm = (float)(int)bpm;

      timer.interval = (1 / (bpm / 60)) / subdivisions;

      total_notes = beats * subdivisions;
      
      subdivision_slider.draw();
      beats_slider.draw();
      
      draw_button("reset (no undo)", {(float)GetScreenWidth() - 210.0, 10, 200, 40}, reset_button_style, &on_reset);
      draw_button("remove channel", Rectangle{0, 215, 125, 30}, reset_button_style, &on_remove_channel);
      
      for *channel; channels {
        channel.draw(seq_x, seq_y);
        seq_y += 40
      }
      
      file_dropdown.draw();
      
      {
        if playing {
          play_button_style.highlighted = RED;
        } else {
          play_button_style.highlighted = GREEN;
        }
        draw_button("play", {0, 50, 100, 40}, play_button_style, &play_callback);
      }
    EndDrawing();
  }
}