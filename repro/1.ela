#import core;

// ! These are dependencies for the 2 bugs.
array_realloc :: (array: $T[] *) {
  array.capacity = array.length * 1.5;
  new_data := malloc(sizeof(T) * array.capacity);
  memcpy((void*)new_data, (void*)array.data, sizeof(T) * array.length);
  free((void*)array.data);
  array.data = (T*)new_data;
}

// ! These are dependencies for the 2 bugs.
array_push :: (array: $T[]*, value: $T) {
  capacity := &array.capacity;
  length := &array.length;
  data: T**  = &array.data;

  if *length >= *capacity 
    then array_realloc(array);

  slot := (data[*length]);
  (*slot) = value;
  *length += 1;
}

// ! These are dependencies for the 2 bugs.
array_pop :: (array: $T[]*) -> $T {
  length := &array.length;
  data := &array.data;

  if *length == 0 {
    printf("Error: popped an empty array");
    exit(1);
  }

  *length -= 1;
  return (*data)[*length];
}

/* 
 ! BUG #1
 !generic_fn.cpp:129:5: error: use of undeclared identifier 'array_realloc'
 !  129 |     array_realloc(array);
 !      |     ^ 
  
 ? These functions are showing how when we have a generic function that calls into another generic function that hasn't been called by any
 ? other site, that we don't actually emit a function definition in the emitter. This may be due to not 
  
  
  ? ---- CODE ---- 
  
*     main :: () {
*       array: int[] ;
*       array_push(&array, (int)100);
*     }
  

  
  ? ---- CODE ----
  
  
  * I suspect the issue is caused by the way the emitter is handling generic function calls.
  * I think that once we emit the function call to the array_push, we've already visited and ignored the 
  * function declaation for array_realloc, which didn't have any calls yet when we visited it, because it's body gets ignored
  * until emit time. We need to be pre-visiting these calls somehow, I have no idea how. We should probably have a more
  * comprehensive system for doing generics, maybe even a dedicated visitor. Or a resolver that works like a scheduler.
*/

/*
  ! BUG #2

  ! fn_dependency.cpp -o generic_fn_dependency 
  ! generic_fn_dependency.cpp:129:5: error: use of undeclared identifier 'array_realloc'
  !   129 |     array_realloc(array);
  !       |     ^
  ! generic_fn_dependency.cpp:138:3: error: no matching function for call to 'array_push'
  !   138 |   array_push(&array, (s8)100);
  !       |   ^~~~~~~~~~
  ! generic_fn_dependency.cpp:124:6: note: candidate function not viable: no known conversion from '_array<int> *' to '_array<s8> *' (aka '_array<signed char> *') for 1st argument
  !   124 | void array_push(_array<s8>* array, s8 value) {
  !       |      ^          ~~~~~~~~~~~~~~~~~
 
  ? additionally, we infer the T type by the first one WITHOUT extensions,
  ? which causes problems because our literals attempt to be the smallest literal possible, 
  ? and the explicit casting the backend has to do causes some real big issues
 
  ! Bug 2
  
  ? ---- CODE ----
  
*   main :: () {
*     array: int[] ;
*     array_push(&array, 100);
*   }
  
  
  * I suspect that this issue is caused by us inferring T from the first non-extended argument, which in this case it the 'value' parameter of 'array_push'
  * whereas we really need to infer the type from the first ocurring usage of a particular generic parameter.
  
  ? ---- CODE ----
*/
