#import core;

// ! These are dependencies for the 2 bugs.
array_realloc :: ($T[] *array) {
  array.capacity = array.length * 1.5;
  new_data := malloc(sizeof(T) * array.capacity);
  memcpy((void*)new_data, (void*)array.data, sizeof(T) * array.length);
  free((void*)array.data);
  array.data = (T*)new_data;
}

// ! These are dependencies for the 2 bugs.
array_push :: ($T[] *array, $T value) {
  capacity := &array.capacity;
  length := &array.length;
  T** data = &array.data;

  if *length >= *capacity 
    then array_realloc(array);

  slot := (data[*length]);
  (*slot) = value;
  *length += 1;
}

// ! These are dependencies for the 2 bugs.
array_pop :: ($T[] *array) -> $T {
  length := &array.length;
  data := &array.data;

  if *length == 0 {
    printf("Error: popped an empty array");
    exit(1);
  }

  *length -= 1;
  return (*data)[*length];
}

/* 
 ! BUG #1
 !generic_fn.cpp:129:5: error: use of undeclared identifier 'array_realloc'
 !  129 |     array_realloc(array);
 !      |     ^ 
  
 ? These functions are showing how when we have a generic function that calls into another generic function that hasn't been called by any
 ? other site, that we don't actually emit a function definition in the emitter. This may be due to not 
  
  
  ? ---- CODE ---- 
  
  * main :: () {
  *   int[] array;
  *   array_push(&array, (int)100);
  * }
  
  ? ---- CODE ----
*/

/*
  ! BUG #2

  ! fn_dependency.cpp -o generic_fn_dependency 
  ! generic_fn_dependency.cpp:129:5: error: use of undeclared identifier 'array_realloc'
  !   129 |     array_realloc(array);
  !       |     ^
  ! generic_fn_dependency.cpp:138:3: error: no matching function for call to 'array_push'
  !   138 |   array_push(&array, (s8)100);
  !       |   ^~~~~~~~~~
  ! generic_fn_dependency.cpp:124:6: note: candidate function not viable: no known conversion from '_array<int> *' to '_array<s8> *' (aka '_array<signed char> *') for 1st argument
  !   124 | void array_push(_array<s8>* array, s8 value) {
  !       |      ^          ~~~~~~~~~~~~~~~~~
 
  ? additionally, we infer the T type by the first one WITHOUT extensions,
  ? which causes problems because our literals attempt to be the smallest literal possible, 
  ? and the explicit casting the backend has to do causes some real big issues
 
  ! Bug 2
  
  ? ---- CODE ----
  
  * main :: () {
  *   int[] array;
  *   array_push(&array, 100);
  * }
  
  ? ---- CODE ----
*/