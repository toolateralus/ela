#import core;

#compiler_flags "-g"

XaryuStruct :: struct {
  f: float ;
}

Union :: union {
  a: int;
  b: int;
  c: int;
  method :: (n: int) {
    assert("union equality check in method failed", n == a && n == b && n == c);
  }
  #ctor :: () {
    a = -1;
  }
  #dtor :: () {
    printf("union destructor\n");
  }
}
_Vec2 :: union {
  #anon :: struct {
    x: int;
    y: int;
    z: int;
  };
  values: int[3] ;

  method :: (n: int) {
    assert("union equality check in method failed", n == x && n == y && n == z);
    assert("union equality check in method failed", n == values[0] && n == values[1] && n == values[2]);
  }

  something :: () -> #self {
    return #make(#self);
  }
  
  #ctor :: (_x : int, _y, _z) {
    x = _x;
    y = _y;
    z = _z;
  }

  #ctor :: () {
    memset(#make(void*, values), 0, sizeof(int) * 3);
    x=0;
    y=0;
    z=0;
    //printf();
  }

  #dtor :: () {
    printf("%d, %d, %d", x, y, z);
  }
}

CustomIteratorStruct :: struct {
  value: int* = malloc(sizeof(int) * 10);
  begin :: () -> int * {
    return value;
  }
  end :: () -> int * {
    return value + 10;
  }
  #dtor :: () {
    free(value);
  }
}

Constructible :: struct {
  x: float32;
  #ctor :: (_x: float32) {
      x = _x;
  }
  #ctor :: (other: Constructible) {
      x = other.x;
  }
  #ctor :: () {
    x = 10.0;
  }
}

Vector2 :: struct {
  x: float32;
  y: float32;
}

Vector3 :: struct {
  vec2: Vector2;
  z: float32;
}

Node :: struct {
  next: Node*;
}

Array :: struct {
  ptr: Node[10];
}

IHaveAMethod :: struct {
  method :: () -> float32 {
      return 0.0;
  }
  parameter_method :: (x: float32) -> float32 {
      return x;
  }
}

#flags Banana :: enum  {
  Unripe,
  Ripe,
  Overripe,
  Rotten,
}

MyEnum :: enum {
  Some,
  Other,
  Value = 100 * 2,
}

// Keep this at the top otherwise it messesup the output formatting in the middle
#test test_printf :: () {
  s: char*  = "Hello i am a string";
  printf("testing printing a string: %s\n", s);
  return;
}

#test failure_case :: () {
  assert("This should fail", false);
}

#test test_for :: () {
  for i: s32; i < 10; ++i {
      assert("i should be less than 10", i < 10);
      return;
  }
  arr: s32[];
  for v; arr {
      assert("Unexpected case in array loop", false);
      return;
  }
  assert("End of test_for reached", true);
}

#test test_while :: () {
  b: bool = true;
  while b {
      assert("while condition == true", b == true);
      return;
  }
  assert("End of test_while reached", true);
}

#test test_if_1 :: () {
  v: bool = true;
  hit: bool = false;
  if v {
      assert("v should be true", v == true);
      hit = true;
  } else {
      assert("Unexpected case", false);
  }
  assert("failed to fall through if statement", hit);
}

#test test_if_2 :: () {
  v: bool = false;
  hit: bool = true;
  if v {
      assert("Unexpected case", false);
  } else if !v {
      hit = true;
  }
  assert("fell through if else, but didn't set the variable", hit);
}

#test test_if_3 :: () {
  v: bool = false;
  hit: bool = true;
  if v {
      assert("Unexpected case", false);
  } else if v {
      assert("Unexpected case", false);
  } else {
      hit = true;
  }
  assert("fell though if,if_else,else but didn't set the variable", hit);
}

#test test_comp_assign :: () {
  deref: s32 = 1;
  deref += deref;
  assert("+=", deref == 2);
  deref -= deref;
  assert("-=", deref == 0);
  deref *= deref;
  assert("*=)", deref == 0);
  deref = 2;
  deref /= deref;
  assert("/=", deref == 1);
  deref = 2;
  deref %= deref;
  assert("%=", deref == 0);
  deref &= deref;
  assert("&=", deref == 0);
  deref |= deref;
  assert("|=", deref == 0);
  deref ^= deref;
  assert("^=", deref == 0);
  deref <<= deref;
  assert("<<=", deref == 0);
  deref >>= deref;
  assert(">>=", deref == 0);
}

#test test_operators :: () {
  left: s32 = 1;
  right: s32 = 1;
  result: s32;
  result_bool: bool;
  result_bool = left == right;
  assert("left should equal right", result_bool == true);
  result_bool = left != right;
  assert("left should not equal right", result_bool == false);
  result_bool = left < right;
  assert("left should not be less than right", result_bool == false);
  result_bool = left > right;
  assert("left should not be greater than right", result_bool == false);
  result_bool = left <= right;
  assert("left should be less than or equal to right", result_bool == true);
  result_bool = left >= right;
  assert("left should be greater than or equal to right", result_bool == true);
  result_bool = left && right;
  assert("left and right should be true", result_bool == true);
  result_bool = left || right;
  assert("left or right should be true", result_bool == true);

  result = left + right;
  assert("left + right should be 2", result == 2);
  result = left - right;
  assert("left - right should be 0", result == 0);
  result = left * right;
  assert("left * right should be 1", result == 1);
  result = left / right;
  assert("left / right should be 1", result == 1);
  result = left % right;
  assert("left % right should be 0", result == 0);
  result = left & right;
  assert("left & right should be 1", result == 1);
  result = left | right;
  assert("left | right should be 1", result == 1);
  result = left ^ right;
  assert("left ^ right should be 0", result == 0);
  result = left << right;
  assert("left << right should be 2", result == 2);
  result = left >> right;
  assert("left >> right should be 0", result == 0);
}

#test test_relational_results :: () {
  test1: bool = (1 == 1 + 2) || 1 == 2;
  test2: bool = (3 > 2) && (2 < 4);
  test3: bool = !(5 <= 5) || (6 >= 6);
  test4: bool = (7 != 8) && (9 == 9);
  assert("test1 should be false", test1 == false);
  assert("test2 should be true", test2 == true);
  assert("test3 should be true", test3 == true);
  assert("test4 should be true", test4 == true);
}

#test test_address_of :: () {
  v: s32 = 0;
  addr_of_v: s32* = &v;
  assert("address of grabbed a non-null ptr", addr_of_v != null);
  v = *addr_of_v;
  assert("deref'ing a ptr grabbed with &v failed to == the same value as when it was defined.", v == 0);
}

#test test_malloc :: () {
  ptr: s32* = malloc(4);
  assert("malloc'd pointer was null", ptr != null);
  free(ptr);
  ptr = null;
  assert("freed ptr and set to null was not == null", ptr == null);
}

many_params :: (a: float32, b, c, d = 1.0) -> float32 {
  return a * b * c * d;
}

mul_params :: (n: float32, f) -> float32 {
  return n * f;
}

#test test_param :: () {
  assert("params of 1.5 * 2.0 expected to equal 3.0", mul_params(1.5, 2.0) == 3.0);
  assert("multiplying many params failed, or default param", many_params(1.0, 2.0, 4.0) == 8.0);
}

returns :: () -> s32  {
  return 1;
}

#test test_implicit_numerical_casting :: () {
  u1: u8;
  u2: u16 = u1;
  u3: u32 = u2;
  u4: u64 = u3;
  assert("unable to upcast successfully", u4 == u1);

  s1: s8;
  s2: s16 = s1;
  s3: s32 = s2;
  s4: s64 = s3;
  assert("unable to upcast successfully", s1 == s4);

  f: float;
  f1: float64 = f;
  assert("unable to upcast successfully", f == f1);
}

#test test_return_value :: () {
  assert("function expected to return 1", returns() == 1);
}

#test test_struct_single_level :: () {
  v: Vector2;
  assert("v.x != 0.0", v.x == 0.0);
  assert("v.y != 0.0", v.y == 0.0);
}

#test test_struct_nested_once :: () {
  v: Vector3;
  assert("v.vec2.x != 0.0", v.vec2.x == 0.0);
  assert("v.vec2.y != 0.0", v.vec2.y == 0.0);
  assert("v.z != 0.0", v.z == 0.0);
}

#test test_struct_assign_member :: () {
  v: Vector2;
  v.x = 10.0;
  v.y = 10.0;
  assert("assigning v.x = 10.0 failed", v.x == 10.0);
  assert("assigning v.y = 10.0 failed", v.y == 10.0);
}

#test test_struct_assign_nested_member :: () {
  v: Vector3;
  v.vec2.x = 1.0;
  v.vec2.y = 2.0;
  v.z = 3.0;
  assert("assigning v.vec2.x = 1.0 failed", v.vec2.x == 1.0);
  assert("assigning v.vec2.y = 1.0 failed", v.vec2.y == 2.0);
  assert("assigning v.z = 3.0 failed", v.z == 3.0);
}

struct_as_param :: (v: Vector2)  -> float32 {
  return v.x;
}

#test test_struct_as_param :: () {
  v: Vector2;
  assert("", struct_as_param(v) == 0.0);
}

something :: (f: float32) -> float32 {
  return f;
}

#test test_struct_member_as_param :: () {
  v: Vector2;
  assert("passing dot expr struct member as param failed", something(v.x) == 0.0);
}

#test test_local_function :: () {
  local_function :: () -> s32 {
      return 0;
  }
  assert("failed to get 0 from local function call", local_function() == 0);
}

#test test_chained_dot_subscript :: () {
  a: Array;
  a.ptr[0].next = null;
  assert("failure: a.ptr[0].next != null", a.ptr[0].next == null);

  n: Node ;
  a.ptr[0].next = &n;
  assert("failure: a.ptr[0].next != null", a.ptr[0].next != null);
}

#test test_subscript :: () {
  arr: s32[100];
  arr[50] = 0;
  assert("subscript 50 on s32[100] failed to == 0", arr[50] == 0);
  n: int;
  ++n;
}

#test test_referencing_pointer :: () {
  node: Node;
  node.next = malloc(sizeof(Node));
  other: Node;
  node.next.next = &other;

  assert("mallocing 'next' of 'Node' failed.", node.next != null);
  assert("dereferencing other into node.next failed.", node.next.next != null);
}

// testing conflicting definitons. expected: compiler error if failed.
#test for_loop_2 :: () {
  for i: int; i < 10; ++i {
      i = i;
  }
  for i: int; i < 10; ++i {
      i = i;
  }

  array: int[];

  for k; array {
    k = k;
  }
  for k; array {
    k = k;
  }
}

#test make_parameterless :: () {
  n := #make(Constructible);
  assert("default construction failed.", n.x == 10.0);
}

#test test_copy_make :: () {
  c: Constructible;
  c1: Constructible = #make(Constructible, c);
  assert("failed to copy construct Constructible (struct)", c1.x == c.x);
}

#test test_make :: () {
  c: Constructible = #make(Constructible, 10.0);
  assert("failed to construct", c.x == 10.0);
}

#test test_make_cast :: () {
  big: u16 = #make(u16, 65365);
  small: u8 = #make(u8, big);
  assert("failed to down cast", small == (big % 255));
}

#test test_method :: () {
  owner: IHaveAMethod ;
  assert("failed to get 0.0 from method.", owner.method() == 0.0);
  assert("failed to get 0.0 from method (passing back param).", owner.parameter_method(0.0) == 0.0);
}

#test test_enum_flags :: () {
  flags := Banana.Unripe | Banana.Overripe;
  assert("flags & Banana.Unripe failed.", (flags & Banana.Unripe) != 0);
}

// TODO(Josh) 10/1/2024, 10:08:18 AM :: we need to allow declarations of variables with their enum type.
// Right now we just cast enums to int always.
// We should be able to do MyEnum value = MyEnum.Some;
// This will also allow us to do other stuff, like type safe enums.

#test test_regular_enum :: () {
  value := MyEnum.Some;
  value1 := MyEnum.Value;
  assert("MyEnum.Value failed to == 100 * 2", value1 == 100 * 2);
  assert("Zero case of enum did not equal 0", value == 0);
}

// #test test_type_alias :: () {
//   #alias Xaryu :: int;
//   Xaryu i = 0;
//   assert("type alias failed", i == 0);
// }

// woo hoo complex expressions parse and type very well!.
#test test_comp_assign_non_iden :: () {
  arr: float32[12];
  arr[0] = 10;
  arr[0] += 10;
  assert("comp assign arr[0] += 10 failed to == 20.", arr[0] == 20);

  xarbars:  XaryuStruct[1];
  xarbars[0].f = 10.0;
  xarbars[0].f += 10.0;
  assert("comp assign xarbars[0].f += 10.0; failed to == 20.0", xarbars[0].f == 20.0);
}

// FEATURE(Josh) 10/1/2024, 1:20:30 PM
// implement tagged unions once we have paramterized structs.
// until we have that, this will be nearly pointless.
// #tagged Union :: union {
//   None,
//   Some :: struct {
//     $T data;
//   }
// }

// function :: ($T[] a, $T value) {
  
// }

// int[] arr;


#test test_union_type :: () {
  test_union: Union;
  test_union.a = 10;
  assert("union variants failed to equal each other", test_union.a == test_union.b && test_union.b == test_union.c);
  test_union.method(10);
}

#test test_two_way_implicit_conversion_bin_ops :: () {
  v: s32;
  v1: s8;
  f: float32;
  assert("failed to convert both ways", v + v1 == 0 && v1 + v == 0);
}

#test test_union_type_anonymous_sub_struct :: () {
  vec: _Vec2;
  vec.method(0); // this does the assertions
}

#test test_new :: () {
  vec: _Vec2* = new _Vec2(10, 10, 10);
  vec1: _Vec2* = new _Vec2(10, 10, 10);
  assert("new allocated structs using ctor failed to equal each other", vec.x == vec1.x && vec.y == vec1.y && vec.z == vec1.z);
  delete (vec, vec1);
}

#test ptr_iter_range_base :: () {
  array: s8[] = {0,1,2,3};
  n: int ;
  for *v; array {
    assert("", n == *v);
    ++n;
  }
}

#test test_custom_iterator :: () {
  iter: CustomIteratorStruct;
  n: int;
  for k; iter {
    assert("iterator value failed to equal 0", k == 0);
    n++;
  }
  assert("failed to iterate the appropriate number of times", n == 10);
}

#test test_string :: () {
  my_string : string = "Xaryu Baryu";
  assert("string length failed to equal expected value", my_string.length == 11);
}

#test test_array :: () {
  array : int[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  assert("array length failed to equal expected value", array.length == 11);
  
  // we can always expect the capacity to equal length * 1.5f if we havent mutated it ourselves.
  assert("array capacity failed to equal expected value", array.capacity == 16);
  
  // !BUG: we need to fix this.
  // !This throws C++ errors during compilation
  // !because initializer lists have strangely strict typing
  // !compared to normal narrowing rules.
  // !bool[] arr = {0,1,2,3,4,5};
}

#test test_aliasing :: () {
  #alias int_ptr :: int*;
  p: int* = malloc(sizeof(int));
  other: int_ptr  = p;
  assert("alias failed to equal pointed to type field.", p == other);

  pp: int** = #make(int**, malloc(sizeof(int*)));
  other1: int_ptr* = pp;
  assert("alias failed to equal pointed to type field.", pp == other1);
}

Xaryu :: struct {
  value: int;
  to_string :: () -> char * {
    return "XarBar";
  }
}

#test test_string_interpolation :: () {
  xarbar: Xaryu;
  interp: string = $"{xarbar.to_string()}";
  assert("unexpected interpolated string value", strcmp(interp.data, "XarBar") == 0);
  interp = $"{(1 + 1) * 2}";
  println($"Interpolated value {interp}");
  assert("unexpected interpolated string value", strcmp(interp.data, "4") == 0);
}

overloaded :: (n: int , y) -> int {
  return n * y;
}

overloaded :: (n: int) -> int {
  return n;
}

overloaded :: (f: float ) -> float {
  return f;
}

overloaded :: (xaryu: Xaryu ) -> Xaryu {
  return xaryu;
}

#test test_function_overloads :: () {
  assert("overload with integer arg failed to call", strcmp((#type overloaded(10)).name, "int") == 0);
  assert("overload with float arg failed to call", strcmp((#type overloaded(12.5)).name, "float") == 0);
  xaryu: Xaryu;
  xaryu.value = 100;
  assert("overload with float arg failed to call", strcmp((#type overloaded(xaryu)).name, "Xaryu") == 0);
  
  //! Bug? maybe its fine
  // if an overloaded function has a different number of parameters,
  // and its like (int, int)
  // and we pass it (float, float)
  // it fails to call, and claims wrong number of parameters, because it began searching with the first
  // function that had a float argument at the beginning.
  assert("overload with different number of parameters failed", overloaded(1, 2) == 2);
}

OperatorOverloadTest :: struct {
  value: int = 0;

  #operator(+) :: (something: OperatorOverloadTest) -> int {
    return value + something.value;
  }
  #operator(-) :: (something: OperatorOverloadTest) -> int {
    return value - something.value;
  }
  #operator(*) :: (something: OperatorOverloadTest) -> int {
    return value * something.value;
  }
  #operator(/) :: (something: OperatorOverloadTest) -> int {
    return value / something.value;
  }
  #operator(%) :: (something: OperatorOverloadTest) -> int {
    return value % something.value;
  }
  #operator(&) :: (something: OperatorOverloadTest) -> int {
    return value & something.value;
  }
  #operator(|) :: (something: OperatorOverloadTest) -> int {
    return value | something.value;
  }
  #operator(^) :: (something: OperatorOverloadTest) -> int {
    return value ^ something.value;
  }
  #operator(~) :: () -> int {
    return ~value;
  }
  #operator(<<) :: (something: OperatorOverloadTest) -> int {
    return value << something.value;
  }
  #operator(>>) :: (something: OperatorOverloadTest) -> int {
    return value >> something.value;
  }
  #operator(+=) :: (something: OperatorOverloadTest) -> int {
    value += something.value;
    return value;
  }
  #operator(-=) :: (something: OperatorOverloadTest) -> int {
    value -= something.value;
    return value;
  }
  #operator(*=) :: (something: OperatorOverloadTest) -> int {
    value *= something.value;
    return value;
  }
  #operator(/=) :: (something: OperatorOverloadTest) -> int {
    value /= something.value;
    return value;
  }
  #operator(%=) :: (something: OperatorOverloadTest) -> int {
    value %= something.value;
    return value;
  }
  #operator(&=) :: (something: OperatorOverloadTest) -> int {
    value &= something.value;
    return value;
  }
  #operator(|=) :: (something: OperatorOverloadTest) -> int {
    value |= something.value;
    return value;
  }
  #operator(^=) :: (something: OperatorOverloadTest) -> int {
    value ^= something.value;
    return value;
  }
  #operator(<<=) :: (something: OperatorOverloadTest) -> int {
    value <<= something.value;
    return value;
  }
  #operator(>>=) :: (something: OperatorOverloadTest) -> int {
    value >>= something.value;
    return value;
  }
  #operator(++) :: () -> int {
    return ++value;
  }
  #operator(--) :: () -> int {
    return --value;
  }
  #operator(==) :: (something: OperatorOverloadTest) -> bool {
    return value == something.value;
  }
  #operator(!=) :: (something: OperatorOverloadTest) -> bool {
    return value != something.value;
  }
  #operator(<) :: (something: OperatorOverloadTest) -> bool {
    return value < something.value;
  }
  #operator(<=) :: (something: OperatorOverloadTest) -> bool {
    return value <= something.value;
  }
  #operator(>) :: (something: OperatorOverloadTest) -> bool {
    return value > something.value;
  }
  #operator(>=) :: (something: OperatorOverloadTest) -> bool {
    return value >= something.value;
  }
  #operator([]) :: (n: int) -> int {
    base: int = 10;
    return n + base;
  }
  to_string :: () -> char *  {
    str: char* = malloc(sizeof(char *) * 1);
    sprintf(str, "%d", value);
    return str;
  }
}

#test test_operator_overload :: () {
  opstr1: OperatorOverloadTest;
  opstr2: OperatorOverloadTest;
  opstr1.value = 10;
  opstr2.value = 5;
  assert("Addition operator overload failed",                   opstr1 + opstr2 == 15);
  assert("Subtraction operator overload failed",                opstr1 - opstr2 == 5);
  assert("Multiplication operator overload failed",             opstr1 * opstr2 == 50);
  assert("Division operator overload failed",                   opstr1 / opstr2 == 2);
  assert("Modulus operator overload failed",                    opstr1 % opstr2 == 0);
  assert("Bitwise AND operator overload failed",                opstr1 & opstr2 == 0);
  assert("Bitwise OR operator overload failed",                 opstr1 | opstr2 == 15);
  assert("Bitwise XOR operator overload failed",                opstr1 ^ opstr2 == 15);
  assert("Bitwise NOT operator overload failed",                ~opstr1 == -11);
  assert("Left shift operator overload failed",                 opstr1 << opstr2 == 320);
  assert("Right shift operator overload failed",                opstr1 >> opstr2 == 0);
  ++opstr1;
  assert("Increment operator overload failed",                  opstr1.value == 11);
  --opstr1;
  assert("Decrement operator overload failed",                  opstr1.value == 10);
  assert("Equality operator overload failed",                   opstr1 == opstr2 == false);
  assert("Inequality operator overload failed",                 opstr1 != opstr2 == true);
  assert("Less than operator overload failed",                  opstr1 < opstr2 == false);
  assert("Less than or equal operator overload failed",         opstr1 <= opstr2 == false);
  assert("Greater than operator overload failed",               opstr1 > opstr2 == true);
  assert("Greater than or equal operator overload failed",      opstr1 >= opstr2 == true);
  assert("Subscript operator didn't return '30'",               opstr1[20] == 30);
}
#test test_comp_assign_overloads :: () {
  opstr1: OperatorOverloadTest;
  opstr2: OperatorOverloadTest;
  opstr1.value = 10;
  opstr2.value = 5;
  opstr1 += opstr2;
  assert("Addition assignment operator overload failed",        opstr1.value == 15);
  opstr1 -= opstr2;
  assert("Subtraction assignment operator overload failed",     opstr1.value == 10);
  opstr1 *= opstr2;
  assert("Multiplication assignment operator overload failed",  opstr1.value == 50);
  opstr1 /= opstr2;
  assert("Division assignment operator overload failed",        opstr1.value == 10);
  opstr1 %= opstr2;
  assert("Modulus assignment operator overload failed",         opstr1.value == 0);
  opstr1 &= opstr2;
  assert("Bitwise AND assignment operator overload failed",     opstr1.value == 0);
  opstr1 |= opstr2;
  assert("Bitwise OR assignment operator overload failed",      opstr1.value == 5);
  opstr1 ^= opstr2;
  assert("Bitwise XOR assignment operator overload failed",     opstr1.value == 0);
  opstr1 <<= opstr2;
  assert("Left shift assignment operator overload failed",      opstr1.value == 0);
  opstr1 >>= opstr2;
  assert("Right shift assignment operator overload failed",     opstr1.value == 0);
}

InitListStruct :: struct {
  a: int;
  b: int;
  c: int;
}
#test test_initializer_lists :: () {
    scalar: int = {0};
    arr: int[]  = {0, 1, 2};
    fixed: int[3] = {0, 1, 2};
    str: InitListStruct = {0, 0, 0};
    
    //!BUG This thing is broken because we provide too many elements to the init list, however our type checker fails to catch it and you get a C++ massive annoying errer.
    //! This line causes it: InitListStruct[] strArr = {{0, 0, 0, 4}, {0, 0, 0}, {0, 0, 0}};
    strArr: InitListStruct[]  = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}; // ! Comment this out to test.
    strArr1: InitListStruct[3] = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};

    expected_arr: int[] = {0, 1, 2};
    for i: s32; i < arr.length; i++ {
      assert("Array element mismatch", arr[i] == expected_arr[i]);
    }

    expected_fixed: int[3] = {0, 1, 2};
    for i: s32; i < 3; i++ {
      assert("Fixed array element mismatch", fixed[i] == expected_fixed[i]);
    }

    assert("Struct element mismatch", str.a == 0);
    assert("Struct element mismatch", str.b == 0);
    assert("Struct element mismatch", str.c == 0);

    expected_strArr: InitListStruct[]  = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};
    for i: s32; i < strArr.length; i++ {
      assert("Struct array element mismatch", strArr[i].a == expected_strArr[i].a);
      assert("Struct array element mismatch", strArr[i].b == expected_strArr[i].b);
      assert("Struct array element mismatch", strArr[i].c == expected_strArr[i].c);
    }

    // Assertions for strArr1
    expected_strArr1: InitListStruct[3]  = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};
    for i: s32 ; i < 3; i++ {
      assert("Fixed struct array element mismatch", strArr1[i].a == expected_strArr1[i].a);
      assert("Fixed struct array element mismatch", strArr1[i].b == expected_strArr1[i].b);
      assert("Fixed struct array element mismatch", strArr1[i].c == expected_strArr1[i].c);
    }
}

#test test_cast :: () {
  n: int = 10;
  f: float  = (float)n;
  assert("Cast failed", f == 10.0);
}

#test test_underscores_in_number_literals :: () {
  n: int = 1_000_000;
  assert("number literal with underscores failed to equal expected value", n == 1000000)
}

add :: (a: $T, b: $T) -> $T {
  return a + b;
}

generic_test_1 :: (arg1: $T**, value: $T) -> $T {
  return value;
}
generic_called_by_generic :: (v: $T) -> $T {
  return v;
}
generic_calling_generic :: (v: $T) -> $T {
  return generic_called_by_generic(v);
} 

#test test_generic_functions :: () {
  //assert("generic function failed to return a + b", add(1, 1) == 2);
  assert("add() failed to return a + b", add(1, 1) == 2);
  assert("add() failed to return a + b", add(-1, add(-1, -0)) == -2);
  assert("add() failed to return a + b", add(1.5, 1.5) == 3.0);
  
  //! Bug, this shouldnt work but it does because of both a failure of us type checking
  //! generic arguments, and also C++ failing to have good casting rules.
  // We should never be able to cast 10 to a boolean lol.
  {
    j: bool**;
    generic_test_1(j, 10);
  }
  
  //! See bug 1.1 :: 
  //! generic_calling_generic(10);
}


#test test_array_concat_operator :: () {
  array: int[];
  array ~= 10;
  assert("concat operator failed", array.length == 1);
}

#test test_array_pop_operator :: () {
  array: int[];
  for i: s32; i < 100; ++i {
    array ~= 10;
  }
  n: int;
  for i: s32; i < 100; ++i{
    n = ~array;
  }
  assert("pop operator failed", array.length == 0 && n == 10);
}

#test test_array_erase_operator :: () {
  array: int[] ;
  array ~= 10;
  array ~~ 10;
  assert("failed to erase element from array with ~~", array.length == 0);
}