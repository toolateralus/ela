#import core;

#compiler_flags "-g"

XaryuStruct :: struct {
  float f;
}

Union :: union {
  int a;
  int b;
  int c;
  method :: (int n) {
    assert("union equality check in method failed", n == a && n == b && n == c);
  }
  #ctor :: () {
    a = -1;
  }
  #dtor :: () {
    printf("union destructor\n");
  }
}
_Vec2 :: union {
  #anon :: struct {
    int x;
    int y;
    int z;
  };
  int[3] values;

  method :: (int n) {
    assert("union equality check in method failed", n == x && n == y && n == z);
    assert("union equality check in method failed", n == values[0] && n == values[1] && n == values[2]);
  }

  something :: () -> #self {
    return #make(#self);
  }
  #ctor :: (int _x, _y, _z) {
    x = _x;
    y = _y;
    z = _z;
  }

  #ctor :: () {
    memset(#make(void*, values), 0, sizeof(int) * 3);
    x=0;
    y=0;
    z=0;
    //printf();
  }

  #dtor :: () {
    printf("%d, %d, %d", x, y, z);
  }
}

CustomIteratorStruct :: struct {
  int *value = malloc(sizeof(int) * 10);
  begin :: () -> int * {
    return value;
  }
  end :: () -> int * {
    return value + 10;
  }
  #dtor :: () {
    free(value);
  }
}

Constructible :: struct {
  float32 x;
  #ctor :: (float32 _x) {
      x = _x;
  }
  #ctor :: (Constructible other) {
      x = other.x;
  }
  #ctor :: () {
    x = 10.0;
  }
}

Vector2 :: struct {
  float32 x;
  float32 y;
}

Vector3 :: struct {
  Vector2 vec2;
  float32 z;
}

Node :: struct {
  Node *next;
}

Array :: struct {
  Node[10] ptr;
}

IHaveAMethod :: struct {
  method :: () -> float32 {
      return 0.0;
  }
  parameter_method :: (float32 x) -> float32 {
      return x;
  }
}

#flags Banana :: enum  {
  Unripe,
  Ripe,
  Overripe,
  Rotten,
}

MyEnum :: enum {
  Some,
  Other,
  Value = 100 * 2,
}

// Keep this at the top otherwise it messesup the output formatting in the middle
#test test_printf :: () {
  char* s = "Hello i am a string";
  printf("testing printing a string: %s\n", s);
  return;
}

#test failure_case :: () {
  assert("This should fail", false);
}

#test test_for :: () {
  for s32 i; i < 10; ++i {
      assert("i should be less than 10", i < 10);
      return;
  }
  s32[] arr;
  for v; arr {
      assert("Unexpected case in array loop", false);
      return;
  }
  assert("End of test_for reached", true);
}

#test test_while :: () {
  bool b = true;
  while b {
      assert("while condition == true", b == true);
      return;
  }
  assert("End of test_while reached", true);
}

#test test_if_1 :: () {
  bool v = true;
  bool hit = false;
  if v {
      assert("v should be true", v == true);
      hit = true;
  } else {
      assert("Unexpected case", false);
  }
  assert("failed to fall through if statement", hit);
}

#test test_if_2 :: () {
  bool v = false;
  bool hit = true;
  if v {
      assert("Unexpected case", false);
  } else if !v {
      hit = true;
  }
  assert("fell through if else, but didn't set the variable", hit);
}

#test test_if_3 :: () {
  bool v = false;
  bool hit = true;
  if v {
      assert("Unexpected case", false);
  } else if v {
      assert("Unexpected case", false);
  } else {
      hit = true;
  }
  assert("fell though if,if_else,else but didn't set the variable", hit);
}

#test test_comp_assign :: () {
  s32 deref = 1;
  deref += deref;
  assert("+=", deref == 2);
  deref -= deref;
  assert("-=", deref == 0);
  deref *= deref;
  assert("*=)", deref == 0);
  deref = 2;
  deref /= deref;
  assert("/=", deref == 1);
  deref = 2;
  deref %= deref;
  assert("%=", deref == 0);
  deref &= deref;
  assert("&=", deref == 0);
  deref |= deref;
  assert("|=", deref == 0);
  deref ^= deref;
  assert("^=", deref == 0);
  deref <<= deref;
  assert("<<=", deref == 0);
  deref >>= deref;
  assert(">>=", deref == 0);
}

#test test_operators :: () {
  s32 left = 1;
  s32 right = 1;
  s32 result;
  bool result_bool;
  result_bool = left == right;
  assert("left should equal right", result_bool == true);
  result_bool = left != right;
  assert("left should not equal right", result_bool == false);
  result_bool = left < right;
  assert("left should not be less than right", result_bool == false);
  result_bool = left > right;
  assert("left should not be greater than right", result_bool == false);
  result_bool = left <= right;
  assert("left should be less than or equal to right", result_bool == true);
  result_bool = left >= right;
  assert("left should be greater than or equal to right", result_bool == true);
  result_bool = left && right;
  assert("left and right should be true", result_bool == true);
  result_bool = left || right;
  assert("left or right should be true", result_bool == true);

  result = left + right;
  assert("left + right should be 2", result == 2);
  result = left - right;
  assert("left - right should be 0", result == 0);
  result = left * right;
  assert("left * right should be 1", result == 1);
  result = left / right;
  assert("left / right should be 1", result == 1);
  result = left % right;
  assert("left % right should be 0", result == 0);
  result = left & right;
  assert("left & right should be 1", result == 1);
  result = left | right;
  assert("left | right should be 1", result == 1);
  result = left ^ right;
  assert("left ^ right should be 0", result == 0);
  result = left << right;
  assert("left << right should be 2", result == 2);
  result = left >> right;
  assert("left >> right should be 0", result == 0);
}

#test test_relational_results :: () {
  bool test1 = (1 == 1 + 2) || 1 == 2;
  bool test2 = (3 > 2) && (2 < 4);
  bool test3 = !(5 <= 5) || (6 >= 6);
  bool test4 = (7 != 8) && (9 == 9);
  assert("test1 should be false", test1 == false);
  assert("test2 should be true", test2 == true);
  assert("test3 should be true", test3 == true);
  assert("test4 should be true", test4 == true);
}

#test test_address_of :: () {
  s32 v = 0;
  s32* addr_of_v = &v;
  assert("address of grabbed a non-null ptr", addr_of_v != null);
  v = *addr_of_v;
  assert("deref'ing a ptr grabbed with &v failed to == the same value as when it was defined.", v == 0);
}

#test test_malloc :: () {
  s32* ptr = malloc(4);
  assert("malloc'd pointer was null", ptr != null);
  free(ptr);
  ptr = null;
  assert("freed ptr and set to null was not == null", ptr == null);
}

many_params :: (float32 a, b, c, d = 1.0) -> float32 {
  return a * b * c * d;
}

mul_params :: (float32 n, f) -> float32 {
  return n * f;
}

#test test_param :: () {
  assert("params of 1.5 * 2.0 expected to equal 3.0", mul_params(1.5, 2.0) == 3.0);
  assert("multiplying many params failed, or default param", many_params(1.0, 2.0, 4.0) == 8.0);
}

returns :: () -> s32  {
  return 1;
}

#test test_implicit_numerical_casting :: () {
  u8 u1;
  u16 u2 = u1;
  u32 u3 = u2;
  u64 u4 = u3;
  assert("unable to upcast successfully", u4 == u1);

  s8 s1;
  s16 s2 = s1;
  s32 s3 = s2;
  s64 s4 = s3;
  assert("unable to upcast successfully", s1 == s4);

  float f;
  float64 f1 = f;
  assert("unable to upcast successfully", f == f1);
}

#test test_return_value :: () {
  assert("function expected to return 1", returns() == 1);
}

#test test_struct_single_level :: () {
  Vector2 v;
  assert("v.x != 0.0", v.x == 0.0);
  assert("v.y != 0.0", v.y == 0.0);
}

#test test_struct_nested_once :: () {
  Vector3 v;
  assert("v.vec2.x != 0.0", v.vec2.x == 0.0);
  assert("v.vec2.y != 0.0", v.vec2.y == 0.0);
  assert("v.z != 0.0", v.z == 0.0);
}

#test test_struct_assign_member :: () {
  Vector2 v;
  v.x = 10.0;
  v.y = 10.0;
  assert("assigning v.x = 10.0 failed", v.x == 10.0);
  assert("assigning v.y = 10.0 failed", v.y == 10.0);
}

#test test_struct_assign_nested_member :: () {
  Vector3 v;
  v.vec2.x = 1.0;
  v.vec2.y = 2.0;
  v.z = 3.0;
  assert("assigning v.vec2.x = 1.0 failed", v.vec2.x == 1.0);
  assert("assigning v.vec2.y = 1.0 failed", v.vec2.y == 2.0);
  assert("assigning v.z = 3.0 failed", v.z == 3.0);
}

struct_as_param :: (Vector2 v)  -> float32 {
  return v.x;
}

#test test_struct_as_param :: () {
  Vector2 v;
  assert("", struct_as_param(v) == 0.0);
}

something :: (float32 f) -> float32 {
  return f;
}

#test test_struct_member_as_param :: () {
  Vector2 v;
  assert("passing dot expr struct member as param failed", something(v.x) == 0.0);
}

#test test_local_function :: () {
  local_function :: () -> s32 {
      return 0;
  }
  assert("failed to get 0 from local function call", local_function() == 0);
}

#test test_chained_dot_subscript :: () {
  Array a;
  a.ptr[0].next = null;
  assert("failure: a.ptr[0].next != null", a.ptr[0].next == null);

  Node n;
  a.ptr[0].next = &n;
  assert("failure: a.ptr[0].next != null", a.ptr[0].next != null);
}

#test test_subscript :: () {
  s32[100] arr;
  arr[50] = 0;
  assert("subscript 50 on s32[100] failed to == 0", arr[50] == 0);
  int n;
  ++n;
}

#test test_referencing_pointer :: () {
  Node node;
  node.next = malloc(sizeof(Node));
  Node other;
  node.next.next = &other;

  assert("mallocing 'next' of 'Node' failed.", node.next != null);
  assert("dereferencing other into node.next failed.", node.next.next != null);
}

// testing conflicting definitons. expected: compiler error if failed.
#test for_loop_2 :: () {
  for int i; i < 10; ++i {
      i = i;
  }
  for int i; i < 10; ++i {
      i = i;
  }

  int[] array;

  for k; array {
    k = k;
  }
  for k; array {
    k = k;
  }
}

#test make_parameterless :: () {
  n := #make(Constructible);
  assert("default construction failed.", n.x == 10.0);
}

#test test_copy_make :: () {
  Constructible c;
  Constructible c1 = #make(Constructible, c);
  assert("failed to copy construct Constructible (struct)", c1.x == c.x);
}

#test test_make :: () {
  Constructible c = #make(Constructible, 10.0);
  assert("failed to construct", c.x == 10.0);
}

#test test_make_cast :: () {
  u16 big = #make(u16, 65365);
  u8 small = #make(u8, big);
  assert("failed to down cast", small == (big % 256));
}

#test test_method :: () {
  IHaveAMethod owner;
  assert("failed to get 0.0 from method.", owner.method() == 0.0);
  assert("failed to get 0.0 from method (passing back param).", owner.parameter_method(0.0) == 0.0);
}

#test test_enum_flags :: () {
  flags := Banana.Unripe | Banana.Overripe;
  assert("flags & Banana.Unripe failed.", (flags & Banana.Unripe) != 0);
}

// TODO(Josh) 10/1/2024, 10:08:18 AM :: we need to allow declarations of variables with their enum type.
// Right now we just cast enums to int always.
// We should be able to do MyEnum value = MyEnum.Some;
// This will also allow us to do other stuff, like type safe enums.

#test test_regular_enum :: () {
  value := MyEnum.Some;
  value1 := MyEnum.Value;
  assert("MyEnum.Value failed to == 100 * 2", value1 == 100 * 2);
  assert("Zero case of enum did not equal 0", value == 0);
}

// #test test_type_alias :: () {
//   #alias Xaryu :: int;
//   Xaryu i = 0;
//   assert("type alias failed", i == 0);
// }

// woo hoo complex expressions parse and type very well!.
#test test_comp_assign_non_iden :: () {
  float32[12] arr;
  arr[0] = 10;
  arr[0] += 10;
  assert("comp assign arr[0] += 10 failed to == 20.", arr[0] == 20);

  XaryuStruct[1] xarbars;
  xarbars[0].f = 10.0;
  xarbars[0].f += 10.0;
  assert("comp assign xarbars[0].f += 10.0; failed to == 20.0", xarbars[0].f == 20.0);
}

// TODO(Josh) 10/1/2024, 1:20:30 PM
// implement tagged unions once we have paramterized structs.
// until we have that, this will be nearly pointless.
// #tagged Union :: union {
//   None,
//   Some :: struct {
//     $T data;
//   }
// }


#test test_union_type :: () {
  Union test_union;
  test_union.a = 10;
  assert("union variants failed to equal each other", test_union.a == test_union.b && test_union.b == test_union.c);
  test_union.method(10);
}

#test test_two_way_implicit_conversion_bin_ops :: () {
  s32 v;
  s8 v1;
  float32 f;
  assert("failed to convert both ways", v + v1 == 0 && v1 + v == 0);
}

#test test_union_type_anonymous_sub_struct :: () {
  _Vec2 vec;
  vec.method(0); // this does the assertions
}

#test test_new :: () {
  _Vec2 *vec = new _Vec2(10, 10, 10);
  _Vec2 *vec1 = new _Vec2(10, 10, 10);
  assert("new allocated structs using ctor failed to equal each other", vec.x == vec1.x && vec.y == vec1.y && vec.z == vec1.z);
  delete (vec, vec1);
}

#test ptr_iter_range_base :: () {
  s8[] array = {0,1,2,3};
  int n;
  for *v; array {
    assert("", n == *v);
    ++n;
  }
}

#test test_custom_iterator :: () {
  CustomIteratorStruct iter;
  int n;
  for k; iter {
    assert("iterator value failed to equal 0", k == 0);
    n++;
  }
  assert("failed to iterate the appropriate number of times", n == 10);
}

#test test_string :: () {
  string my_string = "Xaryu Baryu";
  assert("string length failed to equal expected value", my_string.length == 11);
}

#test test_array :: () {
  // TODO: put a lot more work into init lists, right now they only really work
  // for dynamic ararys.
  int[] array = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  assert("array length failed to equal expected value", array.length == 11);
  // TODO: we need to fix this.
  // This throws C++ errors during compilation
  // because initializer lists have strangely strict typing
  // compared to normal narrowing rules.
  // bool[] arr = {0,1,2,3,4,5};
}

// #test test_function_pointers :: () {
//   #alias VoidFunction :: void()*;
//   VoidFunction* func = #make(VoidFunction*, malloc(sizeof(VoidFunction) * 10));
//   for s32 i; i < 10; ++i {
//     func[i] = &test_function_pointers;
//   }
//   for s32 i; i < 10; ++i {
//     assert("func failed to == itself", func[i] == &test_function_pointers)
//   }
// }

#test test_aliasing :: () {
  #alias int_ptr :: int*;
  int* p = malloc(sizeof(int));
  int_ptr other = p;
  assert("alias failed to equal pointed to type field.", p == other);

  int **pp = #make(int**, malloc(sizeof(int*)));
  int_ptr* other1 = pp;
  assert("alias failed to equal pointed to type field.", pp == other1);
}

Xaryu :: struct {
  int value;
  to_string :: () -> char * {
    return "XarBar";
  }
}

#test test_string_interpolation :: () {
  Xaryu xarbar;
  string interp = $"{xarbar.to_string()}";
  assert("unexpected interpolated string value", strcmp(interp.data, "XarBar") == 0);
  interp = $"{(1 + 1) * 2}";
  println($"Interpolated value {interp}");
  assert("unexpected interpolated string value", strcmp(interp.data, "4") == 0);
}



overloaded :: (int n) -> int {
  return n;
}

overloaded :: (float f) -> float {
  return f;
}

overloaded :: (Xaryu xaryu) -> Xaryu {
  return xaryu;
}

#test test_function_overloads :: () {
  assert("overload with integer arg failed to call", strcmp((#type overloaded(10)).name, "int") == 0);
  assert("overload with float arg failed to call", strcmp((#type overloaded(12.5)).name, "float") == 0);
  Xaryu xaryu;
  xaryu.value = 100;
  assert("overload with float arg failed to call", strcmp((#type overloaded(xaryu)).name, "Xaryu") == 0);
}

OperatorOverloadTest :: struct {
  int value = 0;

  #operator(+) :: (OperatorOverloadTest something) -> int {
    return value + something.value;
  }
  #operator(-) :: (OperatorOverloadTest something) -> int {
    return value - something.value;
  }
  #operator(*) :: (OperatorOverloadTest something) -> int {
    return value * something.value;
  }
  #operator(/) :: (OperatorOverloadTest something) -> int {
    return value / something.value;
  }
  #operator(%) :: (OperatorOverloadTest something) -> int {
    return value % something.value;
  }
  #operator(&) :: (OperatorOverloadTest something) -> int {
    return value & something.value;
  }
  #operator(|) :: (OperatorOverloadTest something) -> int {
    return value | something.value;
  }
  #operator(^) :: (OperatorOverloadTest something) -> int {
    return value ^ something.value;
  }
  #operator(~) :: () -> int {
    return ~value;
  }
  #operator(<<) :: (OperatorOverloadTest something) -> int {
    return value << something.value;
  }
  #operator(>>) :: (OperatorOverloadTest something) -> int {
    return value >> something.value;
  }
  #operator(+=) :: (OperatorOverloadTest something) -> int {
    value += something.value;
    return value;
  }
  #operator(-=) :: (OperatorOverloadTest something) -> int {
    value -= something.value;
    return value;
  }
  #operator(*=) :: (OperatorOverloadTest something) -> int {
    value *= something.value;
    return value;
  }
  #operator(/=) :: (OperatorOverloadTest something) -> int {
    value /= something.value;
    return value;
  }
  #operator(%=) :: (OperatorOverloadTest something) -> int {
    value %= something.value;
    return value;
  }
  #operator(&=) :: (OperatorOverloadTest something) -> int {
    value &= something.value;
    return value;
  }
  #operator(|=) :: (OperatorOverloadTest something) -> int {
    value |= something.value;
    return value;
  }
  #operator(^=) :: (OperatorOverloadTest something) -> int {
    value ^= something.value;
    return value;
  }
  #operator(<<=) :: (OperatorOverloadTest something) -> int {
    value <<= something.value;
    return value;
  }
  #operator(>>=) :: (OperatorOverloadTest something) -> int {
    value >>= something.value;
    return value;
  }
  #operator(++) :: () -> int {
    return ++value;
  }
  #operator(--) :: () -> int {
    return --value;
  }
  #operator(==) :: (OperatorOverloadTest something) -> bool {
    return value == something.value;
  }
  #operator(!=) :: (OperatorOverloadTest something) -> bool {
    return value != something.value;
  }
  #operator(<) :: (OperatorOverloadTest something) -> bool {
    return value < something.value;
  }
  #operator(<=) :: (OperatorOverloadTest something) -> bool {
    return value <= something.value;
  }
  #operator(>) :: (OperatorOverloadTest something) -> bool {
    return value > something.value;
  }
  #operator(>=) :: (OperatorOverloadTest something) -> bool {
    return value >= something.value;
  }
  #operator(()) :: () -> char * {
    return "Hi";
  }
  #operator([]) :: (int n) -> int {
    int base = 10;
    return n + base;
  }
  to_string :: () -> char *  {
    char * str = malloc(sizeof(char *) * 1);
    sprintf(str, "%d", value);
    return str;
  }
}

// TODO: fix operator precedence. If you un-parenthesis a lot of these expresssions,
// it's revealed how our type system is totally failing on binary expressions.
#test test_operator_overload :: () {
  OperatorOverloadTest opstr1;
  OperatorOverloadTest opstr2;
  opstr1.value = 10;
  opstr2.value = 5;
  assert("Addition operator overload failed",                   (opstr1 + opstr2) == 15);
  assert("Subtraction operator overload failed",                (opstr1 - opstr2) == 5);
  assert("Multiplication operator overload failed",             (opstr1 * opstr2) == 50);
  assert("Division operator overload failed",                   (opstr1 / opstr2) == 2);
  assert("Modulus operator overload failed",                    (opstr1 % opstr2) == 0);
  assert("Bitwise AND operator overload failed",                (opstr1 & opstr2) == 0);
  assert("Bitwise OR operator overload failed",                 (opstr1 | opstr2) == 15);
  assert("Bitwise XOR operator overload failed",                (opstr1 ^ opstr2) == 15);
  assert("Bitwise NOT operator overload failed",                (~opstr1) == -11);
  assert("Left shift operator overload failed",                 (opstr1 << opstr2) == 320);
  assert("Right shift operator overload failed",                (opstr1 >> opstr2) == 0);
  ++opstr1;
  assert("Increment operator overload failed",                  (opstr1.value) == 11);
  --opstr1;
  assert("Decrement operator overload failed",                  (opstr1.value) == 10);
  assert("Equality operator overload failed",                   (opstr1 == opstr2) == false);
  assert("Inequality operator overload failed",                 (opstr1 != opstr2) == true);
  assert("Less than operator overload failed",                  (opstr1 < opstr2) == false);
  assert("Less than or equal operator overload failed",         (opstr1 <= opstr2) == false);
  assert("Greater than operator overload failed",               (opstr1 > opstr2) == true);
  assert("Greater than or equal operator overload failed",      (opstr1 >= opstr2) == true);
  assert("Call operator didn't return 'Hi'",                    strcmp(opstr1(), "Hi") == 0);
  assert("Subscript operator didn't return '30'",               (opstr1[20]) == 30);
}
#test test_comp_assign_overloads :: () {
  OperatorOverloadTest opstr1;
  OperatorOverloadTest opstr2;
  opstr1.value = 10;
  opstr2.value = 5;
  opstr1 += opstr2;
  assert("Addition assignment operator overload failed",        opstr1.value == 15);
  opstr1 -= opstr2;
  assert("Subtraction assignment operator overload failed",     opstr1.value == 10);
  opstr1 *= opstr2;
  assert("Multiplication assignment operator overload failed",  opstr1.value == 50);
  opstr1 /= opstr2;
  assert("Division assignment operator overload failed",        opstr1.value == 10);
  opstr1 %= opstr2;
  assert("Modulus assignment operator overload failed",         opstr1.value == 0);
  opstr1 &= opstr2;
  assert("Bitwise AND assignment operator overload failed",     opstr1.value == 0);
  opstr1 |= opstr2;
  assert("Bitwise OR assignment operator overload failed",      opstr1.value == 5);
  opstr1 ^= opstr2;
  assert("Bitwise XOR assignment operator overload failed",     opstr1.value == 0);
  opstr1 <<= opstr2;
  assert("Left shift assignment operator overload failed",      opstr1.value == 0);
  opstr1 >>= opstr2;
  assert("Right shift assignment operator overload failed",     opstr1.value == 0);
}

InitListStruct :: struct {
  int a; int b; int c;
}
#test test_initializer_lists :: () {
    int scalar = {0};
    int[] arr = {0, 1, 2};
    int[3] fixed = {0, 1, 2};
    InitListStruct str = {0, 0, 0};
    
    //!BUG This thing is broken because we provide too many elements to the init list, however our type checker fails to catch it and you get a C++ massive annoying errer.
    // InitListStruct[] strArr = {{0, 0, 0, 4}, {0, 0, 0}, {0, 0, 0}};
    InitListStruct[] strArr = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};
    InitListStruct[3] strArr1 = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};

    int[] expected_arr = {0, 1, 2};
    for s32 i; i < arr.length; i++ {
      assert("Array element mismatch", arr[i] == expected_arr[i]);
    }

    int[3] expected_fixed = {0, 1, 2};
    for s32 i; i < 3; i++ {
      assert("Fixed array element mismatch", fixed[i] == expected_fixed[i]);
    }

    assert("Struct element mismatch", str.a == 0);
    assert("Struct element mismatch", str.b == 0);
    assert("Struct element mismatch", str.c == 0);

    InitListStruct[] expected_strArr = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};
    for s32 i; i < strArr.length; i++ {
      assert("Struct array element mismatch", strArr[i].a == expected_strArr[i].a);
      assert("Struct array element mismatch", strArr[i].b == expected_strArr[i].b);
      assert("Struct array element mismatch", strArr[i].c == expected_strArr[i].c);
    }

    // Assertions for strArr1
    InitListStruct[3] expected_strArr1 = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};
    for s32 i; i < 3; i++ {
      assert("Fixed struct array element mismatch", strArr1[i].a == expected_strArr1[i].a);
      assert("Fixed struct array element mismatch", strArr1[i].b == expected_strArr1[i].b);
      assert("Fixed struct array element mismatch", strArr1[i].c == expected_strArr1[i].c);
    }
}

#test test_cast :: () {
  int n = 10;
  float f = (float)n;
  assert("Cast failed", f == 10.0);
}
