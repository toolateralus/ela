#import core;
#import interned_string;

TType :: enum {
  Eof = -1,
  Identifier,

  // Literals
  Integer,
  String,

  // Operators.
  Add,
  Sub,
  Mul,
  Div,
}

ttype_name_cache: string[.Div];

get_ttype_names :: () {
  type := #type TType;
  for i in 0..TType.Div {
    ttype_name_cache[i] = type.fields[i].name;
  }
}

Token :: struct {
  value:        InternedString;
  line:         s64;
  column:       s64;
  type:         int;

  to_string :: () -> string {
    return $"value: {value.get_string_value()}, line: {line}, column: {column}, type: {ttype_name_cache[type]}";
  }
}

token_eof :: () -> Token {
  tok: Token;
  tok.type = .Eof;
  return tok;
}

make_token :: (slice: string, line: s64, column, type: int) -> Token {
  token: Token;
  token.value = #make(InternedString, slice);
  token.line = line;
  token.column = column;
  token.type = type;
  return token;
}

make_operator :: (slice: string, line: s64, column) -> Token {
  token: Token;
  token.value = #make(InternedString, slice);
  token.line = line;
  token.column = column;
  token.type = switch slice {
    string{"+"}: { return .Add; }
    string{"-"}: { return .Sub; }
    string{"/"}: { return .Div; }
    string{"*"}: { return .Mul; }
  }
  return token;
}


Lexer :: struct {

  #ctor :: (input: string) {
    this.input = input;
    length = input.length;
  }

  position:     int;
  line:         s64       = 1;
  column:       s64       = 1;
  input:        string;
  length:       s64;

  get_token :: () -> Token {
    if length >= position
      then return token_eof();

    while length < position {

      c : char = input[position];

      if c == #char "\n" {
        column = 1;
        position++;
        line++;
        continue;
      }

      if c == #char " " {
        position++;
        column++;
        continue;
      }

      start := position;

      get_slice :: () -> string {
        return #make(string, &input[start], &input[position]);
      }

      advance :: () {
        position++;
        c = input[position];
        line++;
        column++;
      }

      if isalpha(c) {
        while position < length && isalpha(c) || c == #char "_" {
          advance();
        }
        slice := get_slice();
        return make_token(slice, line, column, .Identifier);
      } else if isdigit(c) {
        while position < length && isdigit(c) || c == #char "_" {
          advance();
        }
        slice := get_slice();
        return make_token(slice, line, column, .Integer);
      } else if ispunct(c) {
        while position < length && ispunct(c) {
          advance();
        }
        slice := get_slice();
        return make_operator(slice, line, column);
      } else {
        printf("Failed to lex character: %c\n", c);
      }
    }

    return token_eof();
  }
}


main :: () {
  get_ttype_names();
  lexer := #make(Lexer, "I am gay as hell");

  while true {
    tok := lexer.get_token();
    if tok.type == .Eof then break;
    println($"{tok}");
  }

}

