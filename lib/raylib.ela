#import core;

#c_flags "-lraylib -lm"

Key :: enum {
  Null            = 0,
  Apostrophe      = 39,
  Comma           = 44,
  Minus           = 45,
  Period          = 46,
  Slash           = 47,
  Zero            = 48,
  One             = 49,
  Two             = 50,
  Three           = 51,
  Four            = 52,
  Five            = 53,
  Six             = 54,
  Seven           = 55,
  Eight           = 56,
  Nine            = 57,
  Semicolon       = 59,
  Equal           = 61,
  A               = 65,
  B               = 66,
  C               = 67,
  D               = 68,
  E               = 69,
  F               = 70,
  G               = 71,
  H               = 72,
  I               = 73,
  J               = 74,
  K               = 75,
  L               = 76,
  M               = 77,
  N               = 78,
  O               = 79,
  P               = 80,
  Q               = 81,
  R               = 82,
  S               = 83,
  T               = 84,
  U               = 85,
  V               = 86,
  W               = 87,
  X               = 88,
  Y               = 89,
  Z               = 90,
  LeftBracket    = 91,
  Backslash       = 92,
  RightBracket   = 93,
  Grave           = 96,
  Space           = 32,
  Escape          = 256,
  Enter           = 257,
  Tab             = 258,
  Backspace       = 259,
  Insert          = 260,
  Delete          = 261,
  Right           = 262,
  Left            = 263,
  Down            = 264,
  Up              = 265,
  PageUp         = 266,
  PageDown       = 267,
  Home            = 268,
  End             = 269,
  CapsLock       = 280,
  ScrollLock     = 281,
  NumLock        = 282,
  PrintScreen    = 283,
  Pause           = 284,
  F1              = 290,
  F2              = 291,
  F3              = 292,
  F4              = 293,
  F5              = 294,
  F6              = 295,
  F7              = 296,
  F8              = 297,
  F9              = 298,
  F10             = 299,
  F11             = 300,
  F12             = 301,
  LeftShift      = 340,
  LeftControl    = 341,
  LeftAlt        = 342,
  LeftSuper      = 343,
  RightShift     = 344,
  RightControl   = 345,
  RightAlt       = 346,
  RightSuper     = 347,
  Kb_menu         = 348,
  Keypad0            = 320,
  Keypad1            = 321,
  Keypad2            = 322,
  Keypad3            = 323,
  Keypad4            = 324,
  Keypad5            = 325,
  Keypad6            = 326,
  Keypad7            = 327,
  Keypad8            = 328,
  Keypad9            = 329,
  KpDecimal      = 330,
  KpDivide       = 331,
  KpMultiply     = 332,
  KpSubtract     = 333,
  KpAdd          = 334,
  KpEnter        = 335,
  KpEqual        = 336,
  Back            = 4,
  Menu            = 5,
  VolumeUp       = 24,
  VolumeDown     = 25
}

MouseButton :: enum {
  Left = 0,
  Right = 1,
  Middle = 2,
  Side = 3,
  Extra = 4,
  Forward = 5,
  Back = 6
}

Color :: struct {
  r: u8;
  g: u8;
  b: u8;
  a: u8;
}

impl Color {
  to_string :: fn(self*) -> string {
    return $"r: {self.r}, g: {self.g}, b: {self.b}, a: {self.a}";
  }

  with_alpha :: fn(self, a: int) -> #self {
    self.a = a as u8;
    return self;
  }

  // Scales rgb values, but never wraps around.
  scaled_rgb :: fn(self, scalar: float32) -> #self {
    return {
      r: clamp((self.r * scalar) as int, 0, 255) as u8,
      g: clamp((self.g * scalar) as int, 0, 255) as u8,
      b: clamp((self.b * scalar) as int, 0, 255) as u8,
      a: self.a,
    }
  }
}

Texture2D :: struct {
  id: int;
  width: int;
  height: int;
  mipmaps: int;
  format: int;
}

Vector2 :: struct {
  x: float;
  y: float;
}

impl Vector2 {
  scalar :: fn(f: float) -> #self {
    return {
      x: f, y: f
    };
  }
  to_string :: fn(self*) -> string {
    return $"x: {self.x}, y: {self.y}";
  }

  add :: fn(self* other: Vector2) -> Vector2 {
    return { x: self.x + other.x, y: self.y + other.y };
  }

  subtract :: fn(self* other: Vector2) -> Vector2 {
    return { x: self.x - other.x, y: self.y - other.y };
  }

  multiply :: fn(self* scalar: float) -> Vector2 {
    return { x: self.x * scalar, y: self.y * scalar };
  }

  divide :: fn(self* scalar: float) -> Vector2 {
    return { x: self.x / scalar, y: self.y / scalar };
  }

  dot :: fn(self* other: Vector2) -> float64 {
    return self.x * other.x + self.y * other.y;
  }

  length :: fn(self*) -> float64 {
    return sqrt(self.x * self.x + self.y * self.y);
  }

  normalize :: fn(self*) -> Vector2 {
    len := self.length();
    return { x: (self.x / len) as float32, y: (self.y / len) as float32 };
  }

}

Vector3 :: struct {
  x: float;
  y: float;
  z: float;
}

impl Vector3 {
  to_string :: fn(self*) -> string {
    return $"x: {self.x}, y: {self.y}, z: {self.z}"
  }
  add :: fn(self* other: Vector3) -> Vector3 {
    return { x: self.x + other.x, y: self.y + other.y, z: self.z + other.z };
  }

  subtract :: fn(self* other: Vector3) -> Vector3 {
    return { x: self.x - other.x, y: self.y - other.y, z: self.z - other.z };
  }

  multiply :: fn(self* scalar: float) -> Vector3 {
    return { x: self.x * scalar, y: self.y * scalar, z: self.z * scalar };
  }

  divide :: fn(self* scalar: float) -> Vector3 {
    return { x: self.x / scalar, y: self.y / scalar, z: self.z / scalar };
  }

  dot :: fn(self* other: Vector3) -> float {
    return self.x * other.x + self.y * other.y + self.z * other.z;
  }

  cross :: fn(self* other: Vector3) -> Vector3 {
    return {
      x: self.y * other.z - self.z * other.y,
      y: self.z * other.x - self.x * other.z,
      z: self.x * other.y - self.y * other.x
    };
  }

  length :: fn(self*) -> float64 {
    return sqrt(self.x * self.x + self.y * self.y + self.z * self.z);
  }

  normalize :: fn(self*) -> Vector3 {
    len := self.length();
    return { x: (self.x / len) as float32, y: (self.y / len) as float32, z: (self.z / len) as float32 };
  }

}

Rectangle :: struct {
  x: float;
  y: float;
  width: float;
  height: float;
}

impl Rectangle {
  to_string :: fn(self*) -> string {
    return $"x: {self.x}, y: {self.y}, width: {self.width}, height: {self.height}";
  }
}

GlyphInfo :: struct {
  value:      int;
  offsetX:    int;
  offsetY:    int;
  advanceX:   int;
  image:      Texture2D;
}

Font :: struct {
  baseSize:     int;
  glyphCount:   int;
  glyphPadding: int;
  texture:      Texture2D;
  recs:         Rectangle*;
  glyphs:       GlyphInfo*;
}


// Opaque structs defined in C files in raudio.c;
rAudioBuffer :: struct;
rAudioProcessor :: struct;

AudioStream :: struct {
  buffer: rAudioBuffer*;
  processor: rAudioProcessor*;
  sampleRate: u32;
  sampleSize: u32;
  channels: u32;
}

Music :: struct {
  stream: AudioStream;
  frameCount: u32;
  looping: bool;
  ctxType: int;
  ctxData: void*;
}

Sound :: struct {
  stream: AudioStream;
  frameCount: u32;
}

Camera :: struct {
  position:     Vector3;
  target:       Vector3;
  up:           Vector3;
  fovy:         float;
  projection:   int;
}

Camera2D :: struct {
  offset:         Vector2;
  target:         Vector2;
  rotation:       float;
  zoom:           float = 1.0;
}

CameraMode :: enum {
  Custom        = 0,
  Free          = 1,
  Orbital       = 2,
  FirstPerson   = 3,
  ThirdPerson   = 4
}

ConfigFlags :: enum {
  FullscreenMode        = 0x00000002, // 1 << 1
  WindowResizable       = 0x00000004, // 1 << 2
  WindowUndecorated     = 0x00000008, // 1 << 3
  WindowTransparent     = 0x00000010, // 1 << 4
  Msaa4xHint            = 0x00000020, // 1 << 5
  VsyncHint             = 0x00000040, // 1 << 6
  WindowHidden          = 0x00000080, // 1 << 7
  WindowAlwaysRun       = 0x00000100, // 1 << 8
  WindowMinimized       = 0x00000200, // 1 << 9
  WindowMaximized       = 0x00000400, // 1 << 10
  WindowUnfocused       = 0x00000800, // 1 << 11
  WindowTopmost         = 0x00001000, // 1 << 12
  WindowHighdpi         = 0x00002000, // 1 << 13
  WindowMousePassthrough = 0x00004000, // 1 << 14
  BorderlessWindowedMode = 0x00008000, // 1 << 15
  InterlacedHint        = 0x00010000  // 1 << 16
}

color_lerp :: fn(a: Color, b: Color, t: float) -> Color {
  return {
    r: clamp(a.r + (b.r - a.r) * t, 0, 255) as u8,
    g: clamp(a.g + (b.g - a.g) * t, 0, 255) as u8,
    b: clamp(a.b + (b.b - a.b) * t, 0, 255) as u8,
    a: clamp(a.a + (b.a - a.a) * t, 0, 255) as u8
  };
}

CLEAR: Color;
WHITE: Color = { r: 255 as u8, g: 255 as u8, b: 255 as u8, a: 255 as u8 };
BLACK: Color = { r: 0 as u8, g: 0 as u8, b: 0 as u8, a: 255 as u8 };
RED: Color = { r: 255 as u8, g: 0 as u8, b: 0 as u8, a: 255 as u8 };
GREEN: Color = { r: 0 as u8, g: 255 as u8, b: 0 as u8, a: 255 as u8 };
BLUE: Color = { r: 0 as u8, g: 0 as u8, b: 255 as u8, a: 255 as u8 };
YELLOW: Color = { r: 255 as u8, g: 255 as u8, b: 0 as u8, a: 255 as u8 };
PURPLE: Color = { r: 255 as u8, g: 0 as u8, b: 255 as u8, a: 255 as u8 };
ORANGE: Color = { r: 255 as u8, g: 165 as u8, b: 0 as u8, a: 255 as u8 };
GRAY: Color = { r: 128 as u8, g: 128 as u8, b: 128 as u8, a: 255 as u8 };
DARKGRAY: Color = { r: 80 as u8, g: 80 as u8, b: 80 as u8, a: 255 as u8 };
LIGHTGRAY: Color = { r: 200 as u8, g: 200 as u8, b: 200 as u8, a: 255 as u8 };
BROWN: Color = { r: 165 as u8, g: 42 as u8, b: 42 as u8, a: 255 as u8 };
PINK: Color = { r: 255 as u8, g: 192 as u8, b: 203 as u8, a: 255 as u8 };
LIME: Color = { r: 0 as u8, g: 255 as u8, b: 0 as u8, a: 255 as u8 };
DARKGREEN: Color = { r: 0 as u8, g: 100 as u8, b: 0 as u8, a: 255 as u8 };
SKYBLUE: Color = { r: 135 as u8, g: 206 as u8, b: 235 as u8, a: 255 as u8 };
VIOLET: Color = { r: 238 as u8, g: 130 as u8, b: 238 as u8, a: 255 as u8 };
GOLD: Color = { r: 255 as u8, g: 215 as u8, b: 0 as u8, a: 255 as u8 };
BEIGE: Color = { r: 245 as u8, g: 245 as u8, b: 220 as u8, a: 255 as u8 };
MAGENTA: Color = { r: 255 as u8, g: 0 as u8, b: 255 as u8, a: 255 as u8 };
MAROON: Color = { r: 128 as u8, g: 0 as u8, b: 0 as u8, a: 255 as u8 };
DARKBLUE: Color = { r: 0 as u8, g: 0 as u8, b: 139 as u8, a: 255 as u8 };
DARKPURPLE: Color = { r: 139 as u8, g: 0 as u8, b: 139 as u8, a: 255 as u8 };
DARKBROWN: Color = { r: 101 as u8, g: 67 as u8, b: 33 as u8, a: 255 as u8 };
CYAN: Color = { r: 0 as u8, g: 255 as u8, b: 255 as u8, a: 255 as u8 };
DARKCYAN: Color = { r: 0 as u8, g: 139 as u8, b: 139 as u8, a: 255 as u8 };
LIGHTCYAN: Color = { r: 224 as u8, g: 255 as u8, b: 255 as u8, a: 255 as u8 };

// Exclude black and white.
All_Colors : Color[] = {
  WHITE,
  RED,
  GREEN,
  BLUE,
  YELLOW,
  PURPLE,
  ORANGE,
  GRAY,
  DARKGRAY,
  LIGHTGRAY,
  BROWN,
  PINK,
  LIME,
  DARKGREEN,
  SKYBLUE,
  VIOLET,
  GOLD,
  BEIGE,
  MAGENTA,
  MAROON,
  DARKBLUE,
  DARKPURPLE,
  DARKBROWN,
  CYAN,
  DARKCYAN,
  LIGHTCYAN,
}

#foreign InitTimer :: fn() -> void;
#foreign GetTime :: fn() -> float64;

#foreign Vector2Zero :: fn() -> Vector2;
#foreign Vector2One :: fn() -> Vector2;
#foreign Vector2Add :: fn(v: Vector2, v1: Vector2) -> Vector2;
#foreign Vector2AddValue :: fn(v: Vector2, add: float) -> Vector2;
#foreign Vector2Subtract :: fn(v: Vector2, v1: Vector2) -> Vector2;
#foreign Vector2SubtractValue :: fn(v: Vector2, sub: float) -> Vector2;
#foreign Vector2Length :: fn(v: Vector2) -> float;
#foreign Vector2LengthSqr :: fn(v: Vector2) -> float;
#foreign Vector2DotProduct :: fn(v: Vector2, v1: Vector2) -> float;
#foreign Vector2Distance :: fn(v: Vector2, v1: Vector2) -> float;
#foreign Vector2DistanceSqr :: fn(v: Vector2, v1: Vector2) -> float;
#foreign Vector2Angle :: fn(v: Vector2, v1: Vector2) -> float;
#foreign Vector2LineAngle :: fn(start: Vector2, end) -> float;
#foreign Vector2Scale :: fn(v: Vector2, scale: float) -> Vector2;
#foreign Vector2Multiply :: fn(v: Vector2, v1) -> Vector2;
#foreign Vector2Negate :: fn(v: Vector2) -> Vector2;
#foreign Vector2Divide :: fn(v: Vector2, v1) -> Vector2;
#foreign Vector2Normalize :: fn(v: Vector2) -> Vector2;

#foreign Vector2Lerp :: fn(v: Vector2, v1, amount: float) -> Vector2;
#foreign Vector2Reflect :: fn(v: Vector2, normal) -> Vector2;
#foreign Vector2Min :: fn(v: Vector2, v1) -> Vector2;
#foreign Vector2Max :: fn(v: Vector2, v1) -> Vector2;
#foreign Vector2Rotate :: fn(v: Vector2, angle: float) -> Vector2;
#foreign Vector2MoveTowards :: fn(v: Vector2, target, maxDistance: float) -> Vector2;
#foreign Vector2Invert :: fn(v: Vector2) -> Vector2;
#foreign Vector2Clamp :: fn(v: Vector2, min, max) -> Vector2;
#foreign Vector2ClampValue :: fn(v: Vector2, min: float, max) -> Vector2;
#foreign Vector2Equals :: fn(p: Vector2, q) -> int;
#foreign Vector2Refract :: fn(v: Vector2, n, r: float) -> Vector2;

/* Collision detection */
#foreign CheckCollisionRecs :: fn(rec1: Rectangle, rec2: Rectangle) -> bool;
#foreign CheckCollisionCircles :: fn(center1: Vector2, radius1: float, center2: Vector2, radius2: float) -> bool;
#foreign CheckCollisionCircleRec :: fn(center: Vector2, radius: float, rec: Rectangle) -> bool;
#foreign CheckCollisionPointRec :: fn(point: Vector2, rec: Rectangle) -> bool;
#foreign CheckCollisionPointCircle :: fn(point: Vector2, center: Vector2, radius: float) -> bool;
#foreign CheckCollisionPointTriangle :: fn(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2) -> bool;

/* Window stuff */
#foreign GetScreenWidth :: fn() -> int;
#foreign GetScreenHeight :: fn() -> int;

/* Input stuff */
#foreign GetMouseWheelMove :: fn() -> float;
#foreign GetMouseX :: fn() -> int;
#foreign GetMouseY :: fn() -> int;
#foreign GetMousePosition :: fn() -> Vector2;
#foreign IsMouseButtonPressed :: fn(button: int) -> bool;
#foreign IsMouseButtonDown :: fn(button: int) -> bool;
#foreign IsMouseButtonReleased :: fn(button: int) -> bool;
#foreign IsMouseButtonUp :: fn(button: int) -> bool;

#foreign GetKeyPressed :: fn() -> int;
#foreign GetCharPressed :: fn() -> char;
#foreign IsKeyPressed :: fn(key: int) -> bool;
#foreign IsKeyDown :: fn(key: int) -> bool;
#foreign IsKeyReleased :: fn(key: int) -> bool;
#foreign SetExitKey :: fn(key :int);

/* Drawing functions */
#foreign InitWindow :: fn(width: int, height: int, title: c_string) -> void;
#foreign WindowShouldClose :: fn() -> bool;
#foreign CloseWindow :: fn() -> void;
#foreign BeginDrawing :: fn() -> void;
#foreign EndDrawing :: fn() -> void;
#foreign ClearBackground :: fn(color: Color) -> void;

#foreign SetTargetFPS :: fn(fps: int) -> void;
#foreign DrawFPS :: fn(posX: int, posY: int) -> void;
#foreign GetFPS :: fn() -> int;
#foreign DrawLine :: fn(startPosX: int, startPosY, endPosX, endPosY, color: Color) -> void;
#foreign DrawCircle :: fn(centerX: int, centerY, radius: float, color: Color) -> void;
#foreign DrawRectangle :: fn(posX: int, posY, width, height, color: Color) -> void;
#foreign DrawTriangle :: fn(v1X: int, v1Y, v2X, v2Y, v3X, v3Y, color: Color) -> void;
#foreign DrawPoly :: fn(centerX: int, centerY: int, sides: int, radius: float, rotation: float, color: Color) -> void;
#foreign LoadTexture :: fn(fileName: c_string) -> Texture2D;
#foreign UnloadTexture :: fn(texture: Texture2D) -> void;
#foreign DrawTexture :: fn(texture: Texture2D, posX: int, posY: int, tint: Color) -> void;
#foreign DrawTextureEx :: fn(texture: Texture2D, position: Vector2, rotation: float, scale: float, tint: Color) -> void;
#foreign DrawRectangleRec :: fn(rec: Rectangle, color: Color) -> void;
#foreign DrawTextureRec :: fn(texture: Texture2D, sourceRec: Rectangle, position: Vector2, tint: Color) -> void;
#foreign DrawTexturePro :: fn(texture: Texture2D, sourceRec: Rectangle, destRec: Rectangle, origin: Vector2, rotation: float, tint: Color) -> void;
#foreign DrawRectangleLinesEx :: fn(rec: Rectangle, lineThick: int, color: Color) -> void;
#foreign DrawRectangleV :: fn(position: Vector2, size: Vector2, color: Color) -> void;
#foreign DrawRectangleLines :: fn(posX: int, posY: int, width: int, height: int, color: Color) -> void;
#foreign ColorAlphaBlend:: fn(dst: Color, src, tint) -> Color;
#foreign IsWindowResized :: fn() -> bool;
#foreign SetWindowState :: fn(flags: int) -> void;
#foreign BeginScissorMode :: fn(x: int, y, w, h);
#foreign EndScissorMode :: fn();
#foreign Fade :: fn(color: Color, alpha: float) -> Color;
#foreign ColorFromHSV :: fn(hue: float, saturation, value) -> Color;

#foreign SetCameraMode :: fn(camera: Camera2D, mode: int) -> void;
#foreign UpdateCamera :: fn(camera: Camera2D*) -> void;
#foreign BeginMode2D :: fn(camera: Camera2D) -> void;
#foreign EndMode2D :: fn() -> void;

#foreign GetWorldToScreen :: fn(position: Vector3, camera: Camera) -> Vector2;
#foreign GetWorldToScreenEx :: fn(position: Vector3, camera: Camera, width: int, height: int) -> Vector2;
#foreign GetWorldToScreen2D :: fn(position: Vector2, camera: Camera2D) -> Vector2;
#foreign GetScreenToWorld2D :: fn(position: Vector2, camera: Camera2D) -> Vector2;


/* Text functions */
#foreign DrawText :: fn(text: c_string, posX: int, posY: int, fontSize: int, color: Color) -> void;
#foreign MeasureText :: fn(text: c_string, fontSize: int) -> int;
#foreign TextFormat :: fn(format: c_string, ...) -> c_string;
#foreign LoadFont :: fn(fileName: c_string) -> Font;
#foreign DrawTextEx :: fn(font: Font, text: c_string, position: Vector2, fontSize: float, spacing: float, tint: Color) -> void;
#foreign MeasureTextEx :: fn(font: Font, text: c_string, fontSize: float, spacing: float) -> Vector2;


/* Audio functions */
#foreign LoadSound :: fn(fileName: c_string) -> Sound;
#foreign UnloadSound :: fn(sound: Sound) -> void;
#foreign PlaySound :: fn(sound: Sound) -> void;
#foreign StopSound :: fn(sound: Sound) -> void;
#foreign PauseSound :: fn(sound: Sound) -> void;
#foreign ResumeSound :: fn(sound: Sound) -> void;
#foreign LoadMusicStream :: fn(fileName: c_string) -> Music;
#foreign UnloadMusicStream :: fn(music: Music) -> void;
#foreign PlayMusicStream :: fn(music: Music) -> void;
#foreign UpdateMusicStream :: fn(music: Music) -> void;
#foreign StopMusicStream :: fn(music: Music) -> void;
#foreign PauseMusicStream :: fn(music: Music) -> void;
#foreign ResumeMusicStream :: fn(music: Music) -> void;
#foreign SetMusicVolume :: fn(music: Music, volume: float);
#foreign SetSoundVolume :: fn(sound: Sound, volume: float);
#foreign IsMusicStreamPlaying :: fn(music: Music) -> bool;
#foreign SetAudioStreamPitch :: fn(music: Music, pitch: float);
#foreign SetSoundPitch :: fn(sound: Sound, pitch: float) -> void;
#foreign InitAudioDevice :: fn() -> void;
#foreign CloseAudioDevice :: fn() -> void;
#foreign IsAudioDeviceReady :: fn() -> bool;
#foreign SetMasterVolume :: fn(volume: float) -> void;


// * ########### BUILTIN UI HELPERS ############### //
// * Function pointer to use with the `draw_button` function.
#alias ButtonCallback :: fn* () -> void;

// * Style struct used for UI styling.
Style :: struct {
  foreground: Color;
  background: Color;
  highlighted: Color;
  font_size: int;
  use_jiggly_text: bool = true;
  jiggle_intensity : float = 10.0;
  jiggle_rate : float = 4.0;
}

// * Measure the width of a jiggly text of 'text' and 'style'
measure_jiggly_text :: fn(text: c_string, style: Style) -> float {
  length: int = strlen(text);
  total_width: float = 0.0;
  for i in 0..length {
    total_width += style.font_size;
  }
  return total_width;
}

// * Draw wavy jiggly text.
jiggly_text :: fn(text: c_string, rect: Rectangle, style: Style) {
  time: float = GetTime() as float;
  length: int = strlen(text);

  intensity := style.jiggle_intensity;
  rate := style.jiggle_rate;

  for i in 0..length {
    char_x := rect.x + i * style.font_size as float;
    char_y := rect.y + intensity * sin(rate * time + (i as float));
    temp : char[2] = { text[i], '\0' };
    DrawText(temp as c_string, char_x as int, char_y as int, style.font_size, style.foreground);
  }
}

// * Draw a button with a click callback.
draw_button :: fn(text: c_string, rect: Rectangle, style: Style, callback: ButtonCallback) -> bool {
  position: Vector2 = { x: rect.x, y: rect.y};
  size: Vector2 = { x: rect.width, y: rect.height};

  text_width : float;
  if style.use_jiggly_text {
    text_width = measure_jiggly_text(text, style);
  } else {
    text_width = MeasureText(text, style.font_size);
  }

  text_height : float = style.font_size;

  if text_width > rect.width {
    size.x = text_width;
    position.x = rect.x - (text_width - rect.width) / 2;
  }

  new_rect : Rectangle = { x: position.x, y: position.y, width: size.x, height: size.y};

  text_x := position.x + (size.x - text_width) / 2;
  text_y := position.y + (size.y - text_height) / 2;

  mouse_over := CheckCollisionPointRec(GetMousePosition(), new_rect);

  if mouse_over {
    DrawRectangleV(position, size, style.highlighted);
    if (IsMouseButtonPressed(MouseButton::Left)) {
      callback();
      return true;
    }
  } else {
    DrawRectangleV(position, size, style.background);
  }

  if !style.use_jiggly_text {
    DrawText(text, text_x as int, text_y as int, style.font_size, style.foreground);
  } else {
    jiggly_text(text, { x: text_x, y: text_y, width: new_rect.width, height: new_rect.height}, style);
  }

  return false;
}

// *########### END BUILTIN UI HELPERS ############### */
// ? A simple timer that can be used in update loops to get a tick every N seconds.
// * interval: float = seconds between each tick.
Timer :: struct {
  interval : float = 0.5;
  // Returns true if the timer has exceeded the interval time relative to the last tick time.
  last_tick_time: float;
}

impl Timer {
  tick :: fn(self*) -> bool {
    now := GetTime();
    if self.last_tick_time == 0 {
      self.last_tick_time = now;
      return true;
    }
    if now >= (self.last_tick_time + self.interval) {
      self.last_tick_time = now;
      return true;
    }
    return false;
  }
}

SliderF :: struct {
  text: string;
  rect: Rectangle;
  style: Style;
  min_value: float;
  max_value: float;
  value: float*;
  held : bool;
  digits_to_show: int = 5;
}

impl SliderF {
  adjust_slider_value :: fn(self*) {
    increment: float;
    if IsKeyDown(Key::LeftShift) {
      increment = (self.max_value - self.min_value) / 100;
    } else {
      increment = (self.max_value - self.min_value) / 50;
    }
    if IsKeyPressed(Key::Right) {
      *self.value = clamp(*self.value + increment, min![float](self.min_value, self.max_value), max![float](self.min_value, self.max_value));
    } else if IsKeyPressed(Key::Left) {
      *self.value = clamp(*self.value - increment, min![float](self.min_value, self.max_value), max![float](self.min_value, self.max_value));
    }

    // Handle mouse input
    mouse_pos := GetMousePosition();
    if CheckCollisionPointRec(mouse_pos, self.rect) {
      if IsMouseButtonDown(MouseButton::Left) {
      self.held = true;
      }
    }

    if self.held {
      if !IsMouseButtonDown(MouseButton::Left) {
      self.held = false;
      } else {
      new_value := self.min_value + ((mouse_pos.x - self.rect.x) / self.rect.width) * (self.max_value - self.min_value);
      *self.value = clamp(new_value, min![float](self.min_value, self.max_value), max![float](self.min_value, self.max_value));
      }
    }
  }

  draw :: fn(self*) {
    // Draw the slider background
    DrawRectangleV(Vector2{ x: self.rect.x, y: self.rect.y}, Vector2{ x: self.rect.width, y: self.rect.height}, self.style.background);

    slider_width : float = self.rect.width * clamp((abs(*self.value - self.min_value) / abs(self.max_value - self.min_value)), 0.0, 1.0);
    slider_rect : Rectangle = {
      x: self.rect.x,
      y: self.rect.y,
      width: slider_width,
      height: self.rect.height
    };

    // Draw the slider foreground
    DrawRectangleV(Vector2{ x: slider_rect.x, y: slider_rect.y}, Vector2{ x: slider_rect.width, y: slider_rect.height}, self.style.foreground);

    DrawRectangleLines(self.rect.x as int, self.rect.y as int, self.rect.width as int, self.rect.height as int, self.style.highlighted);

    // Draw the text
    text_x := self.rect.x + (self.rect.width - MeasureText(self.text.data, self.style.font_size)) / 2;
    text_y := self.rect.y + (self.rect.height - self.style.font_size) / 2;
    DrawText(self.text.data, text_x as int, text_y as int, self.style.font_size, self.style.highlighted);

    // Draw the slider value
    value_text := $"{*self.value}";
    value_text.data[self.digits_to_show] = '\0';
    value_text_x := text_x + MeasureText(self.text.data, self.style.font_size) + 10; // 10 pixels padding
    DrawText(value_text.data, value_text_x as int, text_y as int, self.style.font_size, self.style.highlighted);

    self.adjust_slider_value();
  }
}

SliderI :: struct {
  text: string;
  rect: Rectangle;
  style: Style;
  min_value: int;
  max_value: int;
  value: int*;
  held : bool;
  digits_to_show: int = 3;
}

impl SliderI {
  adjust_slider_value :: fn(self*) {
    increment: float;
    if IsKeyDown(Key::LeftShift) {
      increment = (self.max_value - self.min_value) / 100;
    } else {
      increment = (self.max_value - self.min_value) / 50;
    }
    if IsKeyPressed(Key::Right) {
      *self.value = clamp(*self.value + increment, min![int](self.min_value, self.max_value), max![int](self.min_value, self.max_value));
    } else if IsKeyPressed(Key::Left) {
      *self.value = clamp(*self.value - increment, min![int](self.min_value, self.max_value), max![int](self.min_value, self.max_value));
    }

    // Handle mouse input
    mouse_pos := GetMousePosition();
    if CheckCollisionPointRec(mouse_pos, self.rect) {
      if IsMouseButtonDown(MouseButton::Left) {
      self.held = true;
      }
    }

    if self.held {
      if !IsMouseButtonDown(MouseButton::Left) {
      self.held = false;
      } else {
      new_value := self.min_value + ((mouse_pos.x - self.rect.x) / self.rect.width) * (self.max_value - self.min_value);
      *self.value = clamp(new_value, min![int](self.min_value, self.max_value), max![int](self.min_value, self.max_value));
      }
    }
  }

  draw :: fn(self*) {
    DrawRectangleV(Vector2{ x: self.rect.x, y: self.rect.y}, Vector2{ x: self.rect.width, y: self.rect.height}, self.style.background);

    v_f := (*self.value) as float;
    min_f := self.min_value as float;
    max_f := self.max_value as float;

    slider_width : float = self.rect.width * clamp(abs(v_f - min_f) / abs(max_f - min_f), 0.0, 1.0);

    slider_rect : Rectangle = {
      x: self.rect.x,
      y: self.rect.y,
      width: slider_width,
      height: self.rect.height
    };

    DrawRectangleV(Vector2{ x: slider_rect.x, y: slider_rect.y}, Vector2{ x: slider_rect.width, y: slider_rect.height}, self.style.foreground);

    DrawRectangleLines(self.rect.x as int, self.rect.y as int, self.rect.width as int, self.rect.height as int, self.style.highlighted);

    text_x := self.rect.x + (self.rect.width - MeasureText(self.text.data, self.style.font_size)) / 2;
    text_y := self.rect.y + (self.rect.height - self.style.font_size) / 2;
    DrawText(self.text.data, text_x as int, text_y as int, self.style.font_size, self.style.highlighted);

    value_text := $"{*self.value}";
    value_text.data[self.digits_to_show] = '\0';
    value_text_x := text_x + MeasureText(self.text.data, self.style.font_size) + 10; // 10 pixels padding
    DrawText(value_text.data, value_text_x as int, text_y as int, self.style.font_size, self.style.highlighted);

    self.adjust_slider_value();
  }
}

CheckButton :: struct {
  value: bool = false;
  rect: Rectangle;
  style: Style;
  text: string;
  allow_hold : bool;
}

impl CheckButton {
  draw :: fn(self*) {
  if self.value {
    DrawRectangleV(Vector2{ x: self.rect.x, y: self.rect.y}, Vector2{ x: self.rect.width, y: self.rect.height}, self.style.highlighted);
  } else {
    DrawRectangleV(Vector2{ x: self.rect.x, y: self.rect.y}, Vector2{ x: self.rect.width, y: self.rect.height}, self.style.background);
  }

  if self.text.data {
    text_x := self.rect.x + (self.rect.width - MeasureText(self.text.data, self.style.font_size)) / 2;
    text_y := self.rect.y + (self.rect.height - self.style.font_size) / 2;
    DrawText(self.text.data, text_x as int, text_y as int, self.style.font_size, self.style.foreground);
  }

  hit := CheckCollisionPointRec(GetMousePosition(), self.rect);

  if hit {
    DrawRectangleLines(self.rect.x as int, self.rect.y as int, self.rect.width as int, self.rect.height as int, ORANGE);
  }

  left := false;
  right := false;

  if self.allow_hold {
    left = IsMouseButtonDown(MouseButton::Left);
    right = IsMouseButtonDown(MouseButton::Right);
    if hit && left {
    self.value = true;
    } else if hit && right {
    self.value = false;
    }
  } else if hit && IsMouseButtonPressed(MouseButton::Left) {
    self.value = !self.value;
  }
  }
}

DropDown :: struct {
  options: string[];
  rect: Rectangle;
  style: Style;
  selected_index: int = -1;
  is_open: bool = false;
  on_selected: fn*(int) = null;
  on_open: fn*() = null;
  label: string;
  show_selected_option := false;
}

impl DropDown {
  draw :: fn(self*) {
  // Draw the dropdown box
  DrawRectangleV(Vector2{ x: self.rect.x, y: self.rect.y}, Vector2{ x: self.rect.width, y: self.rect.height}, self.style.background);

  if self.selected_index >= 0 && self.selected_index < self.options.length && self.show_selected_option {
    // Draw the selected option
    text_x := self.rect.x + (self.rect.width - MeasureText(self.options[self.selected_index].data, self.style.font_size)) / 2;
    text_y := self.rect.y + (self.rect.height - self.style.font_size) / 2;
    DrawText(self.options[self.selected_index].data, text_x as int, text_y as int, self.style.font_size, self.style.foreground);
  } else {
    // Draw the label
    text_x := self.rect.x + (self.rect.width - MeasureText(self.label.data, self.style.font_size)) / 2;
    text_y := self.rect.y + (self.rect.height - self.style.font_size) / 2;
    DrawText(self.label.data, text_x as int, text_y as int, self.style.font_size, self.style.foreground);
  }

  hit := CheckCollisionPointRec(GetMousePosition(), self.rect);
  if hit && IsMouseButtonPressed(MouseButton::Left) {
    self.is_open = !self.is_open;
    if self.is_open && self.on_open {
    self.on_open();
    }
  }

  hit_option := false;
  if self.is_open {
    option_rect := self.rect;
    option_rect.y += self.rect.height;
    for i in 0..self.options.length {
    option_color := self.style.background;
    if CheckCollisionPointRec(GetMousePosition(), option_rect) {
      option_color = self.style.highlighted;
      hit_option = true;
    }
    DrawRectangleV(Vector2{ x: option_rect.x, y: option_rect.y}, Vector2{ x: option_rect.width, y: option_rect.height}, option_color);
    text_x := option_rect.x + (option_rect.width - MeasureText(self.options[i].data, self.style.font_size)) / 2;
    text_y := option_rect.y + (option_rect.height - self.style.font_size) / 2;
    DrawText(self.options[i].data, text_x as int, text_y as int, self.style.font_size, self.style.foreground);

    if CheckCollisionPointRec(GetMousePosition(), option_rect) && IsMouseButtonPressed(MouseButton::Left) {
      self.selected_index = i;
      self.is_open = false;
      if self.on_selected {
      self.on_selected(i);
      }
    }
    option_rect.y += option_rect.height;
    }
  }

  if !hit && !hit_option {
    self.is_open = false;
  }
  }
}
