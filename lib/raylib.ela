#compiler_flags "-lraylib -lm"
#import core;

Key :: enum {
  Null            = 0,  
  Apostrophe      = 39, 
  Comma           = 44, 
  Minus           = 45, 
  Period          = 46, 
  Slash           = 47, 
  Zero            = 48, 
  One             = 49, 
  Two             = 50, 
  Three           = 51, 
  Four            = 52, 
  Five            = 53, 
  Six             = 54, 
  Seven           = 55, 
  Eight           = 56, 
  Nine            = 57, 
  Semicolon       = 59, 
  Equal           = 61, 
  A               = 65, 
  B               = 66, 
  C               = 67, 
  D               = 68, 
  E               = 69, 
  F               = 70, 
  G               = 71, 
  H               = 72, 
  I               = 73, 
  J               = 74, 
  K               = 75, 
  L               = 76, 
  M               = 77, 
  N               = 78, 
  O               = 79, 
  P               = 80, 
  Q               = 81, 
  R               = 82, 
  S               = 83, 
  T               = 84, 
  U               = 85, 
  V               = 86, 
  W               = 87, 
  X               = 88, 
  Y               = 89, 
  Z               = 90, 
  LeftBracket    = 91, 
  Backslash       = 92, 
  RightBracket   = 93, 
  Grave           = 96, 
  Space           = 32, 
  Escape          = 256,
  Enter           = 257,
  Tab             = 258,
  Backspace       = 259,
  Insert          = 260,
  Delete          = 261,
  Right           = 262,
  Left            = 263,
  Down            = 264,
  Up              = 265,
  PageUp         = 266,
  PageDown       = 267,
  Home            = 268,
  End             = 269,
  CapsLock       = 280,
  ScrollLock     = 281,
  NumLock        = 282,
  PrintScreen    = 283,
  Pause           = 284,
  F1              = 290,
  F2              = 291,
  F3              = 292,
  F4              = 293,
  F5              = 294,
  F6              = 295,
  F7              = 296,
  F8              = 297,
  F9              = 298,
  F10             = 299,
  F11             = 300,
  F12             = 301,
  LeftShift      = 340,
  LeftControl    = 341,
  LeftAlt        = 342,
  LeftSuper      = 343,
  RightShift     = 344,
  RightControl   = 345,
  RightAlt       = 346,
  RightSuper     = 347,
  Kb_menu         = 348,
  Keypad0            = 320,
  Keypad1            = 321,
  Keypad2            = 322,
  Keypad3            = 323,
  Keypad4            = 324,
  Keypad5            = 325,
  Keypad6            = 326,
  Keypad7            = 327,
  Keypad8            = 328,
  Keypad9            = 329,
  KpDecimal      = 330,
  KpDivide       = 331,
  KpMultiply     = 332,
  KpSubtract     = 333,
  KpAdd          = 334,
  KpEnter        = 335,
  KpEqual        = 336,
  Back            = 4,  
  Menu            = 5,  
  VolumeUp       = 24, 
  VolumeDown     = 25  
}

MouseButton :: enum {
  Left = 0,
  Right = 1,
  Middle = 2,
  Side = 3,
  Extra = 4,
  Forward = 5,
  Back = 6
}

Color :: struct {
  r: u8;
  g: u8;
  b: u8;
  a: u8;
  
  to_string :: () -> string {
    return $"r: {r}, g: {g}, b: {b}, a: {a}";
  }
  
  #operator(==) :: (other: #self) -> bool {
    return other.a == a && other.r == r && other.g == g && other.b == b;
  }
  
  with_alpha :: (a: int) -> #self {
    color := *this;
    color.a = (u8)a;
    return color;
  }
}

Texture2D :: struct {
  id: int;
  width: int;
  height: int;
  mipmaps: int;
  format: int;
}

Vector2 :: struct {
  x: float;
  y: float;

  #operator(+) :: (other: #self) -> #self {
    return #make(#self, { x + other.x, y + other.y });
  }

  #operator(-) :: (other: #self) -> #self {
    return #make(#self, {x - other.x, y - other.y });
  }

  #operator(*) :: (scalar: float) -> #self {
    return #make(#self, {x * scalar, y * scalar });
  }

  #operator(/) :: (scalar: float) -> #self {
    return #make(#self, {x / scalar, y / scalar });
  }

  #operator(+=) :: (other: #self) -> #self {
    x += other.x;
    y += other.y;
    return *this;
  }

  #operator(-=) :: (other: #self) -> #self {
    x -= other.x;
    y -= other.y;
    return *this;
  }

  #operator(*=) :: (scalar: float) -> #self {
    x *= scalar;
    y *= scalar;
    return *this;
  }

  #operator(/=) :: (scalar: float) -> #self {
    x /= scalar;
    y /= scalar;
    return *this;
  }
  
  to_string :: () -> string {
    return $"x: {x}, y: {y}"
  }
}

Vector3 :: struct {
  x: float;
  y: float;
  z: float;
  
  #operator(+) :: (other: Vector3) -> Vector3 {
    return #make(#self, {x + other.x, y + other.y, z + other.z });
  }

  #operator(-) :: (other: Vector3) -> Vector3 {
    return #make(#self, {x - other.x, y - other.y, z - other.z });
  }

  #operator(*) :: (scalar: float) -> Vector3 {
    return #make(#self, {x * scalar, y * scalar, z * scalar });
  }

  #operator(/) :: (scalar: float) -> Vector3 {
    return #make(#self, {x / scalar, y / scalar, z / scalar });
  }

  #operator(+=) :: (other: Vector3) -> Vector3 {
    x += other.x;
    y += other.y;
    z += other.z;
    return *this;
  }

  #operator(-=) :: (other: Vector3) -> Vector3 {
    x -= other.x;
    y -= other.y;
    z -= other.z;
    return *this;
  }

  #operator(*=) :: (scalar: float) -> Vector3 {
    x *= scalar;
    y *= scalar;
    z *= scalar;
    return *this;
  }

  #operator(/=) :: (scalar: float) -> Vector3 {
    x /= scalar;
    y /= scalar;
    z /= scalar;
    return *this;
  }
  
  to_string :: () -> string {
    return $"x: {x}, y: {y}, z: {z}"
  }
}

Rectangle :: struct {
  x: float;
  y: float;
  width: float;
  height: float;
  
  to_string :: () -> string {
    return $"x: {x}, y: {y}, width: {width}, height: {height}";
  }
}

// Opaque structs defined in C files in raudio.c;
rAudioBuffer :: struct;
rAudioProcessor :: struct;

AudioStream :: struct {
  buffer: rAudioBuffer*;
  processor: rAudioProcessor*;
  sampleRate: u32;
  sampleSize: u32;
  channels: u32;
}

Music :: struct {
  stream: AudioStream;
  frameCount: u32;
  looping: bool;
  ctxType: int;
  ctxData: void*;
}

Sound :: struct {
  stream: AudioStream;
  frameCount: u32;
} 

color_with_alpha :: (color: Color, alpha: u8) -> Color {
  color.a = alpha;
  return color;
}

color_lerp :: (a: Color, b: Color, t: float) -> Color {
  return #make(Color, {
    (u8)clamp(a.r + (b.r - a.r) * t, 0, 255),
    (u8)clamp(a.g + (b.g - a.g) * t, 0, 255),
    (u8)clamp(a.b + (b.b - a.b) * t, 0, 255),
    (u8)clamp(a.a + (b.a - a.a) * t, 0, 255)
  });
}

CLEAR: Color;
WHITE: Color = { (u8)255, (u8)255, (u8)255, (u8)255 };
BLACK: Color = { (u8)0, (u8)0, (u8)0, (u8)255 };
RED: Color = { (u8)255, (u8)0, (u8)0, (u8)255 };
GREEN: Color = { (u8)0, (u8)255, (u8)0, (u8)255 };
BLUE: Color = { (u8)0, (u8)0, (u8)255, (u8)255 };
YELLOW: Color = { (u8)255, (u8)255, (u8)0, (u8)255 };
PURPLE: Color = { (u8)255, (u8)0, (u8)255, (u8)255 };
ORANGE: Color = { (u8)255, (u8)165, (u8)0, (u8)255 };
GRAY: Color = { (u8)128, (u8)128, (u8)128, (u8)255 };
DARKGRAY: Color = { (u8)80, (u8)80, (u8)80, (u8)255 };
LIGHTGRAY: Color = { (u8)200, (u8)200, (u8)200, (u8)255 };
BROWN: Color = { (u8)165, (u8)42, (u8)42, (u8)255 };
PINK: Color = { (u8)255, (u8)192, (u8)203, (u8)255 };
LIME: Color = { (u8)0, (u8)255, (u8)0, (u8)255 };
DARKGREEN: Color = { (u8)0, (u8)100, (u8)0, (u8)255 };
SKYBLUE: Color = { (u8)135, (u8)206, (u8)235, (u8)255 };
VIOLET: Color = { (u8)238, (u8)130, (u8)238, (u8)255 };
GOLD: Color = { (u8)255, (u8)215, (u8)0, (u8)255 };
BEIGE: Color = { (u8)245, (u8)245, (u8)220, (u8)255 };
MAGENTA: Color = { (u8)255, (u8)0, (u8)255, (u8)255 };
MAROON: Color = { (u8)128, (u8)0, (u8)0, (u8)255 };
DARKBLUE: Color = { (u8)0, (u8)0, (u8)139, (u8)255 };
DARKPURPLE: Color = { (u8)139, (u8)0, (u8)139, (u8)255 };
DARKBROWN: Color = { (u8)101, (u8)67, (u8)33, (u8)255 };
CYAN: Color = { (u8)0, (u8)255, (u8)255, (u8)255 };
DARKCYAN: Color = { (u8)0, (u8)139, (u8)139, (u8)255 };
LIGHTCYAN: Color = { (u8)224, (u8)255, (u8)255, (u8)255 };

// Exclude black and white.
All_Colors : Color[] = {
  WHITE,
  RED,
  GREEN,
  BLUE,
  YELLOW,
  PURPLE,
  ORANGE,
  GRAY,
  DARKGRAY,
  LIGHTGRAY,
  BROWN,
  PINK,
  LIME,
  DARKGREEN,
  SKYBLUE,
  VIOLET,
  GOLD,
  BEIGE,
  MAGENTA,
  MAROON,
  DARKBLUE,
  DARKPURPLE,
  DARKBROWN,
  CYAN,
  DARKCYAN,
  LIGHTCYAN,
}


#foreign InitTimer :: () -> void;
#foreign GetTime :: () -> float64;

#foreign Vector2Zero :: () -> Vector2;
#foreign Vector2One :: () -> Vector2;
#foreign Vector2Add :: (v: Vector2, v1: Vector2) -> Vector2;
#foreign Vector2AddValue :: (v: Vector2, add: float) -> Vector2;
#foreign Vector2Subtract :: (v: Vector2, v1: Vector2) -> Vector2;
#foreign Vector2SubtractValue :: (v: Vector2, sub: float) -> Vector2;
#foreign Vector2Length :: (v: Vector2) -> float;
#foreign Vector2LengthSqr :: (v: Vector2) -> float;
#foreign Vector2DotProduct :: (v: Vector2, v1: Vector2) -> float;
#foreign Vector2Distance :: (v: Vector2, v1: Vector2) -> float;
#foreign Vector2DistanceSqr :: (v: Vector2, v1: Vector2) -> float;
#foreign Vector2Angle :: (v: Vector2, v1: Vector2) -> float;
#foreign Vector2LineAngle :: (start: Vector2, end) -> float;
#foreign Vector2Scale :: (v: Vector2, scale: float) -> Vector2;
#foreign Vector2Multiply :: (v: Vector2, v1) -> Vector2;
#foreign Vector2Negate :: (v: Vector2) -> Vector2;
#foreign Vector2Divide :: (v: Vector2, v1) -> Vector2;
#foreign Vector2Normalize :: (v: Vector2) -> Vector2;
// I don't think we have matrices yet.
// #foreign Vector2Transform :: (v: Vector2, mat: Matrix) -> Vector2;
#foreign Vector2Lerp :: (v: Vector2, v1, amount: float) -> Vector2;
#foreign Vector2Reflect :: (v: Vector2, normal) -> Vector2;
#foreign Vector2Min :: (v: Vector2, v1) -> Vector2;
#foreign Vector2Max :: (v: Vector2, v1) -> Vector2;
#foreign Vector2Rotate :: (v: Vector2, angle: float) -> Vector2;
#foreign Vector2MoveTowards :: (v: Vector2, target, maxDistance: float) -> Vector2;
#foreign Vector2Invert :: (v: Vector2) -> Vector2;
#foreign Vector2Clamp :: (v: Vector2, min, max) -> Vector2;
#foreign Vector2ClampValue :: (v: Vector2, min: float, max) -> Vector2;
#foreign Vector2Equals :: (p: Vector2, q) -> int;
#foreign Vector2Refract :: (v: Vector2, n, r: float) -> Vector2;

#foreign CheckCollisionRecs :: (rec1: Rectangle, rec2: Rectangle) -> bool;
#foreign CheckCollisionCircles :: (center1: Vector2, radius1: float, center2: Vector2, radius2: float) -> bool;
#foreign CheckCollisionCircleRec :: (center: Vector2, radius: float, rec: Rectangle) -> bool;
#foreign CheckCollisionPointRec :: (point: Vector2, rec: Rectangle) -> bool;
#foreign CheckCollisionPointCircle :: (point: Vector2, center: Vector2, radius: float) -> bool;
#foreign CheckCollisionPointTriangle :: (point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2) -> bool;


#foreign GetKeyPressed :: () -> int;
#foreign GetScreenWidth :: () -> int;
#foreign GetScreenHeight :: () -> int;

#foreign GetMouseX :: () -> int;
#foreign GetMouseY :: () -> int;
#foreign GetMousePosition :: () -> Vector2;
#foreign IsMouseButtonPressed :: (button: int) -> bool;
#foreign IsMouseButtonDown :: (button: int) -> bool;
#foreign IsMouseButtonReleased :: (button: int) -> bool;
#foreign IsMouseButtonUp :: (button: int) -> bool;

#foreign InitWindow :: (width: int, height: int, title: char*) -> void;
#foreign WindowShouldClose :: () -> bool;
#foreign CloseWindow :: () -> void;
#foreign BeginDrawing :: () -> void;
#foreign EndDrawing :: () -> void;
#foreign ClearBackground :: (color: Color) -> void;
#foreign DrawText :: (text: char*, posX: int, posY: int, fontSize: int, color: Color) -> void;
#foreign IsKeyPressed :: (key: int) -> bool;
#foreign IsKeyDown :: (key: int) -> bool;
#foreign IsKeyReleased :: (key: int) -> bool;
#foreign SetTargetFPS :: (fps: int) -> void;
#foreign DrawFPS :: (posX: int, posY: int) -> void;
#foreign GetFPS :: () -> int;
#foreign DrawLine :: (startPosX: int, startPosY, endPosX, endPosY, color: Color) -> void;
#foreign DrawCircle :: (centerX: int, centerY, radius: float, color: Color) -> void;
#foreign DrawRectangle :: (posX: int, posY, width, height, color: Color) -> void;
#foreign DrawTriangle :: (v1X: int, v1Y, v2X, v2Y, v3X, v3Y, color: Color) -> void;
#foreign DrawPoly :: (centerX: int, centerY: int, sides: int, radius: float, rotation: float, color: Color) -> void;
#foreign LoadTexture :: (fileName: char*) -> Texture2D;
#foreign UnloadTexture :: (texture: Texture2D) -> void;
#foreign DrawTexture :: (texture: Texture2D, posX: int, posY: int, tint: Color) -> void;
#foreign DrawTextureEx :: (texture: Texture2D, position: Vector2, rotation: float, scale: float, tint: Color) -> void;
#foreign DrawTextureRec :: (texture: Texture2D, sourceRec: Rectangle, position: Vector2, tint: Color) -> void;
#foreign DrawTexturePro :: (texture: Texture2D, sourceRec: Rectangle, destRec: Rectangle, origin: Vector2, rotation: float, tint: Color) -> void;
#foreign DrawRectangleV :: (position: Vector2, size: Vector2, color: Color) -> void;
#foreign DrawRectangleLines :: (posX: int, posY: int, width: int, height: int, color: Color) -> void;
#foreign LoadSound :: (fileName: char*) -> Sound;
#foreign UnloadSound :: (sound: Sound) -> void;
#foreign PlaySound :: (sound: Sound) -> void;
#foreign StopSound :: (sound: Sound) -> void;
#foreign PauseSound :: (sound: Sound) -> void;
#foreign ResumeSound :: (sound: Sound) -> void;
#foreign LoadMusicStream :: (fileName: char*) -> Music;
#foreign UnloadMusicStream :: (music: Music) -> void;
#foreign PlayMusicStream :: (music: Music) -> void;
#foreign UpdateMusicStream :: (music: Music) -> void;
#foreign StopMusicStream :: (music: Music) -> void;
#foreign PauseMusicStream :: (music: Music) -> void;
#foreign ResumeMusicStream :: (music: Music) -> void;
#foreign SetMusicVolume :: (music: Music, volume: float);
#foreign SetSoundVolume :: (sound: Sound, volume: float);
#foreign IsMusicStreamPlaying :: (music: Music) -> bool;
#foreign SetAudioStreamPitch :: (music: Music, pitch: float);
#foreign SetSoundPitch :: (sound: Sound, pitch: float) -> void;
#foreign InitAudioDevice :: () -> void;
#foreign CloseAudioDevice :: () -> void;
#foreign IsAudioDeviceReady :: () -> bool;
#foreign SetMasterVolume :: (volume: float) -> void;
#foreign ColorAlphaBlend:: (dst: Color, src, tint) -> Color;
#foreign SetExitKey :: (key :int);
#foreign MeasureText :: (text: char*, fontSize: int) -> int;
#foreign TextFormat :: (format: char*, ...) -> char*;

Camera :: struct {
  position:     Vector3;
  target:       Vector3;
  up:           Vector3;
  fovy:         float;
  projection:   int;
} 

Camera2D :: struct {
  offset:         Vector2;
  target:         Vector2;
  rotation:       float;
  zoom:           float = 1.0;
}

CameraMode :: enum {
  Custom        = 0,
  Free          = 1,
  Orbital       = 2,
  FirstPerson   = 3,
  ThirdPerson   = 4
}

ConfigFlags :: enum {
  FullscreenMode        = 0x00000002, // 1 << 1
  WindowResizable       = 0x00000004, // 1 << 2
  WindowUndecorated     = 0x00000008, // 1 << 3
  WindowTransparent     = 0x00000010, // 1 << 4
  Msaa4xHint            = 0x00000020, // 1 << 5
  VsyncHint             = 0x00000040, // 1 << 6
  WindowHidden          = 0x00000080, // 1 << 7
  WindowAlwaysRun       = 0x00000100, // 1 << 8
  WindowMinimized       = 0x00000200, // 1 << 9
  WindowMaximized       = 0x00000400, // 1 << 10
  WindowUnfocused       = 0x00000800, // 1 << 11
  WindowTopmost         = 0x00001000, // 1 << 12
  WindowHighdpi         = 0x00002000, // 1 << 13
  WindowMousePassthrough = 0x00004000, // 1 << 14
  BorderlessWindowedMode = 0x00008000, // 1 << 15
  InterlacedHint        = 0x00010000  // 1 << 16
}

#foreign IsWindowResized :: () -> bool;      
#foreign SetWindowState :: (flags: int) -> void;
#foreign BeginScissorMode :: (x: int, y, w, h);
#foreign EndScissorMode :: ();
#foreign Fade :: (color: Color, alpha: float) -> Color;
#foreign ColorFromHSV :: (hue: float, saturation, value) -> Color;

#foreign SetCameraMode :: (camera: Camera2D, mode: int) -> void;
#foreign UpdateCamera :: (camera: Camera2D*) -> void;
#foreign BeginMode2D :: (camera: Camera2D) -> void;
#foreign EndMode2D :: () -> void;

#foreign GetWorldToScreen :: (position: Vector3, camera: Camera) -> Vector2;
#foreign GetWorldToScreenEx :: (position: Vector3, camera: Camera, width: int, height: int) -> Vector2;
#foreign GetWorldToScreen2D :: (position: Vector2, camera: Camera2D) -> Vector2;
#foreign GetScreenToWorld2D :: (position: Vector2, camera: Camera2D) -> Vector2;


// * ########### BUILTIN UI HELPERS ############### //
// * Function pointer to use with the `draw_button` function.
#alias ButtonCallback :: void()*;

// * Style struct used for UI styling.
Style :: struct {
  foreground: Color;
  background: Color;
  highlighted: Color;
  font_size: int;
  use_jiggly_text: bool = true;
  jiggle_intensity : float = 10.0;
  jiggle_rate : float = 4.0;
}

// * Measure the width of a jiggly text of 'text' and 'style'
measure_jiggly_text :: (text: char*, style: Style) -> float {
  length: int = strlen(text);
  total_width: float = 0.0;
  for i : int = 0; i < length; i++ {
    total_width += style.font_size;
  }
  return total_width;
}

// * Draw wavy jiggly text.
jiggly_text :: (text: char*, rect: Rectangle, style: Style) {
  time: float = (float)GetTime();
  length: int = strlen(text);
  
  intensity := style.jiggle_intensity;
  rate := style.jiggle_rate;
  
  for i : int = 0; i < length; i++ {
    char_x := rect.x + i * style.font_size;
    char_y := rect.y + intensity * sin(rate * time + i);
    temp : char[2] = { text[i], #char "\0" };
    DrawText((char*)temp, (int)char_x, (int)char_y, style.font_size, style.foreground);
  }
}

// * Draw a button with a click callback.
draw_button :: (text: char*, rect: Rectangle, style: Style, callback: ButtonCallback) -> bool {
  position: Vector2 = {rect.x, rect.y};
  size: Vector2 = {rect.width, rect.height};
  
  text_width : float;
  if style.use_jiggly_text {
    text_width = measure_jiggly_text(text, style);
  } else {
    text_width = MeasureText(text, style.font_size);
  }
  
  text_height : float = style.font_size; 
  
  if text_width > rect.width {
    size.x = text_width;
    position.x = rect.x - (text_width - rect.width) / 2;
  }
  
  rect = {position.x, position.y, size.x, size.y};
  
  text_x := position.x + (size.x - text_width) / 2;
  text_y := position.y + (size.y - text_height) / 2;
  
  mouse_over := CheckCollisionPointRec(GetMousePosition(), rect);
  
  if mouse_over {
    DrawRectangleV(position, size, style.highlighted);
    if (IsMouseButtonPressed(MouseButton.Left)) {
      callback();
      return true;
    }
  } else {
    DrawRectangleV(position, size, style.background);
  }
  
  if !style.use_jiggly_text {
    DrawText(text, (int)text_x, (int)text_y, style.font_size, style.foreground);
  } else {
    jiggly_text(text, {text_x, text_y, rect.width, rect.height}, style);
  }

  return false;
}

// *########### END BUILTIN UI HELPERS ############### */
// ? A simple timer that can be used in update loops to get a tick every N seconds.
// * interval: float = seconds between each tick.
Timer :: struct {
  interval : float = 0.5;
  // Returns true if the timer has exceeded the interval time relative to the last tick time.
  last_tick_time: float;
  tick :: () -> bool {
    now := GetTime();
    if last_tick_time == 0 {
      last_tick_time = now;
      return true;
    }
    if now > (last_tick_time + interval) {
      its := (int)((now - last_tick_time) / interval);
      last_tick_time += (float)its * interval;
      return true;
    }
    return false;
  }
}

SliderF :: struct {
  text: string;
  rect: Rectangle;
  style: Style;
  min_value: float;
  max_value: float;
  value: float*;
  held : bool;
  draw :: () {
    // Draw the slider background
    DrawRectangleV(Vector2{rect.x, rect.y}, Vector2{rect.width, rect.height}, style.background);

    slider_width : float = rect.width * clamp((abs(*this.value - min_value) / abs(max_value - min_value)), 0.0, 1.0);
    slider_rect : Rectangle = {
      rect.x,
      rect.y,
      slider_width,
      rect.height
    };

    // Draw the slider foreground
    DrawRectangleV(Vector2{slider_rect.x, slider_rect.y}, Vector2{slider_rect.width, slider_rect.height}, style.foreground);

    DrawRectangleLines((int)rect.x, (int)rect.y, (int)rect.width, (int)rect.height, style.highlighted);

    
    // Draw the text
    text_x := rect.x + (rect.width - MeasureText(text.data, style.font_size)) / 2;
    text_y := rect.y + (rect.height - style.font_size) / 2;
    DrawText(text.data, (int)text_x, (int)text_y, style.font_size, style.highlighted);

    // Draw the slider value

    value_text := $"{*this.value}";
    value_text.data[3] = #char "\0";
    value_text_x := rect.x + text_x + MeasureText(text.data, style.font_size) + 10; // 10 pixels padding
    DrawText(value_text.data, (int)value_text_x, (int)text_y, style.font_size, style.highlighted);


    adjust_slider_value :: () {
      increment: float;
      if IsKeyDown(Key.LeftShift) {
        increment = (max_value - min_value) / 100;
      } else {
        increment = (max_value - min_value) / 50;
      }
      if IsKeyPressed(Key.Right) {
        *this.value = clamp(*this.value + increment, min(min_value, max_value), max(min_value, max_value));
      } else if IsKeyPressed(Key.Left) {
        *this.value = clamp(*this.value - increment, min(min_value, max_value), max(min_value, max_value));
      }
    };

    // Handle mouse input and call the local function for keyboard input
    mouse_pos := GetMousePosition();
    if CheckCollisionPointRec(mouse_pos, rect) {
      if IsMouseButtonPressed(MouseButton.Left) {
        this.held = true;
      }
      adjust_slider_value(); 
    }

    if this.held {
      if IsMouseButtonUp(MouseButton.Left) {
        this.held = false;
      } else {
        new_value := min_value + ((mouse_pos.x - rect.x) / rect.width) * (max_value - min_value);
        *this.value = clamp(new_value, min(min_value, max_value), max(min_value, max_value));
      }
    }
  }
}

SliderI :: struct {
  text: string;
  rect: Rectangle;
  style: Style;
  min_value: int;
  max_value: int;
  value: int*;
  held : bool;
  draw :: () {
    DrawRectangleV(Vector2{rect.x, rect.y}, Vector2{rect.width, rect.height}, style.background);

    v_f := (float)*this.value;
    min_f := (float)min_value;
    max_f := (float)max_value;

    slider_width : float = rect.width * clamp(abs(v_f - min_f) / abs(max_f - min_f), 0.0, 1.0);
    
    slider_rect : Rectangle = {
      rect.x,
      rect.y,
      slider_width,
      rect.height
    };

    DrawRectangleV(Vector2{slider_rect.x, slider_rect.y}, Vector2{slider_rect.width, slider_rect.height}, style.foreground);

    DrawRectangleLines((int)rect.x, (int)rect.y, (int)rect.width, (int)rect.height, style.highlighted);

    text_x := rect.x + (rect.width - MeasureText(text.data, style.font_size)) / 2;
    text_y := rect.y + (rect.height - style.font_size) / 2;
    DrawText(text.data, (int)text_x, (int)text_y, style.font_size, style.highlighted);

    value_text := $"{*this.value}";
    value_text.data[3] = #char "\0";
    value_text_x := rect.x + text_x + MeasureText(text.data, style.font_size) + 10; // 10 pixels padding
    DrawText(value_text.data, (int)value_text_x, (int)text_y, style.font_size, style.highlighted);


    adjust_slider_value :: () {
      increment: float;
      if IsKeyDown(Key.LeftShift) {
        increment = (max_value - min_value) / 100;
      } else {
        increment = (max_value - min_value) / 50;
      }
      if IsKeyPressed(Key.Right) {
        *this.value = clamp(*this.value + increment, min(min_value, max_value), max(min_value, max_value));
      } else if IsKeyPressed(Key.Left) {
        *this.value = clamp(*this.value - increment, min(min_value, max_value), max(min_value, max_value));
      }
    };

    mouse_pos := GetMousePosition();
    if CheckCollisionPointRec(mouse_pos, rect) {
      if IsMouseButtonPressed(MouseButton.Left) {
        this.held = true;
      }
      adjust_slider_value();
    }

    if this.held {
      if IsMouseButtonUp(MouseButton.Left) {
        this.held = false;
      } else {
        new_value := min_value + ((mouse_pos.x - rect.x) / rect.width) * (max_value - min_value);
        *this.value = clamp(new_value, min(min_value, max_value), max(min_value, max_value));
      }
    }
  }
}

CheckButton :: struct {
  value: bool = false;
  rect: Rectangle;
  style: Style;
  text: string;
  allow_hold : bool;
  
  draw :: () {
    if value {
      DrawRectangleV(Vector2{rect.x, rect.y}, Vector2{rect.width, rect.height}, style.highlighted);
    } else {
      DrawRectangleV(Vector2{rect.x, rect.y}, Vector2{rect.width, rect.height}, style.background);
    }
  
    if text.data {
      text_x := rect.x + (rect.width - MeasureText(text.data, style.font_size)) / 2;
      text_y := rect.y + (rect.height - style.font_size) / 2;
      DrawText(text.data, (int)text_x, (int)text_y, style.font_size, style.foreground);
    }
  
    if CheckCollisionPointRec(GetMousePosition(), rect) {
      DrawRectangleLines((int)rect.x, (int)rect.y, (int)rect.width, (int)rect.height, ORANGE);
    }
    
    
    left := false;
    right := false;
    hit := CheckCollisionPointRec(GetMousePosition(), rect);
    
    if allow_hold {
      left = IsMouseButtonDown(MouseButton.Left)
      right = IsMouseButtonDown(MouseButton.Right);
      if hit && left {
        value = true;
      } else if hit && right {
        value = false;
      }
    } else if hit && IsMouseButtonPressed(MouseButton.Left) {
      value = !value;
    }
    
    
    
  }
}

DropDown :: struct {
  options: string[];
  rect: Rectangle;
  style: Style;
  selected_index: int = -1;
  is_open: bool = false;
  on_selected: void(int)* = null;
  on_open: void()* = null;
    draw :: () {
      // Draw the dropdown box
      DrawRectangleV(Vector2{rect.x, rect.y}, Vector2{rect.width, rect.height}, style.background);
  
      // Draw the selected option
      if selected_index >= 0 && selected_index < options.length {
        text_x := rect.x + (rect.width - MeasureText(options[selected_index].data, style.font_size)) / 2;
        text_y := rect.y + (rect.height - style.font_size) / 2;
        DrawText(options[selected_index].data, (int)text_x, (int)text_y, style.font_size, style.foreground);
      }
  
      hit := CheckCollisionPointRec(GetMousePosition(), rect);
      if hit && IsMouseButtonPressed(MouseButton.Left) {
        is_open = !is_open;
        if is_open && on_open {
          on_open();
        }
      }
  
      hit_option := false;
      if is_open {
        option_rect := rect;
        option_rect.y += rect.height;
        for i in 0..options.length {
          option_color := style.background;
          if CheckCollisionPointRec(GetMousePosition(), option_rect) {
            option_color = style.highlighted;
            hit_option = true;
          }
          DrawRectangleV(Vector2{option_rect.x, option_rect.y}, Vector2{option_rect.width, option_rect.height}, option_color);
          text_x := option_rect.x + (option_rect.width - MeasureText(options[i].data, style.font_size)) / 2;
          text_y := option_rect.y + (option_rect.height - style.font_size) / 2;
          DrawText(options[i].data, (int)text_x, (int)text_y, style.font_size, style.foreground);
  
          if CheckCollisionPointRec(GetMousePosition(), option_rect) && IsMouseButtonPressed(MouseButton.Left) {
            selected_index = i;
            is_open = false;
            if on_selected {
              on_selected(i);
            }
          }
          option_rect.y += option_rect.height;
        }
      }
      
      if !hit && !hit_option {
        is_open = false;
      }
  }
}