
#import _raybindings;

#c_flags " -lraylib "

impl Rectangle {
  to_string :: fn(self*) -> string {
    return $"Rectangle(x: {self.x}, y: {self.y}, width: {self.width}, height: {self.height})";
  }
}

impl Vector2 {
  to_string :: fn(self*) -> string {
    return $"Vector2(x: {self.x}, y: {self.y})";
  }
  zero :: fn() -> #self {
    return { x: 0.0, y: 0.0 };
  }

  one :: fn() -> #self {
    return { x: 1.0, y: 1.0 };
  }

  scalar :: fn(value: float32) -> #self {
    return { x: value, y: value };
  }

  add :: fn(self, other: #self) -> #self {
    return { x: self.x + other.x, y: self.y + other.y };
  }

  sub :: fn(self, other: #self) -> #self {
    return { x: self.x - other.x, y: self.y - other.y };
  }

  mul :: fn(self, scalar: float32) -> #self {
    return { x: self.x * scalar, y: self.y * scalar };
  }

  div :: fn(self, scalar: float32) -> #self {
    return { x: self.x / scalar, y: self.y / scalar };
  }

  length :: fn(self) -> float32 {
    return sqrt(self.x * self.x + self.y * self.y) as float32;
  }

  length_sqr :: fn(self) -> float32 {
    return self.x * self.x + self.y * self.y;
  }

  normalize :: fn(self) -> #self {
    len := self.length();
    return { x: self.x / len, y: self.y / len };
  }

  dot :: fn(self, other: #self) -> float32 {
    return self.x * other.x + self.y * other.y;
  }

  scale :: fn(self, scalar: float32) -> #self {
    return { x: self.x * scalar, y: self.y * scalar };
  }

  equals :: fn(self, other: #self) -> bool {
    return self.x == other.x && self.y == other.y;
  }

  distance :: fn(self, other: #self) -> float32 {
    return sqrt((self.x - other.x) * (self.x - other.x) + (self.y - other.y) * (self.y - other.y)) as float32;
  }
}

impl Vector3 {
  to_string :: fn(self*) -> string {
    return $"Vector3(x: {self.x}, y: {self.y}, z: {self.z})";
  }
  zero :: fn() -> #self {
    return { x: 0.0, y: 0.0, z: 0.0 };
  }

  one :: fn() -> #self {
    return { x: 1.0, y: 1.0, z: 1.0 };
  }

  scalar :: fn(value: float32) -> #self {
    return { x: value, y: value, z: value };
  }

  add :: fn(self, other: #self) -> #self {
    return { x: self.x + other.x, y: self.y + other.y, z: self.z + other.z };
  }

  sub :: fn(self, other: #self) -> #self {
    return { x: self.x - other.x, y: self.y - other.y, z: self.z - other.z };
  }

  mul :: fn(self, scalar: float32) -> #self {
    return { x: self.x * scalar, y: self.y * scalar, z: self.z * scalar };
  }

  div :: fn(self, scalar: float32) -> #self {
    return { x: self.x / scalar, y: self.y / scalar, z: self.z / scalar };
  }

  length :: fn(self) -> float32 {
    return sqrt(self.x * self.x + self.y * self.y + self.z * self.z) as float32;
  }

  length_sqr :: fn(self) -> float32 {
    return self.x * self.x + self.y * self.y + self.z * self.z;
  }


  normalize :: fn(self) -> #self {
    len := self.length();
    return { x: self.x / len, y: self.y / len, z: self.z / len };
  }

  dot :: fn(self, other: #self) -> float32 {
    return self.x * other.x + self.y * other.y + self.z * other.z;
  }

  cross :: fn(self, other: #self) -> #self {
    return {
      x: self.y * other.z - self.z * other.y,
      y: self.z * other.x - self.x * other.z,
      z: self.x * other.y - self.y * other.x
    };
  }

  scale :: fn(self, scalar: float32) -> #self {
    return { x: self.x * scalar, y: self.y * scalar, z: self.z * scalar };
  }

  equals :: fn(self, other: #self) -> bool {
    return self.x == other.x && self.y == other.y && self.z == other.z;
  }

  distance :: fn(self, other: #self) -> float32 {
    return sqrt((self.x - other.x) * (self.x - other.x) + (self.y - other.y) * (self.y - other.y) + (self.z - other.z) * (self.z - other.z)) as float32;
  }
}

impl Vector4 {
  to_string :: fn(self*) -> string {
    return $"Vector4(x: {self.x}, y: {self.y}, z: {self.z}, w: {self.w})";
  }

  zero :: fn() -> #self {
    return { x: 0.0, y: 0.0, z: 0.0, w: 0.0 };
  }

  one :: fn() -> #self {
    return { x: 1.0, y: 1.0, z: 1.0, w: 1.0 };
  }

  scalar :: fn(value: float32) -> #self {
    return { x: value, y: value, z: value, w: value };
  }

  add :: fn(self, other: #self) -> #self {
    return { x: self.x + other.x, y: self.y + other.y, z: self.z + other.z, w: self.w + other.w };
  }

  sub :: fn(self, other: #self) -> #self {
    return { x: self.x - other.x, y: self.y - other.y, z: self.z - other.z, w: self.w - other.w };
  }

  mul :: fn(self, scalar: float32) -> #self {
    return { x: self.x * scalar, y: self.y * scalar, z: self.z * scalar, w: self.w * scalar };
  }

  div :: fn(self, scalar: float32) -> #self {
    return { x: self.x / scalar, y: self.y / scalar, z: self.z / scalar, w: self.w / scalar };
  }

  length :: fn(self) -> float32 {
    return sqrt(self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w) as float32;
  }

  length_sqr :: fn(self) -> float32 {
    return self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w;
  }

  normalize :: fn(self) -> #self {
    len := self.length();
    return { x: self.x / len, y: self.y / len, z: self.z / len, w: self.w / len };
  }

  dot :: fn(self, other: #self) -> float32 {
    return self.x * other.x + self.y * other.y + self.z * other.z + self.w * other.w;
  }

  scale :: fn(self, scalar: float32) -> #self {
    return { x: self.x * scalar, y: self.y * scalar, z: self.z * scalar, w: self.w * scalar };
  }

  equals :: fn(self, other: #self) -> bool {
    return self.x == other.x && self.y == other.y && self.z == other.z && self.w == other.w;
  }

  distance :: fn(self, other: #self) -> float32 {
    return sqrt((self.x - other.x) * (self.x - other.x) + (self.y - other.y) * (self.y - other.y) + (self.z - other.z) * (self.z - other.z) + (self.w - other.w) * (self.w - other.w)) as float32;
  }
}

impl Color {
  random :: fn(max: u8) -> #self {
    return {
      r: GetRandomValue(0, max) as u8,
      g: GetRandomValue(0, max) as u8,
      b: GetRandomValue(0, max) as u8,
      a: 255 as u8,
    };
  }

}