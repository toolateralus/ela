#compiler_flags "-lraylib -lm"
#import core;

Key :: enum {
  Null            = 0,  
  Apostrophe      = 39, 
  Comma           = 44, 
  Minus           = 45, 
  Period          = 46, 
  Slash           = 47, 
  Zero            = 48, 
  One             = 49, 
  Two             = 50, 
  Three           = 51, 
  Four            = 52, 
  Five            = 53, 
  Six             = 54, 
  Seven           = 55, 
  Eight           = 56, 
  Nine            = 57, 
  Semicolon       = 59, 
  Equal           = 61, 
  A               = 65, 
  B               = 66, 
  C               = 67, 
  D               = 68, 
  E               = 69, 
  F               = 70, 
  G               = 71, 
  H               = 72, 
  I               = 73, 
  J               = 74, 
  K               = 75, 
  L               = 76, 
  M               = 77, 
  N               = 78, 
  O               = 79, 
  P               = 80, 
  Q               = 81, 
  R               = 82, 
  S               = 83, 
  T               = 84, 
  U               = 85, 
  V               = 86, 
  W               = 87, 
  X               = 88, 
  Y               = 89, 
  Z               = 90, 
  LeftBracket    = 91, 
  Backslash       = 92, 
  RightBracket   = 93, 
  Grave           = 96, 
  Space           = 32, 
  Escape          = 256,
  Enter           = 257,
  Tab             = 258,
  Backspace       = 259,
  Insert          = 260,
  Delete          = 261,
  Right           = 262,
  Left            = 263,
  Down            = 264,
  Up              = 265,
  PageUp         = 266,
  PageDown       = 267,
  Home            = 268,
  End             = 269,
  CapsLock       = 280,
  ScrollLock     = 281,
  NumLock        = 282,
  PrintScreen    = 283,
  Pause           = 284,
  F1              = 290,
  F2              = 291,
  F3              = 292,
  F4              = 293,
  F5              = 294,
  F6              = 295,
  F7              = 296,
  F8              = 297,
  F9              = 298,
  F10             = 299,
  F11             = 300,
  F12             = 301,
  LeftShift      = 340,
  LeftControl    = 341,
  LeftAlt        = 342,
  LeftSuper      = 343,
  RightShift     = 344,
  RightControl   = 345,
  RightAlt       = 346,
  RightSuper     = 347,
  Kb_menu         = 348,
  Keypad0            = 320,
  Keypad1            = 321,
  Keypad2            = 322,
  Keypad3            = 323,
  Keypad4            = 324,
  Keypad5            = 325,
  Keypad6            = 326,
  Keypad7            = 327,
  Keypad8            = 328,
  Keypad9            = 329,
  KpDecimal      = 330,
  KpDivide       = 331,
  KpMultiply     = 332,
  KpSubtract     = 333,
  KpAdd          = 334,
  KpEnter        = 335,
  KpEqual        = 336,
  Back            = 4,  
  Menu            = 5,  
  VolumeUp       = 24, 
  VolumeDown     = 25  
}

MouseButton :: enum {
  Left = 0,
  Right = 1,
  Middle = 2,
  Side = 3,
  Extra = 4,
  Forward = 5,
  Back = 6
}

Color :: struct {
  r: u8;
  g: u8;
  b: u8;
  a: u8;
  
  to_string :: () -> string {
    return $"r: {r}, g: {g}, b: {b}, a: {a}";
  }
  
  #operator(==) :: (other: #self) -> bool {
    return other.a == a && other.r == r && other.g == g && other.b == b;
  }
}

Texture2D :: struct {
  id: int;
  width: int;
  height: int;
  mipmaps: int;
  format: int;
}

Vector2 :: struct {
  x: float;
  y: float;

  #operator(+) :: (other: #self) -> #self {
    return #make(#self, { x + other.x, y + other.y });
  }

  #operator(-) :: (other: #self) -> #self {
    return #make(#self, {x - other.x, y - other.y });
  }

  #operator(*) :: (scalar: float) -> #self {
    return #make(#self, {x * scalar, y * scalar });
  }

  #operator(/) :: (scalar: float) -> #self {
    return #make(#self, {x / scalar, y / scalar });
  }

  #operator(+=) :: (other: #self) -> #self {
    x += other.x;
    y += other.y;
    return *this;
  }

  #operator(-=) :: (other: #self) -> #self {
    x -= other.x;
    y -= other.y;
    return *this;
  }

  #operator(*=) :: (scalar: float) -> #self {
    x *= scalar;
    y *= scalar;
    return *this;
  }

  #operator(/=) :: (scalar: float) -> #self {
    x /= scalar;
    y /= scalar;
    return *this;
  }
  
  to_string :: () -> string {
    return $"x: {x}, y: {y}"
  }
}

Vector3 :: struct {
  x: float;
  y: float;
  z: float;
  
  #operator(+) :: (other: Vector3) -> Vector3 {
    return #make(#self, {x + other.x, y + other.y, z + other.z });
  }

  #operator(-) :: (other: Vector3) -> Vector3 {
    return #make(#self, {x - other.x, y - other.y, z - other.z });
  }

  #operator(*) :: (scalar: float) -> Vector3 {
    return #make(#self, {x * scalar, y * scalar, z * scalar });
  }

  #operator(/) :: (scalar: float) -> Vector3 {
    return #make(#self, {x / scalar, y / scalar, z / scalar });
  }

  #operator(+=) :: (other: Vector3) -> Vector3 {
    x += other.x;
    y += other.y;
    z += other.z;
    return *this;
  }

  #operator(-=) :: (other: Vector3) -> Vector3 {
    x -= other.x;
    y -= other.y;
    z -= other.z;
    return *this;
  }

  #operator(*=) :: (scalar: float) -> Vector3 {
    x *= scalar;
    y *= scalar;
    z *= scalar;
    return *this;
  }

  #operator(/=) :: (scalar: float) -> Vector3 {
    x /= scalar;
    y /= scalar;
    z /= scalar;
    return *this;
  }
  
  to_string :: () -> string {
    return $"x: {x}, y: {y}, z: {z}"
  }
}


Rectangle :: struct {
  x: float;
  y: float;
  width: float;
  height: float;
  
  to_string :: () -> string {
    return $"x: {x}, y: {y}, width: {width}, height: {height}";
  }
}

// Opaque structs defined in C files in raudio.c;
rAudioBuffer :: struct;
rAudioProcessor :: struct;

AudioStream :: struct {
  buffer: rAudioBuffer*;
  processor: rAudioProcessor*;
  sampleRate: u32;
  sampleSize: u32;
  channels: u32;
}

Music :: struct {
  stream: AudioStream;
  frameCount: u32;
  looping: bool;
  ctxType: int;
  ctxData: void*;
}

Sound :: struct {
  stream: AudioStream;
  frameCount: u32;
} 

color_with_alpha :: (color: Color, alpha: u8) -> Color {
  color.a = alpha;
  return color;
}

color_lerp :: (a: Color, b: Color, t: float) -> Color {
  return #make(Color, {
    (u8)clamp(a.r + (b.r - a.r) * t, 0, 255),
    (u8)clamp(a.g + (b.g - a.g) * t, 0, 255),
    (u8)clamp(a.b + (b.b - a.b) * t, 0, 255),
    (u8)clamp(a.a + (b.a - a.a) * t, 0, 255)
  });
}

CLEAR: Color;
WHITE: Color = { (u8)255, (u8)255, (u8)255, (u8)255 };
BLACK: Color = { (u8)0, (u8)0, (u8)0, (u8)255 };
RED: Color = { (u8)255, (u8)0, (u8)0, (u8)255 };
GREEN: Color = { (u8)0, (u8)255, (u8)0, (u8)255 };
BLUE: Color = { (u8)0, (u8)0, (u8)255, (u8)255 };
YELLOW: Color = { (u8)255, (u8)255, (u8)0, (u8)255 };
PURPLE: Color = { (u8)255, (u8)0, (u8)255, (u8)255 };
ORANGE: Color = { (u8)255, (u8)165, (u8)0, (u8)255 };
GRAY: Color = { (u8)128, (u8)128, (u8)128, (u8)255 };
DARKGRAY: Color = { (u8)80, (u8)80, (u8)80, (u8)255 };
LIGHTGRAY: Color = { (u8)200, (u8)200, (u8)200, (u8)255 };
BROWN: Color = { (u8)165, (u8)42, (u8)42, (u8)255 };
PINK: Color = { (u8)255, (u8)192, (u8)203, (u8)255 };
LIME: Color = { (u8)0, (u8)255, (u8)0, (u8)255 };
DARKGREEN: Color = { (u8)0, (u8)100, (u8)0, (u8)255 };
SKYBLUE: Color = { (u8)135, (u8)206, (u8)235, (u8)255 };
VIOLET: Color = { (u8)238, (u8)130, (u8)238, (u8)255 };
GOLD: Color = { (u8)255, (u8)215, (u8)0, (u8)255 };
BEIGE: Color = { (u8)245, (u8)245, (u8)220, (u8)255 };
MAGENTA: Color = { (u8)255, (u8)0, (u8)255, (u8)255 };
MAROON: Color = { (u8)128, (u8)0, (u8)0, (u8)255 };
DARKBLUE: Color = { (u8)0, (u8)0, (u8)139, (u8)255 };
DARKPURPLE: Color = { (u8)139, (u8)0, (u8)139, (u8)255 };
DARKBROWN: Color = { (u8)101, (u8)67, (u8)33, (u8)255 };
CYAN: Color = { (u8)0, (u8)255, (u8)255, (u8)255 };
DARKCYAN: Color = { (u8)0, (u8)139, (u8)139, (u8)255 };
LIGHTCYAN: Color = { (u8)224, (u8)255, (u8)255, (u8)255 };

#foreign InitTimer :: () -> void;
#foreign GetTime :: () -> float64;

#foreign Vector2Equals :: (v1: Vector2, v2) -> bool;
#foreign Vector2Clamp :: (v: Vector2, a, b) -> bool;
#foreign Vector2Add :: (v1: Vector2, v2) -> Vector2;
#foreign Vector2Subtract :: (v1: Vector2, v2) -> Vector2;
#foreign Vector2Scale :: (v: Vector2, scale: float) -> Vector2;
#foreign Vector2Length :: (v: Vector2) -> float;
#foreign Vector2LengthSqr :: (v: Vector2) -> float;
#foreign Vector2DotProduct :: (v1: Vector2, v2) -> float;
#foreign Vector2Distance :: (v1: Vector2, v2) -> float;
#foreign Vector2Angle :: (v1: Vector2, v2) -> float;
#foreign Vector2Normalize :: (v: Vector2) -> Vector2;


#foreign CheckCollisionRecs :: (rec1: Rectangle, rec2: Rectangle) -> bool;
#foreign CheckCollisionCircles :: (center1: Vector2, radius1: float, center2: Vector2, radius2: float) -> bool;
#foreign CheckCollisionCircleRec :: (center: Vector2, radius: float, rec: Rectangle) -> bool;
#foreign CheckCollisionPointRec :: (point: Vector2, rec: Rectangle) -> bool;
#foreign CheckCollisionPointCircle :: (point: Vector2, center: Vector2, radius: float) -> bool;
#foreign CheckCollisionPointTriangle :: (point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2) -> bool;


#foreign GetKeyPressed :: () -> int;
#foreign GetScreenWidth :: () -> int;
#foreign GetScreenHeight :: () -> int;

#foreign GetMouseX :: () -> int;
#foreign GetMouseY :: () -> int;
#foreign GetMousePosition :: () -> Vector2;
#foreign IsMouseButtonPressed :: (button: int) -> bool;
#foreign IsMouseButtonDown :: (button: int) -> bool;
#foreign IsMouseButtonReleased :: (button: int) -> bool;
#foreign IsMouseButtonUp :: (button: int) -> bool;

#foreign InitWindow :: (width: int, height: int, title: char*) -> void;
#foreign WindowShouldClose :: () -> bool;
#foreign CloseWindow :: () -> void;
#foreign BeginDrawing :: () -> void;
#foreign EndDrawing :: () -> void;
#foreign ClearBackground :: (color: Color) -> void;
#foreign DrawText :: (text: char*, posX: int, posY: int, fontSize: int, color: Color) -> void;
#foreign IsKeyPressed :: (key: int) -> bool;
#foreign IsKeyDown :: (key: int) -> bool;
#foreign IsKeyReleased :: (key: int) -> bool;
#foreign SetTargetFPS :: (fps: int) -> void;
#foreign DrawFPS :: (posX: int, posY: int) -> void;
#foreign GetFPS :: () -> int;
#foreign DrawLine :: (startPosX: int, startPosY, endPosX, endPosY, color: Color) -> void;
#foreign DrawCircle :: (centerX: int, centerY, radius: float, color: Color) -> void;
#foreign DrawRectangle :: (posX: int, posY, width, height, color: Color) -> void;
#foreign DrawTriangle :: (v1X: int, v1Y, v2X, v2Y, v3X, v3Y, color: Color) -> void;
#foreign DrawPoly :: (centerX: int, centerY: int, sides: int, radius: float, rotation: float, color: Color) -> void;
#foreign LoadTexture :: (fileName: char*) -> Texture2D;
#foreign UnloadTexture :: (texture: Texture2D) -> void;
#foreign DrawTexture :: (texture: Texture2D, posX: int, posY: int, tint: Color) -> void;
#foreign DrawTextureEx :: (texture: Texture2D, position: Vector2, rotation: float, scale: float, tint: Color) -> void;
#foreign DrawTextureRec :: (texture: Texture2D, sourceRec: Rectangle, position: Vector2, tint: Color) -> void;
#foreign DrawTexturePro :: (texture: Texture2D, sourceRec: Rectangle, destRec: Rectangle, origin: Vector2, rotation: float, tint: Color) -> void;
#foreign DrawRectangleV :: (position: Vector2, size: Vector2, color: Color) -> void;

#foreign LoadSound :: (fileName: char*) -> Sound;
#foreign UnloadSound :: (sound: Sound) -> void;
#foreign PlaySound :: (sound: Sound) -> void;
#foreign StopSound :: (sound: Sound) -> void;
#foreign PauseSound :: (sound: Sound) -> void;
#foreign ResumeSound :: (sound: Sound) -> void;
#foreign LoadMusicStream :: (fileName: char*) -> Music;
#foreign UnloadMusicStream :: (music: Music) -> void;
#foreign PlayMusicStream :: (music: Music) -> void;
#foreign UpdateMusicStream :: (music: Music) -> void;
#foreign StopMusicStream :: (music: Music) -> void;
#foreign PauseMusicStream :: (music: Music) -> void;
#foreign ResumeMusicStream :: (music: Music) -> void;
#foreign SetMusicVolume :: (music: Music, volume: float);
#foreign SetSoundVolume :: (sound: Sound, volume: float);
#foreign IsMusicStreamPlaying :: (music: Music) -> bool;
#foreign SetAudioStreamPitch :: (music: Music, pitch: float);
#foreign InitAudioDevice :: () -> void;
#foreign CloseAudioDevice :: () -> void;
#foreign IsAudioDeviceReady :: () -> bool;
#foreign SetMasterVolume :: (volume: float) -> void;
#foreign ColorAlphaBlend:: (dst: Color, src, tint) -> Color;
#foreign SetExitKey :: (key :int);

#foreign MeasureText :: (text: char*, fontSize: int) -> int;


Camera :: struct {
    position:     Vector3;
    target:       Vector3;
    up:           Vector3;
    fovy:         float;
    projection:   int;
} 

Camera2D :: struct {
  offset:         Vector2;
  target:         Vector2;
  rotation:       float;
  zoom:           float = 1.0;
}

CameraMode :: enum {
  Custom        = 0,
  Free          = 1,
  Orbital       = 2,
  FirstPerson   = 3,
  ThirdPerson   = 4
}

ConfigFlags :: enum {
  FullscreenMode        = 0x00000002, // 1 << 1
  WindowResizable       = 0x00000004, // 1 << 2
  WindowUndecorated     = 0x00000008, // 1 << 3
  WindowTransparent     = 0x00000010, // 1 << 4
  Msaa4xHint            = 0x00000020, // 1 << 5
  VsyncHint             = 0x00000040, // 1 << 6
  WindowHidden          = 0x00000080, // 1 << 7
  WindowAlwaysRun       = 0x00000100, // 1 << 8
  WindowMinimized       = 0x00000200, // 1 << 9
  WindowMaximized       = 0x00000400, // 1 << 10
  WindowUnfocused       = 0x00000800, // 1 << 11
  WindowTopmost         = 0x00001000, // 1 << 12
  WindowHighdpi         = 0x00002000, // 1 << 13
  WindowMousePassthrough = 0x00004000, // 1 << 14
  BorderlessWindowedMode = 0x00008000, // 1 << 15
  InterlacedHint        = 0x00010000  // 1 << 16
}

#foreign SetCameraMode :: (camera: Camera2D, mode: int) -> void;
#foreign UpdateCamera :: (camera: Camera2D*) -> void;
#foreign BeginMode2D :: (camera: Camera2D) -> void;
#foreign EndMode2D :: () -> void;

#foreign GetWorldToScreen :: (position: Vector3, camera: Camera) -> Vector2;
#foreign GetWorldToScreenEx :: (position: Vector3, camera: Camera, width: int, height: int) -> Vector2;
#foreign GetWorldToScreen2D :: (position: Vector2, camera: Camera2D) -> Vector2;
#foreign GetScreenToWorld2D :: (position: Vector2, camera: Camera2D) -> Vector2;

#foreign IsWindowResized :: () -> bool;      

#foreign SetWindowState :: (flags: int) -> void;


#foreign BeginScissorMode :: (x: int, y, w, h);
#foreign EndScissorMode :: ();
#foreign Fade :: (color: Color, alpha: float) -> Color;
#foreign ColorFromHSV :: (hue: float, saturation, value) -> Color;