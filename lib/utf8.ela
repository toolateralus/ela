UTF8_ERROR : u32 = 0xFFFD;

utf8_get_sequence_length :: fn(first: u8) -> s8 {
  if first & 0x80 == 0 {
    return 1;
  } else if first & 0xE0 == 0xC0 {
    return 2;
  } else if first & 0xF0 == 0xE0 {
    return 3;
  } else if first & 0xF8 == 0xF0 {
    return 4;
  } else {
    return -1;
  }
}


utf8_decode_sequence :: fn(bytes: Slice![u8]) -> (u32, s8) {
  assert_neq![u64]("utf8_decode_sequence(): slice was empty", bytes.length, 0);
  if (0x80..0xBF).contains(bytes[0] as u32) then return (UTF8_ERROR, 1);
  
  sequence_length := utf8_get_sequence_length(bytes.data[0]);

  assert("utf8_decode_sequence(): bad sequence length", bytes.length >= sequence_length);

  if sequence_length == -1
    then return (UTF8_ERROR, 1);
    
  if sequence_length == 1
    then return (bytes.data[0] as u32, 1);

  // overlong encoding, could be represented by less bytes.
  if bytes[0] == 0xE0 && bytes[1] < 0xA0 
    then return (UTF8_ERROR, 1);
  
  if bytes[0] == 0xF0 && bytes[1] < 0x90
    then return (UTF8_ERROR, 1);

  // too high of a product value.
  if bytes[0] == 0xF4 && bytes[1] >= 0x90
    then return (UTF8_ERROR, 1)
  

  for idx in 0..sequence_length {
    if idx != 0 {
      // non-continuation byte after a continuation byte.
      if (0x80..0xBF).contains(bytes[idx as u32]) == false {
        return (UTF8_ERROR, 1);
      }
    }
    
    // disallowed values.
    switch bytes[idx as u32] as s32 {
      0xC0: { return (UTF8_ERROR, 1); }
      0xC1: { return (UTF8_ERROR, 1); }
    }
    
    if (0xF5 .. 0xFF).contains(bytes[idx as u32]) then return (UTF8_ERROR, 1);
  }

  ch: u32;

  switch sequence_length as s32 {
    2: {
      ch = (bytes[0] & 0x1F) << 6 | bytes[1] & 0x3F;
    }
    3: {
      ch = (bytes[0] & 0x0F) << 12 | (bytes[1] & 0x3F) << 6 | bytes[2] & 0x3F;
    }
    4: {
      ch = (bytes[0] & 0x07)   << 18 |
             (bytes[1] & 0x3F) << 12 |
             (bytes[2] & 0x3F) << 6  |
             (bytes[3] & 0x3F);
    }
  }
 
  return (ch, sequence_length);   
}

utf8_decode :: fn![T](data: T) -> u32[] where T is As_Char_Slice {
  slice := data.as_char_slice();
  idx := 0;
  output: u32[];
  while idx < slice.length {
    subslice := slice.slice(idx, idx + 4);
    ch, advance := utf8_decode_sequence(subslice);
    output.push(ch);
    idx += advance;
  }
}
