#foreign system :: fn(cmd: c_string) -> int;

#foreign free :: fn(ptr: void*) -> void;
#foreign malloc :: fn(nbytes: u64) -> void*;
#foreign calloc :: fn(num: u64, size: u64) -> void*;
#foreign realloc :: fn(ptr: void*, size: u64) -> void*;

#foreign memcpy :: fn(dest: void*, src: void*, n: u64) -> void*;
#foreign memset :: fn(dest: void*, c: int, n: u64) -> void*;
#foreign memmove :: fn(dest: void*, src: void*, nbytes: s64) -> int;

#foreign printf :: fn(format: c_string, ...) -> int;
#foreign exit :: fn(code: int);

#static print :: fn![T](str: T) {
  printf("%s", $"{str}".data);
}

#static println :: fn![T](str: T) {
  printf("%s\n", $"{str}".data);
}

#static panic :: fn(msg: string) {
  println(msg);
  exit(1);
}

#foreign scanf :: fn(format: c_string, ...) -> int;
#foreign getchar :: fn() -> int;

#foreign sleep :: fn(seconds: int);
#foreign usleep :: fn(c: int);


#foreign strdup :: fn(str: c_string) -> c_string;
#foreign strndup :: fn(str: c_string, n: u64) -> c_string;
#foreign strerror :: fn(errnum: int) -> c_string;
#foreign strtol :: fn(str: c_string, endptr: c_string**, base: int) -> s64;
#foreign strtoul :: fn(str: c_string, endptr: c_string**, base: int) -> u64;
#foreign strtod :: fn(str: c_string, endptr: c_string**) -> float64;
#foreign strtok :: fn(str: c_string, delim: c_string) -> c_string;
#foreign strchr :: fn(str: c_string, c: int) -> c_string;
#foreign strrchr :: fn(str: c_string, c: int) -> c_string;
#foreign strstr :: fn(haystack: c_string, needle: c_string) -> c_string;
#foreign strlen :: fn(str: c_string) -> int;
#foreign strcmp :: fn(str1: c_string, str2: c_string) -> int;
#foreign strcat :: fn(dest: c_string, src: c_string) -> c_string;
#foreign snprintf :: fn(buffer: u8*, buffer_size: u64, format: c_string, ...) -> int;
#foreign sprintf :: fn(buffer: u8*, format: c_string, ...) -> int;
#foreign strncmp :: fn(str: c_string, str2: c_string, len: int) -> int;

#foreign isalnum :: fn(c: int) -> int;
#foreign isalpha :: fn(c: int) -> int;
#foreign isspace :: fn(c: int) -> int;
#foreign isdigit :: fn(c: int) -> int;
#foreign islower :: fn(c: int) -> int;
#foreign isupper :: fn(c: int) -> int;
#foreign isprint :: fn(c: int) -> int;
#foreign ispunct :: fn(c: int) -> int;

#foreign atoi :: fn(v: c_string) -> int;
#foreign atof :: fn(v: c_string) -> float64;

#foreign rand :: fn() -> int;
#foreign srand :: fn(seed: u32);

Random :: struct {
  Max :: 2147483647; // !BUG: can't use constants for structs. Emitting it is just empty
}

impl Random {
  next :: fn(max: float32) -> float {
    return (rand() as float) / (2147483647 as float) * max;
  }
}

impl string {
  empty :: fn() -> #self {
    return {};
  }

  from :: fn(data: c_string) -> #self{
    len := strlen(data);
    str: string;
    str.data = strdup(data);
    str.length = len;
    return str;
  }

  from_ptr :: fn(begin: c_string, end: c_string) -> string {
    str: string;
    str.length = end - begin;
    str.data = malloc(str.length + 1);
    memcpy(str.data, begin, str.length);
    str.data[str.length] = 0;
    return str;
  }

  insert :: fn(self*, pos: s64, substr: string) {
    if pos < 0 || pos > self.length {
      return;
    }
    new_data: c_string = malloc(self.length + substr.length + 1);
    memcpy(new_data, self.data, pos);
    memcpy(new_data + pos, substr.data, substr.length);
    memcpy(new_data + pos + substr.length, self.data + pos, self.length - pos);
    new_data[self.length + substr.length] = 0;

    self.data = new_data;
    self.length += substr.length;
  }

  starts_with :: fn(self*, substr: string) -> bool {
    if self.data == null || substr.data == null
      then return false;

    str_len: int = self.length;
    substr_len: int = substr.length;

    if str_len < substr_len
      then return false;

    if str_len == substr_len && strcmp(self.data, substr.data) == 0
      then return true;

    return strncmp(self.data, substr.data, substr_len) == 0;
  }

  ends_with :: fn(self*, pattern: string) -> bool {
    if !self.data || !pattern.data
      then return false;
    len: int = self.length;
    patlen: int = pattern.length;
    if len < patlen
      then return false;
    return strncmp(self.data + (len - patlen), pattern.data, patlen) == 0;
  }

  // TODO: fix me, something is super messed up. with type checking the implicit self/self* argument,
  // TODO: we basicaly just assume if it's missing one argument it has self.
  replace :: fn(self*, pattern: string, replacement: string) -> string {
    if !self.data || !pattern.data || !replacement.data
      then return *self;

    result: string;
    str_len := self.length;
    pattern_len := pattern.length;
    replacement_len := replacement.length;

    i: int;
    while i < str_len {
      if strncmp(self.data + i, pattern.data, pattern_len) == 0 {
        result.insert(result.length, replacement);
        i += pattern_len;
      } else {
        result.insert(result.length, string::from_ptr(self.data + i, self.data + i + 1));
        i += 1;
      }
    }

    return result;
  }

  substr :: fn(self*, start: int, end: int) -> string {
    if self.length == 0
      then return {};

    len: int = self.length;

    if start > end
      then return {};

    if len < end - start
      then return {};

    dest: c_string = malloc(sizeof(char) * (end - start) + 1);
    memcpy(dest, self.data + start, end - start);
    dest[end - start] = 0;

    return string::from_ptr(dest, dest + (end - start));
  }

  split :: fn(self*, delimiter: char) -> string[] {
    if !self.data then return {};
    result: string[];
    start: int = 0;
    str_len: int = self.length;
    for i in 0..str_len {
      if self.data[i] == delimiter {
        if i > start then result ~= string::from_ptr(self.data + start, self.data + i);
        start = i + 1;
      }
    }
    result ~= string::from_ptr(self.data + start, self.data + str_len);
    return result;
  }

  contains :: fn(self*, pattern: string) -> bool {
    if self.data == null || pattern.data == null
      then return false;

    str_len: int = self.length;
    pattern_len: int = pattern.length;

    if str_len < pattern_len
      then return false;

    for i in 0..(str_len - pattern_len + 1) {
      if strncmp(self.data + i, pattern.data, pattern_len) == 0 {
        return true;
      }
    }
    return false;
  }
}


to_string :: fn(num: s64) -> string {
  switch num {
    0: { return string::from("0"); }
    1: { return string::from("1"); }
    2: { return string::from("2"); }
    3: { return string::from("3"); }
    4: { return string::from("4"); }
    5: { return string::from("5"); }
    6: { return string::from("6"); }
    7: { return string::from("7"); }
    8: { return string::from("8"); }
    9: { return string::from("9"); }
  }

  negative := false;
  if num < 0 {
    negative = true;
    num = -num;
  }

  buffer: char[20];
  index: int = 0;

  while num > 0 {
    buffer[index] = '0' + (num % 10);
    num /= 10;
    index++;
  }

  if negative {
    buffer[index] = '-';
    index++;
  }

  // Reverse the buffer
  for i in 0..(index / 2) {
    temp := buffer[i];
    buffer[i] = buffer[index - i - 1];
    buffer[index - i - 1] = temp;
  }

  return string::from_ptr(buffer as c_string, (buffer as c_string) + index);


}

#foreign fmod :: fn(l: float, r: float) -> float;
#foreign fabs :: fn(f: float64) -> float64;
#foreign isinf :: fn(arg: float64) -> bool;
#foreign isnan :: fn(arg: float64) -> bool;

#foreign pow :: fn(base: float64, exponent: float64) -> float64;
#foreign sqrt :: fn(f: float64) -> float64;
#foreign cos :: fn(f: float64) -> float64;
#foreign sin :: fn(f: float64) -> float64;


abs :: fn![T](v: T) -> T {
  if v < 0 {
    return -v;
  }
  return v;
}


min :: fn![T](a: T, b: T) -> T {
  if a > b then return b;
  return a;
}

max :: fn![T](a: T, b: T) -> T {
  if a > b then return a;
  return b;
}

clamp :: fn(v: float64, min, max) -> float64 {
  if v < min then return min;
  if v > max then return max;
  return v;
}

lerp :: fn(a: float, b, t) -> float {
  return (a * (1.0 - t)) + (b * t);
}

#foreign time :: fn(value: void*) -> int;
timespec_t :: struct {
  tv_sec: s64;
  tv_nsec: s64;
}

#foreign clock_gettime :: fn(clock_id: int, tp: timespec_t*) -> int;

tm_t :: struct {
  tm_sec: int;
  tm_min: int;
  tm_hour: int;
  tm_mday: int;
  tm_mon: int;
  tm_year: int;
  tm_wday: int;
  tm_yday: int;
  tm_isdst: int;
}

#foreign localtime_r :: fn(timep: s64*, result: tm_t*) -> tm_t*;

Timing :: struct;

impl Timing {
  // returns the timespec_t for the current time since epoch.
  get_timespec_since_epoch :: fn() -> timespec_t {
    ts: timespec_t;
    clock_gettime(0, &ts);
    return ts;
  }
  
  // returns a seconds value representing time since epoch
  seconds :: fn() -> float64 {
    ts := #self::get_timespec_since_epoch();
    return (ts.tv_sec as float64) + (ts.tv_nsec as float64) / (1_000_000_000.0 as float64);
  }

  // returns a milliseconds value representing time since epoch
  milliseconds :: fn() -> float64 {
    ts := #self::get_timespec_since_epoch();
    return (ts.tv_sec as float64) * 1_000.0 + (ts.tv_nsec as float64) / 1_000_000.0 as float64;
  }

  // returns a microseconds value representing time since epoch
  microseconds :: fn() -> float64 {
    ts := #self::get_timespec_since_epoch();
    return (ts.tv_sec as float64) * 1_000_000.0 + (ts.tv_nsec as float64) / 1_000.0;
  }

  // returns a minutes value representing time since epoch
  minutes :: fn() -> float64 {
    ts := #self::get_timespec_since_epoch();
    return (ts.tv_sec as float64) / 60.0 + (ts.tv_nsec as float64) / (60.0 * 1_000_000_000.0);
  }

  // returns an hours value representing time since epoch
  hours :: fn() -> float64 {
    ts := #self::get_timespec_since_epoch();
    return (ts.tv_sec as float64) / 3_600.0 + (ts.tv_nsec as float64) / ((3_600.0 * 1_000_000_000.0) as float64);
  }

  // returns a days value representing time since epoch
  days :: fn() -> float64 {
    ts := #self::get_timespec_since_epoch();
    return (ts.tv_sec as float64) / 86_400.0 + (ts.tv_nsec as float64) / ((86_400.0 * 1_000_000_000.0) as float64)
  }

  date_time :: fn() -> string {
    ts := #self::get_timespec_since_epoch();
    time_t: s64 = ts.tv_sec;
    tm: tm_t;
    localtime_r(&time_t, &tm);
    buffer: char[64];
    snprintf(buffer, 64, "%04d-%02d-%02d %02d:%02d:%02d",
             tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
             tm.tm_hour, tm.tm_min, tm.tm_sec);
    return string::from_ptr(buffer as c_string, buffer as c_string + strlen(buffer));
  }
}
