#foreign system :: fn(cmd: c_string) -> int;

#foreign free :: fn(ptr: void*) -> void;
#foreign malloc :: fn(nbytes: u64) -> void*;
#foreign calloc :: fn(num: u64, size: u64) -> void*;
#foreign realloc :: fn(ptr: void*, size: u64) -> void*;

#foreign memcpy :: fn(dest: void*, src: void*, n: u64) -> void*;
#foreign memset :: fn(dest: void*, c: int, n: u64) -> void*;
#foreign memmove :: fn(dest: void*, src: void*, nbytes: s64) -> int;

#foreign printf :: fn(format: c_string, ...) -> int;
#foreign exit :: fn(code: int);

#static print :: fn![T](str: T) {
  printf("%s"c, $"{str}");
}

#static println :: fn![T](str: T) {
  printf("%s\n"c, $"{str}");
}

#static panic :: fn(msg: c_string) {
  println(msg);
  exit(1);
}

#foreign scanf :: fn(format: c_string, ...) -> int;
#foreign getchar :: fn() -> int;

#foreign sleep :: fn(seconds: int);
#foreign usleep :: fn(c: int);


#foreign strdup :: fn(str: c_string) -> c_string;
#foreign strndup :: fn(str: c_string, n: u64) -> c_string;
#foreign strerror :: fn(errnum: int) -> c_string;
#foreign strtol :: fn(str: c_string, endptr: c_string**, base: int) -> s64;
#foreign strtoul :: fn(str: c_string, endptr: c_string**, base: int) -> u64;
#foreign strtod :: fn(str: c_string, endptr: c_string**) -> float64;
#foreign strtok :: fn(str: c_string, delim: c_string) -> c_string;
#foreign strchr :: fn(str: c_string, c: int) -> c_string;
#foreign strrchr :: fn(str: c_string, c: int) -> c_string;
#foreign strstr :: fn(haystack: c_string, needle: c_string) -> c_string;
#foreign strlen :: fn(str: c_string) -> int;
#foreign strcmp :: fn(str1: c_string, str2: c_string) -> int;
#foreign strcat :: fn(dest: c_string, src: c_string) -> c_string;
#foreign snprintf :: fn(buffer: u8*, buffer_size: u64, format: c_string, ...) -> int;
#foreign sprintf :: fn(buffer: u8*, format: c_string, ...) -> int;
#foreign strncmp :: fn(str: c_string, str2: c_string, len: int) -> int;

#foreign isalnum :: fn(c: int) -> int;
#foreign isalpha :: fn(c: int) -> int;
#foreign isspace :: fn(c: int) -> int;
#foreign isdigit :: fn(c: int) -> int;
#foreign islower :: fn(c: int) -> int;
#foreign isupper :: fn(c: int) -> int;
#foreign isprint :: fn(c: int) -> int;
#foreign ispunct :: fn(c: int) -> int;

#foreign atoi :: fn(v: c_string) -> int;
#foreign atof :: fn(v: c_string) -> float64;

#foreign rand :: fn() -> int;
#foreign srand :: fn(seed: u32);

Random :: struct {
  Max :: 2147483647; // !BUG: can't use constants for structs. Emitting it is just empty
}

impl Random {
  next :: fn(max: float32) -> float {
    return (rand() as float) / (2147483647 as float) * max; // ! HACK:: replace this magic number with Random::Max when we fix that problen.
  }
}

// For now until we have a nice, builtin error handling system (likely like zig or odin)
// We just use tuples with c_strings for returning err/ok
#alias Error :: c_string;

to_string :: fn(num: s64) -> c_string {
  #static table : c_string[] = {
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"
  };

  if num < 10 then return table[num];

  negative := false;
  if num < 0 {
    negative = true;
    num = -num;
  }

  buffer: char[20];
  index: int = 0;

  while num > 0 {
    buffer[index] = '0' + (num % 10);
    num /= 10;
    index++;
  }

  if negative {
    buffer[index] = '-';
    index++;
  }

  // Reverse the buffer
  for i in 0..(index / 2) {
    temp := buffer[i];
    buffer[i] = buffer[index - i - 1];
    buffer[index - i - 1] = temp;
  }

  return c_string::from_ptr(buffer as c_string, (buffer as c_string) + index);


}

#foreign fmod :: fn(l: float, r: float) -> float;
#foreign fabs :: fn(f: float64) -> float64;
#foreign isinf :: fn(arg: float64) -> bool;
#foreign isnan :: fn(arg: float64) -> bool;

#foreign pow :: fn(base: float64, exponent: float64) -> float64;
#foreign sqrt :: fn(f: float64) -> float64;
#foreign cos :: fn(f: float64) -> float64;
#foreign sin :: fn(f: float64) -> float64;


abs :: fn![T](v: T) -> T {
  if v < 0 {
    return -v;
  }
  return v;
}


min :: fn![T](a: T, b: T) -> T {
  if a > b then return b;
  return a;
}

max :: fn![T](a: T, b: T) -> T {
  if a > b then return a;
  return b;
}

clamp :: fn(v: float64, min, max) -> float64 {
  if v < min then return min;
  if v > max then return max;
  return v;
}

lerp :: fn(a: float, b, t) -> float {
  return (a * (1.0 - t)) + (b * t);
}

#foreign time :: fn(value: void*) -> int;
timespec_t :: struct {
  tv_sec: s64;
  tv_nsec: s64;
}

#foreign clock_gettime :: fn(clock_id: int, tp: timespec_t*) -> int;

tm_t :: struct {
  tm_sec: int;
  tm_min: int;
  tm_hour: int;
  tm_mday: int;
  tm_mon: int;
  tm_year: int;
  tm_wday: int;
  tm_yday: int;
  tm_isdst: int;
}

#foreign localtime_r :: fn(timep: s64*, result: tm_t*) -> tm_t*;

Timing :: struct;

impl Timing {
  // returns the timespec_t for the current time since epoch.
  get_timespec_since_epoch :: fn() -> timespec_t {
    ts: timespec_t;
    clock_gettime(0, &ts);
    return ts;
  }
  
  // returns a seconds value representing time since epoch
  seconds :: fn() -> float64 {
    ts := #self::get_timespec_since_epoch();
    return (ts.tv_sec as float64) + (ts.tv_nsec as float64) / (1_000_000_000.0 as float64);
  }

  // returns a milliseconds value representing time since epoch
  milliseconds :: fn() -> float64 {
    ts := #self::get_timespec_since_epoch();
    return (ts.tv_sec as float64) * 1_000.0 + (ts.tv_nsec as float64) / 1_000_000.0 as float64;
  }

  // returns a microseconds value representing time since epoch
  microseconds :: fn() -> float64 {
    ts := #self::get_timespec_since_epoch();
    return (ts.tv_sec as float64) * 1_000_000.0 + (ts.tv_nsec as float64) / 1_000.0;
  }

  // returns a minutes value representing time since epoch
  minutes :: fn() -> float64 {
    ts := #self::get_timespec_since_epoch();
    return (ts.tv_sec as float64) / 60.0 + (ts.tv_nsec as float64) / (60.0 * 1_000_000_000.0);
  }

  // returns an hours value representing time since epoch
  hours :: fn() -> float64 {
    ts := #self::get_timespec_since_epoch();
    return (ts.tv_sec as float64) / 3_600.0 + (ts.tv_nsec as float64) / ((3_600.0 * 1_000_000_000.0) as float64);
  }

  // returns a days value representing time since epoch
  days :: fn() -> float64 {
    ts := #self::get_timespec_since_epoch();
    return (ts.tv_sec as float64) / 86_400.0 + (ts.tv_nsec as float64) / ((86_400.0 * 1_000_000_000.0) as float64)
  }

  date_time :: fn() -> c_string {
    ts := #self::get_timespec_since_epoch();
    time_t: s64 = ts.tv_sec;
    tm: tm_t;
    localtime_r(&time_t, &tm);
    buffer: char[64];
    snprintf(buffer, 64, "%04d-%02d-%02d %02d:%02d:%02d"c,
             tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
             tm.tm_hour, tm.tm_min, tm.tm_sec);
    return c_string::from_ptr(buffer as c_string, buffer as c_string + strlen(buffer));
  }
}
