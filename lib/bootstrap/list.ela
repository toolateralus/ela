
// forward declare panic.
panic :: fn(msg: c_string);

#ifndef FREESTANDING {
  impl![T] List![T] {
    slice :: fn(self*, range: Range) -> #self {
      if range.begin < 0 || range.end > self.length || range.begin > range.end {
        return {};
      }
      len := range.end - range.begin;
      slice_data: T* = malloc(sizeof(T) * len);
      memcpy(slice_data, self.data + range.begin, len);
      return {
        data: slice_data,
        length: len,
        capacity: len
      }
    }

    view :: fn(self*, range: Range) -> #self {
      if range.begin < 0 || range.end > self.length || range.begin > range.end {
        return {};
      }
      len := range.end - range.begin;
      return {
        data: self.data + range.begin,
        length: len,
        capacity: len
      }
    }

    // You should probably not call this function, and you do not need to for normal push operations.
    // In the case you want to shrink your array, you can pass in array.length or whatever you want to shrink to,
    // and this will set your length appropriately.
    resize :: fn(self*, new_capacity: u64) {
      if new_capacity < self.capacity && new_capacity < self.length then self.length = new_capacity; // Truncating.

      self.capacity = new_capacity;
      self.data = realloc(self.data, sizeof(T) * self.capacity);
      if !self.data then panic("Failed to allocate in List![{#type(T).name}]");
    }

    push   :: fn(self*, v: T) {
      if self.length + 1 >= self.capacity {
        if self.capacity == 0 then self.capacity = 4;
        self.resize(self.capacity * 2);
      }
      self.data[self.length] = v;
      self.length++;
    }

    pop    :: fn(self*) -> T {
      if self.length == 0 then panic("Attempted to pop from an empty List![{#type(T).name}]");
      value := self.data[self.length - 1];
      self.length -= 1;
      return value;
    }

    // This does not actually deinit any of members in the list.
    // We should have some compile time way to have alternatives based on a specializiation
    // like #if T: Deinit { } .. else {}

    // that causes an odd problem, though. Not really a problem, just an oddity:
    // some specializations would have functions where others would not.
    // you may expect a Type![T] to have a function and depending on a hidden where condition,
    // it may just not have it, and that would probably be a really confusing issue, where you call a known function on one generic
    // instantiation, but another jsut doesn't have it. We could have nice descriptive errors to combat this?
    deinit :: fn(self*) {
      free(self.data);
      self.data = null;
      self.length = 0;
    }

    at :: fn(self*, index: u64) -> T {
      return self.data[index];
    }
  }

  impl![T] Clone for List![T] {
    clone :: fn(self*) -> #self {
      new_data := malloc(sizeof(T) * self.capacity);
      if !new_data then panic("Failed to allocate in List clone");
      memcpy(new_data, self.data, sizeof(T) * self.length);
      return {
        data: new_data,
        length: self.length,
        capacity: self.capacity,
      }
    } 
  }

  impl![T] Iterable![T] for List![T] {
    iter :: fn(self*) -> Iter![T] {
      return {
        ptr: self.data,
        end: (self.data + self.length) as T*,
      }
    }
  }

  impl![T] List![T] {
    subscript :: fn(self*, idx: s64) -> T {
      return self.data[idx];
    }
  }

  impl![T] Init![T] for List![T] {
    init :: fn(init: Collection_Initializer![T]) -> #self {
      self: #self;
      for idx in 0..init.length {
        self.push(init.data[idx]);
      }
      return self;
    }
  }
}