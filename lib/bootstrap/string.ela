// #import utf8;

#ifndef FREESTANDING {
  // TODO: reimplement all the helper functions we used to have.
  // Also, we should make this not null terminated, rather controlled by length.
  // Another thing: We should use u8 or u64 for length, but you have to cast to signed 32 for all the C functions anyway,
  // So we'll have to rewrite them all for that.

  
  impl str {
  
    empty :: fn() -> #self {
      return {};
    }
    
    subscript :: fn(self*, idx: s64) -> u8 {
      return self.data[idx];
    }
    
    starts_with :: fn(self*, prefix: u8*) -> bool {
      prefix_len := strlen(prefix);
      if self.length < prefix_len then return false;
      for i in 0..prefix_len {
        if self.data[i] != prefix[i] then return false;
      }
      return true;
    }
    
    ends_with :: fn(self*, suffix: u8*) -> bool {
      suffix_len := strlen(suffix);
      if self.length < suffix_len then return false;
      for i in 0..suffix_len {
        if self.data[self.length - suffix_len + i] != suffix[i] then return false;
      }
      return true;
    }
    
    slice :: fn(self*, range: Range) -> Slice![u8] {
      start, end := (range.begin, range.end);
      length := end - start;

      if start < 0 || length < 0 || start + length > self.length {
        return {};
      }
      
      return {
        data: self.data + start,
        length: length,
      };
    }
    
    as_string :: fn(self) -> String {
      return {
        data: strdup(self.data),
        length: self.length,
      };
    }
    
  }

  impl String {
    // THIS IS JUST A VIEW OF THE CURRENT STRING, PERFORM A CLONE ON THE STR TO GET AN OWNED COPY.
    as_str :: fn(self) -> str {
      return {
        data: self.data,
        length: self.length,
      }
    }
    empty :: fn() -> #self {
      return {};
    }
    
    subscript :: fn(self*, idx: s64) -> u8 {
      return self.data[idx];
    }
    
    eq :: fn(self*, other: #self) -> bool {
      if self.length != other.length then return false;
      for idx in 0..self.length {
        if (*self)[idx] != other[idx] then return false;
      }
      return true;
    }
    
    starts_with :: fn(self*, prefix: u8*) -> bool {
      prefix_len := strlen(prefix);
      if self.length < prefix_len then return false;
      for i in 0..prefix_len {
        if self.data[i] != prefix[i] then return false;
      }
      return true;
    }
    ends_with :: fn(self*, suffix: u8*) -> bool {
      suffix_len := strlen(suffix);
      if self.length < suffix_len then return false;
      for i in 0..suffix_len {
        if self.data[self.length - suffix_len + i] != suffix[i] then return false;
      }
      return true;
    }
    replace :: fn(self*, old: u8*, replacement: u8*) -> str {
      old_len := strlen(old);
      new_len := strlen(replacement);
      result : str = {};
      for i in 0..self.length {
        if strncmp(self.data + i, old, old_len) == 0 {
          result.data = realloc(result.data, result.length + new_len + 1);
          memcpy(result.data + result.length, replacement, new_len);
          result.length += new_len;
          i += old_len - 1;
        } else {
          result.data = realloc(result.data, result.length + 1 + 1);
          result.data[result.length] = self.data[i];
          result.length++;
        }
      }
      result.data[result.length] = 0;
      return result;
    }
    
    from :: fn(data: u8*) -> #self{
      if !data then return {};
      len := strlen(data);
      return {
        data: strdup(data),
        capacity: len,
        length: len,
      };
    }
    
    from_ptr :: fn(begin: u8*, end: u8*) -> #self {
      self: #self;
      self.length = end - begin;
      self.capacity = self.length;
      self.data = malloc(sizeof(u8) * self.length + 1);
      memcpy(self.data, begin, self.length);
      self.data[self.length] = 0;
      return self;
    }

    resize :: fn(self*, new_size: u64) {
      if new_size < self.length then self.length = new_size;
      self.capacity = new_size;
      printf("new size %d\n"c, new_size);
      self.data = realloc(self.data, new_size * sizeof(u8));
      printf("done resizing\n"c);
    }
    
    push :: fn(self*, ch: u8) {
      if self.capacity == 0 then self.capacity = 256 / 3;
      if self.length + 1 >= self.capacity {
        self.resize(self.capacity * 3);
      }
      self.data[self.length] = ch;
      self.length++;
    }

    pop :: fn(self*) -> u8 {
      if self.length == 0 then return '\0' as u8;
      ch := self.data[self.length--];
      return ch;
    }

    // chars :: fn(self) -> u32[] {
    //   return utf8_decode(self);
    // }
   
  }

  impl Deinit for String {
    deinit :: fn(self*) {
      free(self.data);
      self.length = 0;
    }
  }
}

// This iterator is over the bytes.
impl Iterable![u8] for str { 
  iter :: fn(self*) -> Iter![u8] {
    return {
      ptr: self.data,
      end: self.data + self.length,
    }
  }
}

// This iterator is over the bytes.
// TODO: we need a chars() and bytes() function on both str and string,
// TODO: then we need to support taking an Enumerable![T]/Iter![T] directly in the for loop,
// TODO: cause right now we just look for it on the type
impl Iterable![u8] for String { 
  iter :: fn(self*) -> Iter![u8] {
    return {
      ptr: self.data,
      end: self.data + self.length,
    }
  }
}

impl As_Char_Slice![String] for String {
  as_char_slice :: fn(self) -> Slice![u32] {
    return {
      data: self.data,
      length: self.length,
    }
  }
}

impl As_Char_Slice![str] for str {
  as_char_slice :: fn(self) -> Slice![u32] {
    return {
      data: self.data,
      length: self.length,
    }
  }
}

impl As_Byte_Slice![str] for str {
  as_byte_slice :: fn(self) -> Slice![u8] {
    return {
      data: self.data,
      length: self.length
    }
  }
}

impl As_Byte_Slice![String] for String {
  as_byte_slice :: fn(self) -> Slice![u8] {
    return {
      data: self.data,
      length: self.length
    }
  }
}

impl SelfEq for str {
  eq :: fn(self, other: #self) -> bool {
    if self.length != other.length then return false;
    for idx in 0..self.length {
      if self[idx] != other[idx] then return false;
    }
    return true;
  }
  
  neq :: fn(self, other: #self) -> bool {
    return !self.eq(other);
  }
}

impl Hash for str {
	hash :: fn(self) -> u64 {
		hash : u64 = 0xCBF29CE484222325;
		for byte in self {
			hash ^= byte;
			hash *= 0x100000001B3;
		}
		return hash;
	}
}