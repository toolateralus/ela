;

#flags TypeFlags :: enum {
  INTEGER,
  FLOAT,
  BOOL,
  STRING,
  STRUCT,
  TAGGED_UNION,
  ENUM,
  TUPLE,
  ARRAY,
  FUNCTION,
  POINTER,
  SIGNED,
  UNSIGNED,
}

impl Type  {
  is_signed :: fn(self*) -> bool {
    return self.flags & TypeFlags::SIGNED != 0;
  }

  is_unsigned :: fn(self*) -> bool {
    return self.flags & TypeFlags::UNSIGNED != 0;
  }

  has_no_extension :: fn(self*) -> bool {
    return self.flags & TypeFlags::POINTER == 0 &&
          self.flags & TypeFlags::ARRAY == 0;
  }

  is_array :: fn(self*) -> bool {
    return self.flags & TypeFlags::ARRAY != 0;
  }

  is_string :: fn(self*) -> bool {
    return self.flags & TypeFlags::STRING != 0;
  }

  is_scalar :: fn(self*) -> bool {
    return Type::has_no_extension(self) &&
          (self.flags & TypeFlags::INTEGER != 0 ||
            self.flags & TypeFlags::FLOAT != 0   ||
            self.flags & TypeFlags::BOOL != 0    ||
            self.flags & TypeFlags::STRING != 0);
  }

  is_struct :: fn(self*) -> bool {
    return self.flags & TypeFlags::STRUCT != 0;
  }

  is_enum :: fn(self*) -> bool {
    return self.flags & TypeFlags::ENUM != 0;
  }

  is_integral :: fn(self*) -> bool {
    return self.flags & TypeFlags::INTEGER != 0;
  }

  is_float :: fn(self*) -> bool {
    return self.flags & TypeFlags::FLOAT != 0;
  }

  is_bool :: fn(self*) -> bool {
    return self.flags & TypeFlags::BOOL != 0;
  }

  is_tuple :: fn(self*) -> bool {
    return self.flags & TypeFlags::TUPLE != 0;
  }

  is_function :: fn(self*) -> bool {
    return self.flags & TypeFlags::FUNCTION != 0;
  }

  is_pointer :: fn(self*) -> bool {
    return self.flags & TypeFlags::POINTER != 0;
  }

  get_field :: fn(self*, name: string) -> Field* {
    for field in self.fields {
      if strcmp(field.name, name.data) == 0 {
        return field;
      }
    }
    return null;
  }

  // implemented externally. TODO: remove.
  find_type :: fn(name: string) -> Type *;
}
