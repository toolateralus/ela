#compiler_flags "-lGLEW -lGL -lglfw -lm"

GLFWwindow :: struct;

u32 GL_ARRAY_BUFFER = 34962;
u32 GL_FLOAT = 5126;
u32 GL_STATIC_DRAW = 35044;
u32 GL_TRIANGLES = 4;
u32 GL_INVALID_ENUM = 1280;
u32 GL_INVALID_VALUE = 1281;
u32 GL_INVALID_OPERATION = 1282;
u32 GL_STACK_OVERFLOW = 1283;
u32 GL_STACK_UNDERFLOW = 1284;
u32 GL_OUT_OF_MEMORY = 1285;
u32 GL_COLOR_BUFFER_BIT = 16384;
u32 GL_INFO_LOG_LENGTH = 35716;
u32 GL_COMPILE_STATUS = 35713;
u32 GL_LINK_STATUS = 35714;
u32 GL_VERTEX_SHADER = 35633;
u32 GL_FRAGMENT_SHADER = 35632;

#foreign glfwInit :: () -> bool;
#foreign glfwTerminate :: ();
#foreign glfwCreateWindow :: (int w, int h, char* t, void* v, void* v1) -> GLFWwindow*;
#foreign glfwMakeContextCurrent :: (void* ctx);
#foreign glfwWindowShouldClose :: (GLFWwindow *window) -> bool;
#foreign glfwPollEvents :: ();
#foreign glfwSwapBuffers :: (GLFWwindow *window);
#foreign glewInit :: () -> bool;
#foreign glGenVertexArrays :: (int n, u32* arrays);
#foreign glBindVertexArray :: (int array);
#foreign glGenBuffers :: (int n_buf, u32* buf);
#foreign glBindBuffer :: (int type, u32 buf);
#foreign glBufferData :: (int target, s64 size, void* data, int usage);
#foreign glEnableVertexAttribArray :: (int index);
#foreign glVertexAttribPointer :: (int index, s64 size, int type, bool normalized, s64 stride, void* pointer);
#foreign glDrawArrays :: (u32 mode, int first, int count);
#foreign glClearColor :: (float red, float green, float blue, float alpha);
#foreign glClear :: (u32 mask);
#foreign glGetError :: () -> int;
#foreign glCreateShader :: (u32 type) -> u32;
#foreign glShaderSource :: (u32 shader, int count, char** string, int* length);
#foreign glCompileShader :: (u32 shader);
#foreign glGetShaderiv :: (u32 shader, u32 pname, int* params);
#foreign glGetShaderInfoLog :: (u32 shader, int maxLength, int* length, char* infoLog);
#foreign glCreateProgram :: () -> u32;
#foreign glAttachShader :: (u32 program, u32 shader);
#foreign glLinkProgram :: (u32 program);
#foreign glGetProgramiv :: (u32 program, u32 pname, int* params);
#foreign glGetProgramInfoLog :: (u32 program, int maxLength, int* length, char* infoLog);
#foreign glUseProgram :: (u32 program);
#foreign glDeleteShader :: (s32 shader);
#foreign glDeleteProgram :: (s32 shader);
#foreign glViewport :: (int x, int y, int width, int height);

#foreign glfwGetKey :: (GLFWwindow* window, int key) -> u32;
#foreign glfwGetMouseButton :: (GLFWwindow* window, int button) -> u32;
#foreign glfwGetCursorPos :: (GLFWwindow* window, float* xpos, float* ypos);
#foreign glfwSetCursorPos :: (GLFWwindow* window, float xpos, float ypos);
#foreign glfwSetInputMode :: (GLFWwindow* window, int mode, int value);


u32 GLFW_RELEASE = 0;
u32 GLFW_PRESS = 1;
u32 GLFW_REPEAT = 2;

u32 GLFW_KEY_UNKNOWN = -1;
u32 GLFW_KEY_SPACE = 32;
u32 GLFW_KEY_APOSTROPHE = 39;
u32 GLFW_KEY_COMMA = 44;
u32 GLFW_KEY_MINUS = 45;
u32 GLFW_KEY_PERIOD = 46;
u32 GLFW_KEY_SLASH = 47;
u32 GLFW_KEY_0 = 48;
u32 GLFW_KEY_1 = 49;
u32 GLFW_KEY_2 = 50;
u32 GLFW_KEY_3 = 51;
u32 GLFW_KEY_4 = 52;
u32 GLFW_KEY_5 = 53;
u32 GLFW_KEY_6 = 54;
u32 GLFW_KEY_7 = 55;
u32 GLFW_KEY_8 = 56;
u32 GLFW_KEY_9 = 57;
u32 GLFW_KEY_SEMICOLON = 59;
u32 GLFW_KEY_EQUAL = 61;
u32 GLFW_KEY_A = 65;
u32 GLFW_KEY_B = 66;
u32 GLFW_KEY_C = 67;
u32 GLFW_KEY_D = 68;
u32 GLFW_KEY_E = 69;
u32 GLFW_KEY_F = 70;
u32 GLFW_KEY_G = 71;
u32 GLFW_KEY_H = 72;
u32 GLFW_KEY_I = 73;
u32 GLFW_KEY_J = 74;
u32 GLFW_KEY_K = 75;
u32 GLFW_KEY_L = 76;
u32 GLFW_KEY_M = 77;
u32 GLFW_KEY_N = 78;
u32 GLFW_KEY_O = 79;
u32 GLFW_KEY_P = 80;
u32 GLFW_KEY_Q = 81;
u32 GLFW_KEY_R = 82;
u32 GLFW_KEY_S = 83;
u32 GLFW_KEY_T = 84;
u32 GLFW_KEY_U = 85;
u32 GLFW_KEY_V = 86;
u32 GLFW_KEY_W = 87;
u32 GLFW_KEY_X = 88;
u32 GLFW_KEY_Y = 89;
u32 GLFW_KEY_Z = 90;
u32 GLFW_KEY_LEFT_BRACKET = 91;
u32 GLFW_KEY_BACKSLASH = 92;
u32 GLFW_KEY_RIGHT_BRACKET = 93;
u32 GLFW_KEY_GRAVE_ACCENT = 96;
u32 GLFW_KEY_WORLD_1 = 161;
u32 GLFW_KEY_WORLD_2 = 162;
u32 GLFW_KEY_ESCAPE = 256;
u32 GLFW_KEY_ENTER = 257;
u32 GLFW_KEY_TAB = 258;
u32 GLFW_KEY_BACKSPACE = 259;
u32 GLFW_KEY_INSERT = 260;
u32 GLFW_KEY_DELETE = 261;
u32 GLFW_KEY_RIGHT = 262;
u32 GLFW_KEY_LEFT = 263;
u32 GLFW_KEY_DOWN = 264;
u32 GLFW_KEY_UP = 265;
u32 GLFW_KEY_PAGE_UP = 266;
u32 GLFW_KEY_PAGE_DOWN = 267;
u32 GLFW_KEY_HOME = 268;
u32 GLFW_KEY_END = 269;
u32 GLFW_KEY_CAPS_LOCK = 280;
u32 GLFW_KEY_SCROLL_LOCK = 281;
u32 GLFW_KEY_NUM_LOCK = 282;
u32 GLFW_KEY_PRINT_SCREEN = 283;
u32 GLFW_KEY_PAUSE = 284;
u32 GLFW_KEY_F1 = 290;
u32 GLFW_KEY_F2 = 291;
u32 GLFW_KEY_F3 = 292;
u32 GLFW_KEY_F4 = 293;
u32 GLFW_KEY_F5 = 294;
u32 GLFW_KEY_F6 = 295;
u32 GLFW_KEY_F7 = 296;
u32 GLFW_KEY_F8 = 297;
u32 GLFW_KEY_F9 = 298;
u32 GLFW_KEY_F10 = 299;
u32 GLFW_KEY_F11 = 300;
u32 GLFW_KEY_F12 = 301;
u32 GLFW_KEY_F13 = 302;
u32 GLFW_KEY_F14 = 303;
u32 GLFW_KEY_F15 = 304;
u32 GLFW_KEY_F16 = 305;
u32 GLFW_KEY_F17 = 306;
u32 GLFW_KEY_F18 = 307;
u32 GLFW_KEY_F19 = 308;
u32 GLFW_KEY_F20 = 309;
u32 GLFW_KEY_F21 = 310;
u32 GLFW_KEY_F22 = 311;
u32 GLFW_KEY_F23 = 312;
u32 GLFW_KEY_F24 = 313;
u32 GLFW_KEY_F25 = 314;
u32 GLFW_KEY_KP_0 = 320;
u32 GLFW_KEY_KP_1 = 321;
u32 GLFW_KEY_KP_2 = 322;
u32 GLFW_KEY_KP_3 = 323;
u32 GLFW_KEY_KP_4 = 324;
u32 GLFW_KEY_KP_5 = 325;
u32 GLFW_KEY_KP_6 = 326;
u32 GLFW_KEY_KP_7 = 327;
u32 GLFW_KEY_KP_8 = 328;
u32 GLFW_KEY_KP_9 = 329;
u32 GLFW_KEY_KP_DECIMAL = 330;
u32 GLFW_KEY_KP_DIVIDE = 331;
u32 GLFW_KEY_KP_MULTIPLY = 332;
u32 GLFW_KEY_KP_SUBTRACT = 333;
u32 GLFW_KEY_KP_ADD = 334;
u32 GLFW_KEY_KP_ENTER = 335;
u32 GLFW_KEY_KP_EQUAL = 336;
u32 GLFW_KEY_LEFT_SHIFT = 340;
u32 GLFW_KEY_LEFT_CONTROL = 341;
u32 GLFW_KEY_LEFT_ALT = 342;
u32 GLFW_KEY_LEFT_SUPER = 343;
u32 GLFW_KEY_RIGHT_SHIFT = 344;
u32 GLFW_KEY_RIGHT_CONTROL = 345;
u32 GLFW_KEY_RIGHT_ALT = 346;
u32 GLFW_KEY_RIGHT_SUPER = 347;
u32 GLFW_KEY_MENU = 348;
u32 GLFW_KEY_LAST = GLFW_KEY_MENU;

compile_shader :: (u32 kind, char *source) -> u32 {
  u32 shader = glCreateShader(kind);
  glShaderSource(shader, 1, &source, null);
  glCompileShader(shader);

  int success;
  glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
  if success == 0 {
    int length;
    glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &length);
    char* info_log = malloc(sizeof(char*) * length);
    glGetShaderInfoLog(shader, length, &length, info_log);
    printf("Shader compilation failed: %s\n", info_log);
    free(info_log);
    return #make(u32, 0);
  }
  return shader;
}

create_program :: (char* vert_source, char* frag_source) -> u32 {
  u32 vertex_shader = compile_shader(GL_VERTEX_SHADER, vert_source);
  u32 fragment_shader = compile_shader(GL_FRAGMENT_SHADER, frag_source);

  if vertex_shader == 0 || fragment_shader == 0 {
    return #make(u32, 0);
  }

  u32 program = glCreateProgram();
  glAttachShader(program, vertex_shader);
  glAttachShader(program, fragment_shader);
  glLinkProgram(program);

  int success;
  glGetProgramiv(program, GL_LINK_STATUS, &success);
  if success == 0 {
    int length;
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &length);
    char* info_log = malloc(sizeof(char*) * length);
    glGetProgramInfoLog(program, length, &length, info_log);
    printf("Program linking failed: %s\n", info_log);
    free(info_log);
    return #make(u32, 0);
  }

  glDeleteShader(vertex_shader);
  glDeleteShader(fragment_shader);

  return program;
}

check_error :: (char* location) {
  int err = glGetError();
  if err == GL_INVALID_ENUM {
    printf("error: %s, from: %s\n", "GL_INVALID_ENUM", location);
  } else if err == GL_INVALID_VALUE {
    printf("error: %s, from: %s\n", "GL_INVALID_VALUE", location);
  } else if err == GL_INVALID_OPERATION {
    printf("error: %s, from: %s\n", "GL_INVALID_OPERATION", location);
  } else if err == GL_STACK_OVERFLOW {
    printf("error: %s, from: %s\n", "GL_STACK_OVERFLOW", location);
  } else if err == GL_STACK_UNDERFLOW {
    printf("error: %s, from: %s\n", "GL_STACK_UNDERFLOW", location);
  } else if err == GL_OUT_OF_MEMORY {
    printf("error: %s, from: %s\n", "GL_OUT_OF_MEMORY", location);
  } else if err != 0 {
    printf("unknown gl error: %d, from: %s\n", err, location);
  }
}

Shader :: struct {
  u32 handle;
  use :: () {
    glUseProgram(handle);
  }
  #ctor :: (char * vertexSource, char *fragSource) {
    handle = create_program(vertexSource, fragSource);
  }
  #dtor :: () {
    glDeleteProgram(handle);
  }
}

Window :: struct {
  GLFWwindow *handle;
  #ctor :: (int width, int height, char *title) {
    if !glfwInit() {
      return;
    }
    
    handle = glfwCreateWindow(800, 600, "Hello World", null, null);
    
    if handle == null {
      glfwTerminate();
      return;
    }
    glfwMakeContextCurrent(handle);
    if glewInit() != 0 {
      glfwTerminate();
      return;
    }
  }
  
  should_close :: () -> bool {
    return glfwWindowShouldClose(handle);
  }
  present :: ()  {
    glfwSwapBuffers(handle);
    glfwPollEvents();
  }
  clear :: () {
    glClear(GL_COLOR_BUFFER_BIT);
  }
}