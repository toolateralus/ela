#import math;


// TODO: pack these with GL, we need a system for storing .so/.a files with these modules & linking with them properly?
// TODO Or do we leave it up the the user to do that?
// TODO: either way, we need a way to specify or add these linking options and an ability to specify where you source your libraries from.
#c_flags "-lGLEW -lGL -lglfw -lm"

GLFWwindow :: struct;

#foreign glfwInit :: fn() -> bool;
#foreign glfwTerminate :: fn();
#foreign glfwCreateWindow :: fn(w: s32, h: s32, t: u8*, v: void*, v1: void*) -> GLFWwindow*;
#foreign glfwMakeContextCurrent :: fn(ctx: void*);
#foreign glfwWindowShouldClose :: fn(window: GLFWwindow*) -> bool;
#foreign glfwPollEvents :: fn();
#foreign glfwSwapBuffers :: fn(window: GLFWwindow*);
#foreign glewInit :: fn() -> bool;
#foreign glGenVertexArrays :: fn(n: s32, arrays: u32*);
#foreign glBindVertexArray :: fn(array: s32);
#foreign glGenBuffers :: fn(n_buf: s32, buf: u32*);
#foreign glBindBuffer :: fn(type: s32, buf: u32);
#foreign glBufferData :: fn(target: s32, size: s64, data: void*, usage: s32);
#foreign glEnableVertexAttribArray :: fn(index: s32);
#foreign glVertexAttribPointer :: fn(index: s32, size: s64, type: s32, normalized: bool, stride: s64, pointer: void*);
#foreign glVertexAttribIPointer :: fn(index: s32, size: s32, type: s32, stride: s64, pointer: void*);
#foreign glVertexAttribDivisor :: fn(index: u32, divisor: u32);
#foreign glDrawArrays :: fn(mode: u32, first, count);
#foreign glClearColor :: fn(red: f32, green: f32, blue: f32, alpha: f32);
#foreign glClear :: fn(mask: u32);
#foreign glGetError :: fn() -> s32;
#foreign glCreateShader :: fn(type: u32) -> u32;
#foreign glShaderSource :: fn(shader: u32, count: s32, s: u8**, length: s32*);
#foreign glCompileShader :: fn(shader: u32);
#foreign glGetShaderiv :: fn(shader: u32, pname, params: s32*);
#foreign glGetShaderInfoLog :: fn(shader: u32, maxLength: s32, length: s32*, infoLog: u8*);
#foreign glCreateProgram :: fn() -> u32;
#foreign glAttachShader :: fn(program: u32, shader);
#foreign glLinkProgram :: fn(program: u32);
#foreign glGetProgramiv :: fn(program: u32, pname, params: s32*);
#foreign glGetProgramInfoLog :: fn(program: u32, maxLength: s32, length: s32*, infoLog: u8*);
#foreign glUseProgram :: fn(program: u32);
#foreign glDeleteShader :: fn(shader: s32);
#foreign glDeleteProgram :: fn(shader: s32);
#foreign glViewport :: fn(x: s32, y: s32, width: s32, height: s32);

#foreign glfwGetKey :: fn(window: GLFWwindow*, key: s32) -> u32;
#foreign glfwGetMouseButton :: fn(window: GLFWwindow*, button: s32) -> u32;
#foreign glfwGetCursorPos :: fn(window: GLFWwindow*, xpos: f32*, ypos);
#foreign glfwSetCursorPos :: fn(window: GLFWwindow*, xpos: f32, ypos);
#foreign glfwSetInputMode :: fn(window: GLFWwindow*, mode: s32, value);

#foreign glGetUniformLocation :: fn(program: u32, name: u8*) -> s32;
#foreign glUniform4fv :: fn(location: s32, count, value: f32*);
#foreign glUniform3fv :: fn(location: s32, count, value: f32*);
#foreign glUniform2fv :: fn(location: s32, count, value: f32*);
#foreign glUniform1f :: fn(location: s32, v0: f32);
#foreign glUniformMatrix4fv :: fn(location: s32, count, transpose: bool, value: f32*);
#foreign glfwSwapInterval :: fn(interval: s32);

#foreign glEnable :: fn(cap: s32);
#foreign glDisable :: fn(cap: s32);
#foreign glIsEnabled :: fn(cap: s32) -> bool;

GL :: enum {
 STATIC_DRAW = 35044,
 ARRAY_BUFFER = 34962,
 INFO_LOG_LENGTH = 35716,
 COMPILE_STATUS = 35713,
 LINK_STATUS = 35714,
 VERTEX_SHADER = 35633,
 FRAGMENT_SHADER = 35632,
 ZERO = 0,
 FALSE = 0,
 LOGIC_OP = 0x0BF1,
 NONE = 0,
 TEXTURE_COMPONENTS = 0x1003,
 NO_ERROR = 0,
 POINTS = 0x0000,
 CURRENT_BIT = 0x00000001,
 TRUE = 1,
 ONE = 1,
 CLIENT_PIXEL_STORE_BIT = 0x00000001,
 LINES = 0x0001,
 LINE_LOOP = 0x0002,
 POINT_BIT = 0x00000002,
 CLIENT_VERTEX_ARRAY_BIT = 0x00000002,
 LINE_STRIP = 0x0003,
 LINE_BIT = 0x00000004,
 TRIANGLES = 0x0004,
 TRIANGLE_STRIP = 0x0005,
 TRIANGLE_FAN = 0x0006,
 QUADS = 0x0007,
 QUAD_STRIP = 0x0008,
 POLYGON_BIT = 0x00000008,
 POLYGON = 0x0009,
 POLYGON_STIPPLE_BIT = 0x00000010,
 PIXEL_MODE_BIT = 0x00000020,
 LIGHTING_BIT = 0x00000040,
 FOG_BIT = 0x00000080,
 DEPTH_BUFFER_BIT = 0x00000100,
 ACCUM = 0x0100,
 LOAD = 0x0101,
 RETURN = 0x0102,
 GL_MULT = 0x0103,
 GL_ADD = 0x0104,
 NEVER = 0x0200,
 ACCUM_BUFFER_BIT = 0x00000200,
 GL_LESS = 0x0201,
 GL_EQUAL = 0x0202,
 GL_LEQUAL = 0x0203,
 GL_GREATER = 0x0204,
 GL_NOTEQUAL = 0x0205,
 GEQUAL = 0x0206,
 ALWAYS = 0x0207,
 SRC_COLOR = 0x0300,
 ONE_MINUS_SRC_COLOR = 0x0301,
 SRC_ALPHA = 0x0302,
 ONE_MINUS_SRC_ALPHA = 0x0303,
 DST_ALPHA = 0x0304,
 ONE_MINUS_DST_ALPHA = 0x0305,
 DST_COLOR = 0x0306,
 ONE_MINUS_DST_COLOR = 0x0307,
 SRC_ALPHA_SATURATE = 0x0308,
 STENCIL_BUFFER_BIT = 0x00000400,
 FRONT_LEFT = 0x0400,
 FRONT_RIGHT = 0x0401,
 BACK_LEFT = 0x0402,
 BACK_RIGHT = 0x0403,
 FRONT = 0x0404,
 BACK = 0x0405,
 LEFT = 0x0406,
 RIGHT = 0x0407,
 FRONT_AND_BACK = 0x0408,
 AUX0 = 0x0409,
 AUX1 = 0x040A,
 AUX2 = 0x040B,
 AUX3 = 0x040C,
 INVALID_ENUM = 0x0500,
 INVALID_VALUE = 0x0501,
 INVALID_OPERATION = 0x0502,
 STACK_OVERFLOW = 0x0503,
 STACK_UNDERFLOW = 0x0504,
 OUT_OF_MEMORY = 0x0505,
 _2D = 0x0600,                  // These are a special case where we actually had to change the name of the GL identifier. Sucks
 _3D = 0x0601,                  // These are a special case where we actually had to change the name of the GL identifier. Sucks
 _3D_COLOR = 0x0602,            // These are a special case where we actually had to change the name of the GL identifier. Sucks
 _3D_COLOR_TEXTURE = 0x0603,    // These are a special case where we actually had to change the name of the GL identifier. Sucks
 _4D_COLOR_TEXTURE = 0x0604,    // These are a special case where we actually had to change the name of the GL identifier. Sucks
 PASS_THROUGH_TOKEN = 0x0700,
 POINT_TOKEN = 0x0701,
 LINE_TOKEN = 0x0702,
 POLYGON_TOKEN = 0x0703,
 BITMAP_TOKEN = 0x0704,
 DRAW_PIXEL_TOKEN = 0x0705,
 COPY_PIXEL_TOKEN = 0x0706,
 LINE_RESET_TOKEN = 0x0707,
 EXP = 0x0800,
 VIEWPORT_BIT = 0x00000800,
 EXP2 = 0x0801,
 CW = 0x0900,
 CCW = 0x0901,
 COEFF = 0x0A00,
 ORDER = 0x0A01,
 DOMAIN = 0x0A02,
 CURRENT_COLOR = 0x0B00,
 CURRENT_INDEX = 0x0B01,
 CURRENT_NORMAL = 0x0B02,
 CURRENT_TEXTURE_COORDS = 0x0B03,
 CURRENT_RASTER_COLOR = 0x0B04,
 CURRENT_RASTER_INDEX = 0x0B05,
 CURRENT_RASTER_TEXTURE_COORDS = 0x0B06,
 CURRENT_RASTER_POSITION = 0x0B07,
 CURRENT_RASTER_POSITION_VALID = 0x0B08,
 CURRENT_RASTER_DISTANCE = 0x0B09,
 POINT_SMOOTH = 0x0B10,
 POINT_SIZE = 0x0B11,
 POINT_SIZE_RANGE = 0x0B12,
 POINT_SIZE_GRANULARITY = 0x0B13,
 LINE_SMOOTH = 0x0B20,
 LINE_WIDTH = 0x0B21,
 LINE_WIDTH_RANGE = 0x0B22,
 LINE_WIDTH_GRANULARITY = 0x0B23,
 LINE_STIPPLE = 0x0B24,
 LINE_STIPPLE_PATTERN = 0x0B25,
 LINE_STIPPLE_REPEAT = 0x0B26,
 LIST_MODE = 0x0B30,
 MAX_LIST_NESTING = 0x0B31,
 LIST_BASE = 0x0B32,
 LIST_INDEX = 0x0B33,
 POLYGON_MODE = 0x0B40,
 POLYGON_SMOOTH = 0x0B41,
 POLYGON_STIPPLE = 0x0B42,
 EDGE_FLAG = 0x0B43,
 CULL_FACE = 0x0B44,
 CULL_FACE_MODE = 0x0B45,
 FRONT_FACE = 0x0B46,
 LIGHTING = 0x0B50,
 LIGHT_MODEL_LOCAL_VIEWER = 0x0B51,
 LIGHT_MODEL_TWO_SIDE = 0x0B52,
 LIGHT_MODEL_AMBIENT = 0x0B53,
 SHADE_MODEL = 0x0B54,
 COLOR_MATERIAL_FACE = 0x0B55,
 COLOR_MATERIAL_PARAMETER = 0x0B56,
 COLOR_MATERIAL = 0x0B57,
 FOG = 0x0B60,
 FOG_INDEX = 0x0B61,
 FOG_DENSITY = 0x0B62,
 FOG_START = 0x0B63,
 FOG_END = 0x0B64,
 FOG_MODE = 0x0B65,
 FOG_COLOR = 0x0B66,
 DEPTH_RANGE = 0x0B70,
 DEPTH_TEST = 0x0B71,
 DEPTH_WRITEMASK = 0x0B72,
 DEPTH_CLEAR_VALUE = 0x0B73,
 DEPTH_FUNC = 0x0B74,
 ACCUM_CLEAR_VALUE = 0x0B80,
 STENCIL_TEST = 0x0B90,
 STENCIL_CLEAR_VALUE = 0x0B91,
 STENCIL_FUNC = 0x0B92,
 STENCIL_VALUE_MASK = 0x0B93,
 STENCIL_FAIL = 0x0B94,
 STENCIL_PASS_DEPTH_FAIL = 0x0B95,
 STENCIL_PASS_DEPTH_PASS = 0x0B96,
 STENCIL_REF = 0x0B97,
 STENCIL_WRITEMASK = 0x0B98,
 MATRIX_MODE = 0x0BA0,
 NORMALIZE = 0x0BA1,
 VIEWPORT = 0x0BA2,
 MODELVIEW_STACK_DEPTH = 0x0BA3,
 PROJECTION_STACK_DEPTH = 0x0BA4,
 TEXTURE_STACK_DEPTH = 0x0BA5,
 MODELVIEW_MATRIX = 0x0BA6,
 PROJECTION_MATRIX = 0x0BA7,
 TEXTURE_MATRIX = 0x0BA8,
 ATTRIB_STACK_DEPTH = 0x0BB0,
 CLIENT_ATTRIB_STACK_DEPTH = 0x0BB1,
 ALPHA_TEST = 0x0BC0,
 ALPHA_TEST_FUNC = 0x0BC1,
 ALPHA_TEST_REF = 0x0BC2,
 DITHER = 0x0BD0,
 BLEND_DST = 0x0BE0,
 BLEND_SRC = 0x0BE1,
 BLEND = 0x0BE2,
 LOGIC_OP_MODE = 0x0BF0,
 INDEX_LOGIC_OP = 0x0BF1,
 COLOR_LOGIC_OP = 0x0BF2,
 AUX_BUFFERS = 0x0C00,
 DRAW_BUFFER = 0x0C01,
 READ_BUFFER = 0x0C02,
 SCISSOR_BOX = 0x0C10,
 SCISSOR_TEST = 0x0C11,
 INDEX_CLEAR_VALUE = 0x0C20,
 INDEX_WRITEMASK = 0x0C21,
 COLOR_CLEAR_VALUE = 0x0C22,
 COLOR_WRITEMASK = 0x0C23,
 INDEX_MODE = 0x0C30,
 RGBA_MODE = 0x0C31,
 DOUBLEBUFFER = 0x0C32,
 STEREO = 0x0C33,
 RENDER_MODE = 0x0C40,
 PERSPECTIVE_CORRECTION_HINT = 0x0C50,
 POINT_SMOOTH_HINT = 0x0C51,
 LINE_SMOOTH_HINT = 0x0C52,
 POLYGON_SMOOTH_HINT = 0x0C53,
 FOG_HINT = 0x0C54,
 TEXTURE_GEN_S = 0x0C60,
 TEXTURE_GEN_T = 0x0C61,
 TEXTURE_GEN_R = 0x0C62,
 TEXTURE_GEN_Q = 0x0C63,
 PIXEL_MAP_I_TO_I = 0x0C70,
 PIXEL_MAP_S_TO_S = 0x0C71,
 PIXEL_MAP_I_TO_R = 0x0C72,
 PIXEL_MAP_I_TO_G = 0x0C73,
 PIXEL_MAP_I_TO_B = 0x0C74,
 PIXEL_MAP_I_TO_A = 0x0C75,
 PIXEL_MAP_R_TO_R = 0x0C76,
 PIXEL_MAP_G_TO_G = 0x0C77,
 PIXEL_MAP_B_TO_B = 0x0C78,
 PIXEL_MAP_A_TO_A = 0x0C79,
 PIXEL_MAP_I_TO_I_SIZE = 0x0CB0,
 PIXEL_MAP_S_TO_S_SIZE = 0x0CB1,
 PIXEL_MAP_I_TO_R_SIZE = 0x0CB2,
 PIXEL_MAP_I_TO_G_SIZE = 0x0CB3,
 PIXEL_MAP_I_TO_B_SIZE = 0x0CB4,
 PIXEL_MAP_I_TO_A_SIZE = 0x0CB5,
 PIXEL_MAP_R_TO_R_SIZE = 0x0CB6,
 PIXEL_MAP_G_TO_G_SIZE = 0x0CB7,
 PIXEL_MAP_B_TO_B_SIZE = 0x0CB8,
 PIXEL_MAP_A_TO_A_SIZE = 0x0CB9,
 UNPACK_SWAP_BYTES = 0x0CF0,
 UNPACK_LSB_FIRST = 0x0CF1,
 UNPACK_ROW_LENGTH = 0x0CF2,
 UNPACK_SKIP_ROWS = 0x0CF3,
 UNPACK_SKIP_PIXELS = 0x0CF4,
 UNPACK_ALIGNMENT = 0x0CF5,
 PACK_SWAP_BYTES = 0x0D00,
 PACK_LSB_FIRST = 0x0D01,
 PACK_ROW_LENGTH = 0x0D02,
 PACK_SKIP_ROWS = 0x0D03,
 PACK_SKIP_PIXELS = 0x0D04,
 PACK_ALIGNMENT = 0x0D05,
 MAP_COLOR = 0x0D10,
 MAP_STENCIL = 0x0D11,
 INDEX_SHIFT = 0x0D12,
 INDEX_OFFSET = 0x0D13,
 RED_SCALE = 0x0D14,
 RED_BIAS = 0x0D15,
 ZOOM_X = 0x0D16,
 ZOOM_Y = 0x0D17,
 GREEN_SCALE = 0x0D18,
 GREEN_BIAS = 0x0D19,
 BLUE_SCALE = 0x0D1A,
 BLUE_BIAS = 0x0D1B,
 ALPHA_SCALE = 0x0D1C,
 ALPHA_BIAS = 0x0D1D,
 DEPTH_SCALE = 0x0D1E,
 DEPTH_BIAS = 0x0D1F,
 MAX_EVAL_ORDER = 0x0D30,
 MAX_LIGHTS = 0x0D31,
 MAX_CLIP_PLANES = 0x0D32,
 MAX_TEXTURE_SIZE = 0x0D33,
 MAX_PIXEL_MAP_TABLE = 0x0D34,
 MAX_ATTRIB_STACK_DEPTH = 0x0D35,
 MAX_MODELVIEW_STACK_DEPTH = 0x0D36,
 MAX_NAME_STACK_DEPTH = 0x0D37,
 MAX_PROJECTION_STACK_DEPTH = 0x0D38,
 MAX_TEXTURE_STACK_DEPTH = 0x0D39,
 MAX_VIEWPORT_DIMS = 0x0D3A,
 MAX_CLIENT_ATTRIB_STACK_DEPTH = 0x0D3B,
 SUBPIXEL_BITS = 0x0D50,
 INDEX_BITS = 0x0D51,
 RED_BITS = 0x0D52,
 GREEN_BITS = 0x0D53,
 BLUE_BITS = 0x0D54,
 ALPHA_BITS = 0x0D55,
 DEPTH_BITS = 0x0D56,
 STENCIL_BITS = 0x0D57,
 ACCUM_RED_BITS = 0x0D58,
 ACCUM_GREEN_BITS = 0x0D59,
 ACCUM_BLUE_BITS = 0x0D5A,
 ACCUM_ALPHA_BITS = 0x0D5B,
 NAME_STACK_DEPTH = 0x0D70,
 AUTO_NORMAL = 0x0D80,
 MAP1_COLOR_4 = 0x0D90,
 MAP1_INDEX = 0x0D91,
 MAP1_NORMAL = 0x0D92,
 MAP1_TEXTURE_COORD_1 = 0x0D93,
 MAP1_TEXTURE_COORD_2 = 0x0D94,
 MAP1_TEXTURE_COORD_3 = 0x0D95,
 MAP1_TEXTURE_COORD_4 = 0x0D96,
 MAP1_VERTEX_3 = 0x0D97,
 MAP1_VERTEX_4 = 0x0D98,
 MAP2_COLOR_4 = 0x0DB0,
 MAP2_INDEX = 0x0DB1,
 MAP2_NORMAL = 0x0DB2,
 MAP2_TEXTURE_COORD_1 = 0x0DB3,
 MAP2_TEXTURE_COORD_2 = 0x0DB4,
 MAP2_TEXTURE_COORD_3 = 0x0DB5,
 MAP2_TEXTURE_COORD_4 = 0x0DB6,
 MAP2_VERTEX_3 = 0x0DB7,
 MAP2_VERTEX_4 = 0x0DB8,
 MAP1_GRID_DOMAIN = 0x0DD0,
 MAP1_GRID_SEGMENTS = 0x0DD1,
 MAP2_GRID_DOMAIN = 0x0DD2,
 MAP2_GRID_SEGMENTS = 0x0DD3,
 TEXTURE_1D = 0x0DE0,
 TEXTURE_2D = 0x0DE1,
 FEEDBACK_BUFFER_POINTER = 0x0DF0,
 FEEDBACK_BUFFER_SIZE = 0x0DF1,
 FEEDBACK_BUFFER_TYPE = 0x0DF2,
 SELECTION_BUFFER_POINTER = 0x0DF3,
 SELECTION_BUFFER_SIZE = 0x0DF4,
 TEXTURE_WIDTH = 0x1000,
 TRANSFORM_BIT = 0x00001000,
 TEXTURE_HEIGHT = 0x1001,
 TEXTURE_INTERNAL_FORMAT = 0x1003,
 TEXTURE_BORDER_COLOR = 0x1004,
 TEXTURE_BORDER = 0x1005,
 DONT_CARE = 0x1100,
 FASTEST = 0x1101,
 NICEST = 0x1102,
 AMBIENT = 0x1200,
 DIFFUSE = 0x1201,
 SPECULAR = 0x1202,
 POSITION = 0x1203,
 SPOT_DIRECTION = 0x1204,
 SPOT_EXPONENT = 0x1205,
 SPOT_CUTOFF = 0x1206,
 CONSTANT_ATTENUATION = 0x1207,
 LINEAR_ATTENUATION = 0x1208,
 QUADRATIC_ATTENUATION = 0x1209,
 COMPILE = 0x1300,
 COMPILE_AND_EXECUTE = 0x1301,
 BYTE = 0x1400,
 UNSIGNED_BYTE = 0x1401,
 SHORT = 0x1402,
 UNSIGNED_SHORT = 0x1403,
 INT = 0x1404,
 UNSIGNED_INT = 0x1405,
 FLOAT = 0x1406,
 TWO_BYTES = 0x1407,
 THREE_BYTES = 0x1408,
 FOUR_BYTES = 0x1409,
 DOUBLE = 0x140A,
 CLEAR = 0x1500,
 AND = 0x1501,
 AND_REVERSE = 0x1502,
 COPY = 0x1503,
 AND_INVERTED = 0x1504,
 NOOP = 0x1505,
 XOR = 0x1506,
 OR = 0x1507,
 NOR = 0x1508,
 EQUIV = 0x1509,
 INVERT = 0x150A,
 OR_REVERSE = 0x150B,
 COPY_INVERTED = 0x150C,
 OR_INVERTED = 0x150D,
 NAND = 0x150E,
 SET = 0x150F,
 EMISSION = 0x1600,
 SHININESS = 0x1601,
 AMBIENT_AND_DIFFUSE = 0x1602,
 COLOR_INDEXES = 0x1603,
 MODELVIEW = 0x1700,
 PROJECTION = 0x1701,
 TEXTURE = 0x1702,
 COLOR = 0x1800,
 DEPTH = 0x1801,
 STENCIL = 0x1802,
 COLOR_INDEX = 0x1900,
 STENCIL_INDEX = 0x1901,
 DEPTH_COMPONENT = 0x1902,
 RED = 0x1903,
 GREEN = 0x1904,
 BLUE = 0x1905,
 ALPHA = 0x1906,
 RGB = 0x1907,
 RGBA = 0x1908,
 LUMINANCE = 0x1909,
 LUMINANCE_ALPHA = 0x190A,
 BITMAP = 0x1A00,
 POINT = 0x1B00,
 LINE = 0x1B01,
 FILL = 0x1B02,
 RENDER = 0x1C00,
 FEEDBACK = 0x1C01,
 SELECT = 0x1C02,
 FLAT = 0x1D00,
 SMOOTH = 0x1D01,
 KEEP = 0x1E00,
 REPLACE = 0x1E01,
 INCR = 0x1E02,
 DECR = 0x1E03,
 VENDOR = 0x1F00,
 RENDERER = 0x1F01,
 VERSION = 0x1F02,
 EXTENSIONS = 0x1F03,
 ENABLE_BIT = 0x00002000,
 S = 0x2000,
 T = 0x2001,
 R = 0x2002,
 Q = 0x2003,
 MODULATE = 0x2100,
 DECAL = 0x2101,
 TEXTURE_ENV_MODE = 0x2200,
 TEXTURE_ENV_COLOR = 0x2201,
 TEXTURE_ENV = 0x2300,
 EYE_LINEAR = 0x2400,
 OBJECT_LINEAR = 0x2401,
 SPHERE_MAP = 0x2402,
 TEXTURE_GEN_MODE = 0x2500,
 OBJECT_PLANE = 0x2501,
 EYE_PLANE = 0x2502,
 NEAREST = 0x2600,
 LINEAR = 0x2601,
 NEAREST_MIPMAP_NEAREST = 0x2700,
 LINEAR_MIPMAP_NEAREST = 0x2701,
 NEAREST_MIPMAP_LINEAR = 0x2702,
 LINEAR_MIPMAP_LINEAR = 0x2703,
 TEXTURE_MAG_FILTER = 0x2800,
 TEXTURE_MIN_FILTER = 0x2801,
 TEXTURE_WRAP_S = 0x2802,
 TEXTURE_WRAP_T = 0x2803,
 CLAMP = 0x2900,
 REPEAT = 0x2901,
 POLYGON_OFFSET_UNITS = 0x2A00,
 POLYGON_OFFSET_POINT = 0x2A01,
 POLYGON_OFFSET_LINE = 0x2A02,
 R3_G3_B2 = 0x2A10,
 V2F = 0x2A20,
 V3F = 0x2A21,
 C4UB_V2F = 0x2A22,
 C4UB_V3F = 0x2A23,
 C3F_V3F = 0x2A24,
 N3F_V3F = 0x2A25,
 C4F_N3F_V3F = 0x2A26,
 T2F_V3F = 0x2A27,
 T4F_V4F = 0x2A28,
 T2F_C4UB_V3F = 0x2A29,
 T2F_C3F_V3F = 0x2A2A,
 T2F_N3F_V3F = 0x2A2B,
 T2F_C4F_N3F_V3F = 0x2A2C,
 T4F_C4F_N3F_V4F = 0x2A2D,
 CLIP_PLANE0 = 0x3000,
 CLIP_PLANE1 = 0x3001,
 CLIP_PLANE2 = 0x3002,
 CLIP_PLANE3 = 0x3003,
 CLIP_PLANE4 = 0x3004,
 CLIP_PLANE5 = 0x3005,
 LIGHT0 = 0x4000,
 COLOR_BUFFER_BIT = 0x00004000,
 LIGHT1 = 0x4001,
 LIGHT2 = 0x4002,
 LIGHT3 = 0x4003,
 LIGHT4 = 0x4004,
 LIGHT5 = 0x4005,
 LIGHT6 = 0x4006,
 LIGHT7 = 0x4007,
 HINT_BIT = 0x00008000,
 POLYGON_OFFSET_FILL = 0x8037,
 POLYGON_OFFSET_FACTOR = 0x8038,
 ALPHA4 = 0x803B,
 ALPHA8 = 0x803C,
 ALPHA12 = 0x803D,
 ALPHA16 = 0x803E,
 LUMINANCE4 = 0x803F,
 LUMINANCE8 = 0x8040,
 LUMINANCE12 = 0x8041,
 LUMINANCE16 = 0x8042,
 LUMINANCE4_ALPHA4 = 0x8043,
 LUMINANCE6_ALPHA2 = 0x8044,
 LUMINANCE8_ALPHA8 = 0x8045,
 LUMINANCE12_ALPHA4 = 0x8046,
 LUMINANCE12_ALPHA12 = 0x8047,
 LUMINANCE16_ALPHA16 = 0x8048,
 INTENSITY = 0x8049,
 INTENSITY4 = 0x804A,
 INTENSITY8 = 0x804B,
 INTENSITY12 = 0x804C,
 INTENSITY16 = 0x804D,
 RGB4 = 0x804F,
 RGB5 = 0x8050,
 RGB8 = 0x8051,
 RGB10 = 0x8052,
 RGB12 = 0x8053,
 RGB16 = 0x8054,
 RGBA2 = 0x8055,
 RGBA4 = 0x8056,
 RGB5_A1 = 0x8057,
 RGBA8 = 0x8058,
 RGB10_A2 = 0x8059,
 RGBA12 = 0x805A,
 RGBA16 = 0x805B,
 TEXTURE_RED_SIZE = 0x805C,
 TEXTURE_GREEN_SIZE = 0x805D,
 TEXTURE_BLUE_SIZE = 0x805E,
 TEXTURE_ALPHA_SIZE = 0x805F,
 TEXTURE_LUMINANCE_SIZE = 0x8060,
 TEXTURE_INTENSITY_SIZE = 0x8061,
 PROXY_TEXTURE_1D = 0x8063,
 PROXY_TEXTURE_2D = 0x8064,
 TEXTURE_PRIORITY = 0x8066,
 TEXTURE_RESIDENT = 0x8067,
 TEXTURE_BINDING_1D = 0x8068,
 TEXTURE_BINDING_2D = 0x8069,
 VERTEX_ARRAY = 0x8074,
 NORMAL_ARRAY = 0x8075,
 COLOR_ARRAY = 0x8076,
 INDEX_ARRAY = 0x8077,
 TEXTURE_COORD_ARRAY = 0x8078,
 EDGE_FLAG_ARRAY = 0x8079,
 VERTEX_ARRAY_SIZE = 0x807A,
 VERTEX_ARRAY_TYPE = 0x807B,
 VERTEX_ARRAY_STRIDE = 0x807C,
 NORMAL_ARRAY_TYPE = 0x807E,
 NORMAL_ARRAY_STRIDE = 0x807F,
 COLOR_ARRAY_SIZE = 0x8081,
 COLOR_ARRAY_TYPE = 0x8082,
 COLOR_ARRAY_STRIDE = 0x8083,
 INDEX_ARRAY_TYPE = 0x8085,
 INDEX_ARRAY_STRIDE = 0x8086,
 TEXTURE_COORD_ARRAY_SIZE = 0x8088,
 TEXTURE_COORD_ARRAY_TYPE = 0x8089,
 TEXTURE_COORD_ARRAY_STRIDE = 0x808A,
 EDGE_FLAG_ARRAY_STRIDE = 0x808C,
 VERTEX_ARRAY_POINTER = 0x808E,
 NORMAL_ARRAY_POINTER = 0x808F,
 COLOR_ARRAY_POINTER = 0x8090,
 INDEX_ARRAY_POINTER = 0x8091,
 TEXTURE_COORD_ARRAY_POINTER = 0x8092,
 EDGE_FLAG_ARRAY_POINTER = 0x8093,
 COLOR_INDEX1_EXT = 0x80E2,
 COLOR_INDEX2_EXT = 0x80E3,
 COLOR_INDEX4_EXT = 0x80E4,
 COLOR_INDEX8_EXT = 0x80E5,
 COLOR_INDEX12_EXT = 0x80E6,
 COLOR_INDEX16_EXT = 0x80E7,
 EVAL_BIT = 0x00010000,
 LIST_BIT = 0x00020000,
 TEXTURE_BIT = 0x00040000,
 SCISSOR_BIT = 0x00080000,
 ALL_ATTRIB_BITS = 0x000fffff,
 CLIENT_ALL_ATTRIB_BITS =0xffffffff,
}

GLKeyPress :: enum {
  Released = 0,
  Pressed = 1,
  Repeating = 2,
}

GLKey :: enum {
  UNKNOWN = -1,
  SPACE = 32,
  APOSTROPHE = 39,
  COMMA = 44,
  MINUS = 45,
  PERIOD = 46,
  SLASH = 47,
  D0 = 48,
  D1 = 49,
  D2 = 50,
  D3 = 51,
  D4 = 52,
  D5 = 53,
  D6 = 54,
  D7 = 55,
  D8 = 56,
  D9 = 57,
  SEMICOLON = 59,
  EQUAL = 61,
  A = 65,
  B = 66,
  C = 67,
  D = 68,
  E = 69,
  F = 70,
  G = 71,
  H = 72,
  I = 73,
  J = 74,
  K = 75,
  L = 76,
  M = 77,
  N = 78,
  O = 79,
  P = 80,
  Q = 81,
  R = 82,
  S = 83,
  T = 84,
  U = 85,
  V = 86,
  W = 87,
  X = 88,
  Y = 89,
  Z = 90,
  LEFT_BRACKET = 91,
  BACKSLASH = 92,
  RIGHT_BRACKET = 93,
  GRAVE_ACCENT = 96,
  WORLD_1 = 161,
  WORLD_2 = 162,
  ESCAPE = 256,
  ENTER = 257,
  TAB = 258,
  BACKSPACE = 259,
  INSERT = 260,
  DELETE = 261,
  RIGHT = 262,
  LEFT = 263,
  DOWN = 264,
  UP = 265,
  PAGE_UP = 266,
  PAGE_DOWN = 267,
  HOME = 268,
  END = 269,
  CAPS_LOCK = 280,
  SCROLL_LOCK = 281,
  NUM_LOCK = 282,
  PRINT_SCREEN = 283,
  PAUSE = 284,
  F1 = 290,
  F2 = 291,
  F3 = 292,
  F4 = 293,
  F5 = 294,
  F6 = 295,
  F7 = 296,
  F8 = 297,
  F9 = 298,
  F10 = 299,
  F11 = 300,
  F12 = 301,
  F13 = 302,
  F14 = 303,
  F15 = 304,
  F16 = 305,
  F17 = 306,
  F18 = 307,
  F19 = 308,
  F20 = 309,
  F21 = 310,
  F22 = 311,
  F23 = 312,
  F24 = 313,
  F25 = 314,
  KP_0 = 320,
  KP_1 = 321,
  KP_2 = 322,
  KP_3 = 323,
  KP_4 = 324,
  KP_5 = 325,
  KP_6 = 326,
  KP_7 = 327,
  KP_8 = 328,
  KP_9 = 329,
  KP_DECIMAL = 330,
  KP_DIVIDE = 331,
  KP_MULTIPLY = 332,
  KP_SUBTRACT = 333,
  KP_ADD = 334,
  KP_ENTER = 335,
  KP_EQUAL = 336,
  LEFT_SHIFT = 340,
  LEFT_CONTROL = 341,
  LEFT_ALT = 342,
  LEFT_SUPER = 343,
  RIGHT_SHIFT = 344,
  RIGHT_CONTROL = 345,
  RIGHT_ALT = 346,
  RIGHT_SUPER = 347,
  MENU = 348,
  LAST = 348,
}

compile_shader :: fn(kind: u32, source: u8*) -> u32 {
  shader: u32 = glCreateShader(kind);
  glShaderSource(shader, 1, &source, null);
  glCompileShader(shader);

  success: s32;
  glGetShaderiv(shader, GL::COMPILE_STATUS, &success);
  if success == 0 {
    length: s32;
    glGetShaderiv(shader, GL::INFO_LOG_LENGTH, &length);
    info_log: u8* = malloc(sizeof(u8*) * length);
    glGetShaderInfoLog(shader, length, &length, info_log);
    printf("Shader compilation failed: %s\n"c, info_log);
    free(info_log);
    return 0;
  }
  return shader;
}

create_program :: fn(vert_source: u8*, frag_source: u8*) -> u32 {
  vertex_shader: u32 = compile_shader(GL::VERTEX_SHADER, vert_source);
  fragment_shader: u32 = compile_shader(GL::FRAGMENT_SHADER, frag_source);

  if vertex_shader == 0 || fragment_shader == 0 {
    return 0 as u32;
  }

  program: u32 = glCreateProgram();
  glAttachShader(program, vertex_shader);
  glAttachShader(program, fragment_shader);
  glLinkProgram(program);

  success: s32;
  glGetProgramiv(program, GL::LINK_STATUS, &success);
  if success == 0 {
    length: s32;
    glGetProgramiv(program, GL::INFO_LOG_LENGTH, &length);
    info_log: u8* = malloc(sizeof(u8*) * length);
    glGetProgramInfoLog(program, length, &length, info_log);
    printf("Program linking failed: %s\n"c, info_log);
    free(info_log);
    return 0 as u32;
  }

  glDeleteShader(vertex_shader);
  glDeleteShader(fragment_shader);

  return program;
}

check_error :: fn(location: u8*) {
  err: s32 = glGetError();
  if err == GL::INVALID_ENUM {
    printf("error: %s, from: %s\n"c, "GL::INVALID_ENUM"c, location);
  } else if err == GL::INVALID_VALUE {
    printf("error: %s, from: %s\n"c, "GL::INVALID_VALUE"c, location);
  } else if err == GL::INVALID_OPERATION {
    printf("error: %s, from: %s\n"c, "GL::INVALID_OPERATION"c, location);
  } else if err == GL::STACK_OVERFLOW {
    printf("error: %s, from: %s\n"c, "GL::STACK_OVERFLOW"c, location);
  } else if err == GL::STACK_UNDERFLOW {
    printf("error: %s, from: %s\n"c, "GL::STACK_UNDERFLOW"c, location);
  } else if err == GL::OUT_OF_MEMORY {
    printf("error: %s, from: %s\n"c, "GL::OUT_OF_MEMORYc", location);
  } else if err != 0 {
    printf("unknown gl error: %d, from: %s\n"c, err, location);
  }
}

Vec4 :: union {
  values: f32[4],
  #anon :: struct {
    x: f32,
    y: f32,
    z: f32,
    w: f32,
  }
}

impl Vec4 {
  sqr_mag :: fn(self*) -> f32 {
    return self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w;
  }
  one :: fn() -> #self {
    return { x: 1.0, y: 1.0, z: 1.0, w: 1.0 };
  }
  zero :: fn() -> #self {
    return { x: 0.0, y: 0.0, z: 0.0, w: 0.0 };
  }
}

Vec3 :: union {
  values: f32[3],
  #anon :: struct {
    x: f32,
    y: f32,
    z: f32,
  }  
}

impl Vec3 {
  up :: fn() -> #self {
    #static up: #self = {
      x: 0, y: 1, z: 0
    };
    return up;
  }


  sqr_mag :: fn(self*) -> f32 {
    return self.x * self.x + self.y * self.y + self.z * self.z;
  }
  one :: fn() -> #self {
    return { x: 1.0, y: 1.0, z: 1.0 };
  }
  zero :: fn() -> Vec3 {
    return { x: 0.0, y: 0.0, z: 0.0 };
  }
  normalize :: fn(self) -> #self {
    mag: f32 = sqrt(self.x * self.x + self.y * self.y + self.z * self.z) as f32;
    return { x: self.x / mag, y: self.y / mag, z: self.z / mag };
  }
  cross :: fn(self, other: Vec3) -> Vec3 {
    return {
      x: self.y * other.z - self.z * other.y,
      y: self.z * other.x - self.x * other.z,
      z: self.x * other.y - self.y * other.x,
    };
  }
  dot :: fn(self, other: Vec3) -> f32 {
    return self.x * other.x + self.y * other.y + self.z * other.z;
  }
}

impl Vec3 {
  add :: fn(self, other: Vec3) -> Vec3 {
    return {
      x: self.x + other.x,
      y: self.y + other.y,
      z: self.z + other.z,
    };
  }
  sub :: fn(self, other: Vec3) -> Vec3 {
    return {
      x: self.x - other.x,
      y: self.y - other.y,
      z: self.z - other.z,
    };
  }
  mul :: fn(self, scalar: f32) -> Vec3 {
    return {
      x: self.x * scalar,
      y: self.y * scalar,
      z: self.z * scalar,
    };
  }
  div :: fn(self, scalar: f32) -> Vec3 {
    return {
      x: self.x / scalar,
      y: self.y / scalar,
      z: self.z / scalar,
    };
  }
}

Vec2 :: union {
  values: f32[2],
  #anon :: struct {
    x: f32,
    y: f32,
  }
}

impl Vec2 {
  sqr_mag :: fn(self*) -> f32 {
    return self.x * self.x + self.y * self.y;
  }
  one :: fn() -> #self {
    return { x: 1.0, y: 1.0 };
  }
  zero  :: fn() -> #self {
    return { x: 0.0, y: 0.0 };
  }
  normalize :: fn(self*) -> #self {
    mag: f32 = sqrt(self.x * self.x + self.y * self.y) as f32;
    return { x: self.x / mag, y: self.y / mag };
  }
}

Mat4 :: union {
  values: f32[16],
  #anon :: struct {
    M00: f32,
    M01: f32,
    M02: f32,
    M03: f32,
    M10: f32,
    M11: f32,
    M12: f32,
    M13: f32,
    M20: f32,
    M21: f32,
    M22: f32,
    M23: f32,
    M30: f32,
    M31: f32,
    M32: f32,
    M33: f32,
  },
}

___unused__junk :: fn() {
  // ! this bypasses a bug in the dependency emitter
  // ! where the Mat4 methods get emitted before the Vec3 methods
  // ! I can't reproduce this bug outside of this module, so it is what it is 
  // ! BUG BUG BUG !
  v, v1 := (Vec3::zero(), Vec3::zero());
  v2 := v - v1;
}


impl Mat4 {


  zero :: fn() -> #self {
    return {
      M00: 0.0, M01: 0.0, M02: 0.0, M03: 0.0,
      M10: 0.0, M11: 0.0, M12: 0.0, M13: 0.0,
      M20: 0.0, M21: 0.0, M22: 0.0, M23: 0.0,
      M30: 0.0, M31: 0.0, M32: 0.0, M33: 0.0
    };
  }

  scale :: fn(self*, factor: f32) -> #self {
    matrix: #self;
    matrix.M00 = self.M00 * factor;
    matrix.M01 = self.M01 * factor;
    matrix.M02 = self.M02 * factor;
    matrix.M03 = self.M03 * factor;
    matrix.M10 = self.M10 * factor;
    matrix.M11 = self.M11 * factor;
    matrix.M12 = self.M12 * factor;
    matrix.M13 = self.M13 * factor;
    matrix.M20 = self.M20 * factor;
    matrix.M21 = self.M21 * factor;
    matrix.M22 = self.M22 * factor;
    matrix.M23 = self.M23 * factor;
    matrix.M30 = self.M30 * factor;
    matrix.M31 = self.M31 * factor;
    matrix.M32 = self.M32 * factor;
    matrix.M33 = self.M33 * factor;
    return matrix;
  }

  normalize :: fn(self*) -> #self {
    mag: f32 = sqrt(self.M00 * self.M00 + self.M01 * self.M01 + self.M02 * self.M02 + self.M03 * self.M03 +
                   self.M10 * self.M10 + self.M11 * self.M11 + self.M12 * self.M12 + self.M13 * self.M13 +
                   self.M20 * self.M20 + self.M21 * self.M21 + self.M22 * self.M22 + self.M23 * self.M23 +
                   self.M30 * self.M30 + self.M31 * self.M31 + self.M32 * self.M32 + self.M33 * self.M33) as f32;
    return self.scale(1.0 / mag);
  }

  determinant :: fn(self*) -> f32 {
    r0: f32 = self.M00 * (self.M11 * (self.M22 * self.M33 - self.M23 * self.M32) - self.M12 * (self.M21 * self.M33 - self.M23 * self.M31) + self.M13 * (self.M21 * self.M32 - self.M22 * self.M31));
    r1: f32 = self.M01 * (self.M10 * (self.M22 * self.M33 - self.M23 * self.M32) - self.M12 * (self.M20 * self.M33 - self.M23 * self.M30) + self.M13 * (self.M20 * self.M32 - self.M22 * self.M30));
    r2: f32 = self.M02 * (self.M10 * (self.M21 * self.M33 - self.M23 * self.M31) - self.M11 * (self.M20 * self.M33 - self.M23 * self.M30) + self.M13 * (self.M20 * self.M31 - self.M21 * self.M30));
    r3: f32 = self.M03 * (self.M10 * (self.M21 * self.M32 - self.M22 * self.M31) - self.M11 * (self.M20 * self.M32 - self.M22 * self.M30) + self.M12 * (self.M20 * self.M31 - self.M21 * self.M30));
    return r0 - r1 + r2 - r3;
  }

  identity :: fn() -> #self {
    matrix: #self;
    matrix.M00 = 1.0;
    matrix.M01 = 0.0;
    matrix.M02 = 0.0;
    matrix.M03 = 0.0;
    matrix.M10 = 0.0;
    matrix.M11 = 1.0;
    matrix.M12 = 0.0;
    matrix.M13 = 0.0;
    matrix.M20 = 0.0;
    matrix.M21 = 0.0;
    matrix.M22 = 1.0;
    matrix.M23 = 0.0;
    matrix.M30 = 0.0;
    matrix.M31 = 0.0;
    matrix.M32 = 0.0;
    matrix.M33 = 1.0;
    return matrix;
  }

  look_at :: fn(eye: Vec3, center: Vec3, up: Vec3) -> #self {
    f: Vec3 = (center - eye).normalize();
    s: Vec3 = f.cross(up).normalize();
    u: Vec3 = s.cross(f);

    matrix: #self = Mat4::identity();
    matrix.M00 = s.x;
    matrix.M01 = s.y;
    matrix.M02 = s.z;
    matrix.M10 = u.x;
    matrix.M11 = u.y;
    matrix.M12 = u.z;
    matrix.M20 = -f.x;
    matrix.M21 = -f.y;
    matrix.M22 = -f.z;
    matrix.M30 = -s.dot(eye);
    matrix.M31 = -u.dot(eye);
    matrix.M32 = f.dot(eye);

    return matrix;
  }

  perspective :: fn(fov: f32, aspect: f32, near: f32, far: f32) -> #self {
    tan_half_fov: f32 = tan(fov / 2.0) as f32;

    matrix: #self = Mat4::zero();
    matrix.M00 = 1.0 / (aspect * tan_half_fov);
    matrix.M11 = 1.0 / tan_half_fov;
    matrix.M22 = -(far + near) / (far - near);
    matrix.M23 = -1.0;
    matrix.M32 = -(2.0 * far * near) / (far - near);
    matrix.M33 = 0.0;

    return matrix;
  }

  mul :: fn(self, other: #self) -> #self {
    matrix: #self;
    matrix.M00 = self.M00 * other.M00 + self.M01 * other.M10 + self.M02 * other.M20 + self.M03 * other.M30;
    matrix.M01 = self.M00 * other.M01 + self.M01 * other.M11 + self.M02 * other.M21 + self.M03 * other.M31;
    matrix.M02 = self.M00 * other.M02 + self.M01 * other.M12 + self.M02 * other.M22 + self.M03 * other.M32;
    matrix.M03 = self.M00 * other.M03 + self.M01 * other.M13 + self.M02 * other.M23 + self.M03 * other.M33;
    
    matrix.M10 = self.M10 * other.M00 + self.M11 * other.M10 + self.M12 * other.M20 + self.M13 * other.M30;
    matrix.M11 = self.M10 * other.M01 + self.M11 * other.M11 + self.M12 * other.M21 + self.M13 * other.M31;
    matrix.M12 = self.M10 * other.M02 + self.M11 * other.M12 + self.M12 * other.M22 + self.M13 * other.M32;
    matrix.M13 = self.M10 * other.M03 + self.M11 * other.M13 + self.M12 * other.M23 + self.M13 * other.M33;
    
    matrix.M20 = self.M20 * other.M00 + self.M21 * other.M10 + self.M22 * other.M20 + self.M23 * other.M30;
    matrix.M21 = self.M20 * other.M01 + self.M21 * other.M11 + self.M22 * other.M21 + self.M23 * other.M31;
    matrix.M22 = self.M20 * other.M02 + self.M21 * other.M12 + self.M22 * other.M22 + self.M23 * other.M32;
    matrix.M23 = self.M20 * other.M03 + self.M21 * other.M13 + self.M22 * other.M23 + self.M23 * other.M33;
    
    matrix.M30 = self.M30 * other.M00 + self.M31 * other.M10 + self.M32 * other.M20 + self.M33 * other.M30;
    matrix.M31 = self.M30 * other.M01 + self.M31 * other.M11 + self.M32 * other.M21 + self.M33 * other.M31;
    matrix.M32 = self.M30 * other.M02 + self.M31 * other.M12 + self.M32 * other.M22 + self.M33 * other.M32;
    matrix.M33 = self.M30 * other.M03 + self.M31 * other.M13 + self.M32 * other.M23 + self.M33 * other.M33;
    return matrix;
  }
  
  translation :: fn(translation: Vec3) -> #self {
    matrix: #self = Mat4::identity();
    matrix.M03 = translation.x;
    matrix.M13 = translation.y;
    matrix.M23 = translation.z;
    return matrix;
  }

  rotation :: fn(rotation: Vec3) -> #self {
    cx: f32 = cos(rotation.x) as f32;
    sx: f32 = sin(rotation.x) as f32;
    cy: f32 = cos(rotation.y) as f32;
    sy: f32 = sin(rotation.y) as f32;
    cz: f32 = cos(rotation.z) as f32;
    sz: f32 = sin(rotation.z) as f32;

    matrix: #self = Mat4::identity();
    matrix.M00 = cy * cz;
    matrix.M01 = -cy * sz;
    matrix.M02 = sy;

    matrix.M10 = sx * sy * cz + cx * sz;
    matrix.M11 = -sx * sy * sz + cx * cz;
    matrix.M12 = -sx * cy;

    matrix.M20 = -cx * sy * cz + sx * sz;
    matrix.M21 = cx * sy * sz + sx * cz;
    matrix.M22 = cx * cy;

    return matrix;
  }

  scalar :: fn(scale: Vec3) -> #self {
    matrix: #self = Mat4::identity();
    matrix.M00 = scale.x;
    matrix.M11 = scale.y;
    matrix.M22 = scale.z;
    return matrix;
  }

  get_translation :: fn(self) -> Vec3 {
    return { x: self.M03, y: self.M13, z: self.M23 };
  }

  get_scale :: fn(self) -> Vec3 {
    return {
      x: sqrt(self.M00 * self.M00 + self.M01 * self.M01 + self.M02 * self.M02) as f32,
      y: sqrt(self.M10 * self.M10 + self.M11 * self.M11 + self.M12 * self.M12) as f32,
      z: sqrt(self.M20 * self.M20 + self.M21 * self.M21 + self.M22 * self.M22) as f32,
    };
  }

  get_rotation :: fn(self) -> Vec3 {
    scale := self.get_scale();
    return {
      x: atan2(self.M21 / scale.z, self.M22 / scale.z) as f32,
      y: atan2(-self.M20 / scale.z, sqrt(self.M21 * self.M21 + self.M22 * self.M22) / scale.z) as f32,
      z: atan2(self.M10 / scale.y, self.M00 / scale.x) as f32,
    };
  }

}


Shader :: struct {
  handle: u32
}

impl Shader {

  deinit :: fn(self*) {
    glDeleteProgram(self.handle);
  }

  use :: fn(self*) {
    glUseProgram(self.handle);
  }
  
  create :: fn(vertexSource: String, fragSource: String) -> #self {
    v: #self;
    v.handle = create_program(vertexSource.data, fragSource.data);
    return v;
  }
  
  set_mat4 :: fn(self*, name: str, v: Mat4*) {
    index := glGetUniformLocation(self.handle, name.data);
    if index != -1 {
      glUniformMatrix4fv(index, 1, false, v.values as f32*);
    } else {
      printf("failed to get uniform : %s\n"c, name.data);
    }
  }
  
  set_vec4 :: fn(self*, name: str, v: Vec4*) {
    index := glGetUniformLocation(self.handle, name.data);
    if index != -1 {
      glUniform4fv(index, 1, v.values as f32*);
    } else {
      printf("failed to get uniform : %s\n"c, name.data);
    }
  }
  
  set_vec3 :: fn(self*, name: str, v: Vec3*) {
    index := glGetUniformLocation(self.handle, name.data);
    if index != -1 {
      glUniform3fv(index, 1, v.values as f32*);
    } else {
      printf("failed to get uniform : %s\n"c, name.data);
    }
  }
  
  set_vec2 :: fn(self*, name: str, v: Vec2*) {
    index := glGetUniformLocation(self.handle, name.data);
    if index != -1 {
      glUniform2fv(index, 1, v.values as f32*);
    } else {
      printf("failed to get uniform : %s\n"c, name.data);
    }
  }
  
  set_float :: fn(self*, name: str, v: f32) {
    index := glGetUniformLocation(self.handle, name.data);
    if index != -1 {
      glUniform1f(index, v);
    } else {
      printf("failed to get uniform : %s\n"c, name.data);
    }
  }

  set :: fn![T](self*, name: str, v: T*) {
    switch #type(T) {
      #type(f32): {
        self.set_float(name, *(v as f32*));
        return;
      }
      #type(Vec2): {
        self.set_vec2(name, v as Vec2*);
        return;
      }
      #type(Vec3): {
        self.set_vec3(name, v as Vec3*);
        return;
      }
      #type(Vec4): {
        self.set_vec4(name, v as Vec4*);
        return;
      }
      #type(Mat4): {
        self.set_mat4(name, v as Mat4*);
        return;
      }
    }
    printf("incompatible type with 'set' method on shader: only f32, Vec2/3/4, and Mat4 are currently supported\n");
  }
}

Window :: struct {
  handle: GLFWwindow*
}

impl Window {
  create :: fn(width: s32, height: s32, title: str) -> #self {
    self: #self;
    
    if !glfwInit() {
      printf("Failed to initialize glfw\n"c);
      return self;
    }
    
    self.handle = glfwCreateWindow(width, height, title.data, null, null);
    
    if self.handle == null {
      printf("Failed to create window\n"c);
      glfwTerminate();
      return self;
    }
    
    glfwMakeContextCurrent(self.handle);
    
    if glewInit() != 0 {
      printf("Failed to initialize glew\n"c);
      glfwTerminate();
      return self;
    }
    
    return self;
  }
  
  should_close :: fn(self*) -> bool {
    return glfwWindowShouldClose(self.handle);
  }
  
  present :: fn(self*) {
    glfwSwapBuffers(self.handle);
    glfwPollEvents();
  }
  
  clear :: fn(flags: GL) {
    glClear(flags);
  }
}

Camera :: struct {
  position: Vec3,
  target: Vec3,
  up: Vec3,
  fov: f32,
  aspect_ratio: f32,
  near: f32,
  far: f32,
  view: Mat4,
  projection: Mat4,
}

impl Camera {
  new :: fn(up: Vec3, fov: f32, aspect, near, far) -> #self {
    return {
      position: Vec3::zero(),
      target:   Vec3::zero(),
      up: up,
      fov: fov,
      aspect_ratio: aspect,
      near: near,
      far: far,
    }
  }

  update :: fn(self*) {
    self.view = Mat4::look_at(self.position, self.target, self.up);
    self.projection = Mat4::perspective(self.fov, self.aspect_ratio, self.near, self.far);
  }
}