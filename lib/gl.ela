#compiler_flags "-lGLEW -lGL -lglfw -lm"

GLFWwindow :: struct;

#foreign glfwInit :: () -> bool;
#foreign glfwTerminate :: ();
#foreign glfwCreateWindow :: (int w, int h, char* t, void* v, void* v1) -> GLFWwindow*;
#foreign glfwMakeContextCurrent :: (void* ctx);
#foreign glfwWindowShouldClose :: (GLFWwindow *window) -> bool;
#foreign glfwPollEvents :: ();
#foreign glfwSwapBuffers :: (GLFWwindow *window);
#foreign glewInit :: () -> bool;
#foreign glGenVertexArrays :: (int n, u32* arrays);
#foreign glBindVertexArray :: (int array);
#foreign glGenBuffers :: (int n_buf, u32* buf);
#foreign glBindBuffer :: (int type, u32 buf);
#foreign glBufferData :: (int target, s64 size, void* data, int usage);
#foreign glEnableVertexAttribArray :: (int index);
#foreign glVertexAttribPointer :: (int index, s64 size, int type, bool normalized, s64 stride, void* pointer);
#foreign glDrawArrays :: (u32 mode, first, count);
#foreign glClearColor :: (float red, green, blue, alpha);
#foreign glClear :: (u32 mask);
#foreign glGetError :: () -> int;
#foreign glCreateShader :: (u32 type) -> u32;
#foreign glShaderSource :: (u32 shader, int count, char** string, int* length);
#foreign glCompileShader :: (u32 shader);
#foreign glGetShaderiv :: (u32 shader, pname, int* params);
#foreign glGetShaderInfoLog :: (u32 shader, int maxLength, int* length, char* infoLog);
#foreign glCreateProgram :: () -> u32;
#foreign glAttachShader :: (u32 program, shader);
#foreign glLinkProgram :: (u32 program);
#foreign glGetProgramiv :: (u32 program, pname, int* params);
#foreign glGetProgramInfoLog :: (u32 program, int maxLength, int* length, char* infoLog);
#foreign glUseProgram :: (u32 program);
#foreign glDeleteShader :: (s32 shader);
#foreign glDeleteProgram :: (s32 shader);
#foreign glViewport :: (int x, y, int width, height);

#foreign glfwGetKey :: (GLFWwindow* window, int key) -> u32;
#foreign glfwGetMouseButton :: (GLFWwindow* window, int button) -> u32;
#foreign glfwGetCursorPos :: (GLFWwindow* window, float* xpos, ypos);
#foreign glfwSetCursorPos :: (GLFWwindow* window, float xpos, ypos);
#foreign glfwSetInputMode :: (GLFWwindow* window, int mode, value);

#foreign glGetUniformLocation :: (u32 program, char* name) -> int;
#foreign glUniform4fv :: (int location, count, float* value);
#foreign glUniform3fv :: (int location, count, float* value);
#foreign glUniform2fv :: (int location, count, float* value);
#foreign glUniform1f :: (int location, float v0);
#foreign glUniformMatrix4fv :: (int location, count, bool transpose, float* value);
#foreign glfwSwapInterval :: (int interval);

GL :: enum {
  FALSE = 0,
  TRUE = 1,
  ARRAY_BUFFER = 34962,
  FLOAT = 5126,
  STATIC_DRAW = 35044,
  TRIANGLES = 4,
  INVALID_ENUM = 1280,
  INVALID_VALUE = 1281,
  INVALID_OPERATION = 1282,
  STACK_OVERFLOW = 1283,
  STACK_UNDERFLOW = 1284,
  OUT_OF_MEMORY = 1285,
  COLOR_BUFFER_BIT = 16384,
  INFO_LOG_LENGTH = 35716,
  COMPILE_STATUS = 35713,
  LINK_STATUS = 35714,
  VERTEX_SHADER = 35633,
  FRAGMENT_SHADER = 35632,
}

KeyPress :: enum {
  RELEASE = 0,
  PRESS = 1,
  REPEAT = 2,
}

Key :: enum {
  UNKNOWN = -1,
  SPACE = 32,
  APOSTROPHE = 39,
  COMMA = 44,
  MINUS = 45,
  PERIOD = 46,
  SLASH = 47,
  D0 = 48,
  D1 = 49,
  D2 = 50,
  D3 = 51,
  D4 = 52,
  D5 = 53,
  D6 = 54,
  D7 = 55,
  D8 = 56,
  D9 = 57,
  SEMICOLON = 59,
  EQUAL = 61,
  A = 65,
  B = 66,
  C = 67,
  D = 68,
  E = 69,
  F = 70,
  G = 71,
  H = 72,
  I = 73,
  J = 74,
  K = 75,
  L = 76,
  M = 77,
  N = 78,
  O = 79,
  P = 80,
  Q = 81,
  R = 82,
  S = 83,
  T = 84,
  U = 85,
  V = 86,
  W = 87,
  X = 88,
  Y = 89,
  Z = 90,
  LEFT_BRACKET = 91,
  BACKSLASH = 92,
  RIGHT_BRACKET = 93,
  GRAVE_ACCENT = 96,
  WORLD_1 = 161,
  WORLD_2 = 162,
  ESCAPE = 256,
  ENTER = 257,
  TAB = 258,
  BACKSPACE = 259,
  INSERT = 260,
  DELETE = 261,
  RIGHT = 262,
  LEFT = 263,
  DOWN = 264,
  UP = 265,
  PAGE_UP = 266,
  PAGE_DOWN = 267,
  HOME = 268,
  END = 269,
  CAPS_LOCK = 280,
  SCROLL_LOCK = 281,
  NUM_LOCK = 282,
  PRINT_SCREEN = 283,
  PAUSE = 284,
  F1 = 290,
  F2 = 291,
  F3 = 292,
  F4 = 293,
  F5 = 294,
  F6 = 295,
  F7 = 296,
  F8 = 297,
  F9 = 298,
  F10 = 299,
  F11 = 300,
  F12 = 301,
  F13 = 302,
  F14 = 303,
  F15 = 304,
  F16 = 305,
  F17 = 306,
  F18 = 307,
  F19 = 308,
  F20 = 309,
  F21 = 310,
  F22 = 311,
  F23 = 312,
  F24 = 313,
  F25 = 314,
  KP_0 = 320,
  KP_1 = 321,
  KP_2 = 322,
  KP_3 = 323,
  KP_4 = 324,
  KP_5 = 325,
  KP_6 = 326,
  KP_7 = 327,
  KP_8 = 328,
  KP_9 = 329,
  KP_DECIMAL = 330,
  KP_DIVIDE = 331,
  KP_MULTIPLY = 332,
  KP_SUBTRACT = 333,
  KP_ADD = 334,
  KP_ENTER = 335,
  KP_EQUAL = 336,
  LEFT_SHIFT = 340,
  LEFT_CONTROL = 341,
  LEFT_ALT = 342,
  LEFT_SUPER = 343,
  RIGHT_SHIFT = 344,
  RIGHT_CONTROL = 345,
  RIGHT_ALT = 346,
  RIGHT_SUPER = 347,
  MENU = 348,
  LAST = 348,
}

compile_shader :: (u32 kind, char *source) -> u32 {
  u32 shader = glCreateShader(kind);
  glShaderSource(shader, 1, &source, null);
  glCompileShader(shader);

  int success;
  glGetShaderiv(shader, GL.COMPILE_STATUS, &success);
  if success == 0 {
    int length;
    glGetShaderiv(shader, GL.INFO_LOG_LENGTH, &length);
    char* info_log = malloc(sizeof(char*) * length);
    glGetShaderInfoLog(shader, length, &length, info_log);
    printf("Shader compilation failed: %s\n", info_log);
    free(info_log);
    return #make(u32, 0);
  }
  return shader;
}

create_program :: (char* vert_source, char* frag_source) -> u32 {
  u32 vertex_shader = compile_shader(GL.VERTEX_SHADER, vert_source);
  u32 fragment_shader = compile_shader(GL.FRAGMENT_SHADER, frag_source);

  if vertex_shader == 0 || fragment_shader == 0 {
    return #make(u32, 0);
  }

  u32 program = glCreateProgram();
  glAttachShader(program, vertex_shader);
  glAttachShader(program, fragment_shader);
  glLinkProgram(program);

  int success;
  glGetProgramiv(program, GL.LINK_STATUS, &success);
  if success == 0 {
    int length;
    glGetProgramiv(program, GL.INFO_LOG_LENGTH, &length);
    char* info_log = malloc(sizeof(char*) * length);
    glGetProgramInfoLog(program, length, &length, info_log);
    printf("Program linking failed: %s\n", info_log);
    free(info_log);
    return #make(u32, 0);
  }

  glDeleteShader(vertex_shader);
  glDeleteShader(fragment_shader);

  return program;
}

check_error :: (char* location) {
  int err = glGetError();
  if err == GL.INVALID_ENUM {
    printf("error: %s, from: %s\n", "GL.INVALID_ENUM", location);
  } else if err == GL.INVALID_VALUE {
    printf("error: %s, from: %s\n", "GL.INVALID_VALUE", location);
  } else if err == GL.INVALID_OPERATION {
    printf("error: %s, from: %s\n", "GL.INVALID_OPERATION", location);
  } else if err == GL.STACK_OVERFLOW {
    printf("error: %s, from: %s\n", "GL.STACK_OVERFLOW", location);
  } else if err == GL.STACK_UNDERFLOW {
    printf("error: %s, from: %s\n", "GL.STACK_UNDERFLOW", location);
  } else if err == GL.OUT_OF_MEMORY {
    printf("error: %s, from: %s\n", "GL.OUT_OF_MEMORY", location);
  } else if err != 0 {
    printf("unknown gl error: %d, from: %s\n", err, location);
  }
}


mat4 :: union {
  float[16] values;
  #anon :: struct {
    float M00;
    float M01;
    float M02;
    float M03;
    float M10;
    float M11;
    float M12;
    float M13;
    float M20;
    float M21;
    float M22;
    float M23;
    float M30;
    float M31;
    float M32;
    float M33;
  };
}

mat4_identity :: () -> mat4 {
  mat4 matrix;
  matrix.M00 = 1.0;
  matrix.M01 = 0.0;
  matrix.M02 = 0.0;
  matrix.M03 = 0.0;
  matrix.M10 = 0.0;
  matrix.M11 = 1.0;
  matrix.M12 = 0.0;
  matrix.M13 = 0.0;
  matrix.M20 = 0.0;
  matrix.M21 = 0.0;
  matrix.M22 = 1.0;
  matrix.M23 = 0.0;
  matrix.M30 = 0.0;
  matrix.M31 = 0.0;
  matrix.M32 = 0.0;
  matrix.M33 = 1.0;
  return matrix;
}
vec4 :: union {
  float[4] values;
  #anon :: struct {
    float x;
    float y;
    float z;
    float w;
  }
  #ctor :: () {}
  #ctor :: (float _x, _y, _z, _w) {
    x = _x;
    y = _y;
    z = _z;
    w = _w;
  }
  #ctor :: (float value) {
    x = value;
    y = value;
    z = value;
    w = value;
  }
}

vec4_one :: () -> vec4 {
  return #make(vec4, 1.0);
}

vec4_zero :: () -> vec4 {
  return #make(vec4, 0.0);
}

vec3 :: union {
  float[3] values;
  #anon :: struct {
    float x;
    float y;
    float z;
  }
  #ctor :: () {}
  #ctor :: (float _x, _y, _z) {
    x = _x;
    y = _y;
    z = _z;
  }
  #ctor :: (float value) {
    x = value;
    y = value;
    z = value;
  }
}

vec3_one :: () -> vec3 {
  return #make(vec3, 1.0);
}

vec3_zero :: () -> vec3 {
  return #make(vec3, 0.0);
}


vec2 :: union {
  float[2] values;
  #anon :: struct {
    float x;
    float y;
  }
  #ctor :: () {}
  #ctor :: (float _x, _y) {
    x = _x;
    y = _y;
  }
  #ctor :: (float value) {
    x = value;
    y = value;
  }
}

vec2_one :: () -> vec2 {
  return #make(vec2, 1.0);
}

vec2_zero :: () -> vec2 {
  return #make(vec2, 0.0);
}



Shader :: struct {
  u32 handle;
  use :: () {
    glUseProgram(handle);
  }
  #ctor :: (char * vertexSource, char *fragSource) {
    handle = create_program(vertexSource, fragSource);
  }
  #dtor :: () {
    glDeleteProgram(handle);
  }
  set_mat4 :: (char *name, mat4 *v) {
    index := glGetUniformLocation(handle, name);
    if index != -1 {
      glUniformMatrix4fv(index, 1, false, #make(float*, v.values));
    } else {
      printf("failed to get uniform : %s\n", name);
    }
  }

  set_vec4 :: (char *name, vec4 *v) {
    index := glGetUniformLocation(handle, name);
    if index != -1 {
      glUniform4fv(index, 1, #make(float*, v.values));
    } else {
      printf("failed to get uniform : %s\n", name);
    }
  }
  set_vec3 :: (char *name, vec3 *v) {
    index := glGetUniformLocation(handle, name);
    if index != -1 {
      glUniform3fv(index, 1, #make(float*, v.values));
    } else {
      printf("failed to get uniform : %s\n", name);
    }
  }
  set_vec2 :: (char *name, vec2 *v) {
    index := glGetUniformLocation(handle, name);
    if index != -1 {
      glUniform2fv(index, 1, #make(float*, v.values));
    } else {
      printf("failed to get uniform : %s\n", name);
    }
  }
  set_float :: (char * name, float v) {
    index := glGetUniformLocation(handle, name);
    if index != -1 {
      glUniform1f(index, v);
    } else {
      printf("failed to get uniform : %s\n", name);
    }
  }
}

Window :: struct {
  GLFWwindow *handle;
  #ctor :: (int width, int height, char *title) {
    if !glfwInit() {
      printf("Failed to initialize glfw\n");
      return;
    }
    handle = glfwCreateWindow(width, height, title, null, null);
    if handle == null {
      printf("Failed to create window\n");
      glfwTerminate();
      return;
    }
    glfwMakeContextCurrent(handle);
    if glewInit() != 0 {
      printf("Failed to initialize glew\n");
      glfwTerminate();
      return;
    }
  }
  should_close :: () -> bool {
    return glfwWindowShouldClose(handle);
  }
  present :: ()  {
    glfwSwapBuffers(handle);
    glfwPollEvents();
  }
  clear :: () {
    glClear(GL.COLOR_BUFFER_BIT);
  }
}