
// This seems pretty chunky,
// it might be more performant for building large strings,
// but perhaps this is a setting we can have the user pass in.
STRING_BUILDER_BLOCK_MAX_LEN :: 8192;

String_Builder_Block :: struct {
  data: u8*,
  length: u64,
  next: String_Builder_Block*,
}

impl String_Builder_Block {
  new :: fn() -> #self* {
    self : #self* =  malloc(sizeof(String_Builder_Block));
    self.data = malloc(sizeof(u8) * STRING_BUILDER_BLOCK_MAX_LEN);
    return self;
  }
  deinit :: fn(self*) {
    if self.data then free(self.data);
    if self.next then self.next.deinit();
  } 
}

String_Builder :: struct {
  root: String_Builder_Block*,
  current: String_Builder_Block*,
}

impl String_Builder {
  deinit :: fn(self*) {
    if self.root then self.root.deinit();
  }

  length :: fn(self*) -> u64 {
    if !self.root then return 0;
    current := self.root;
    len: u64;
    while current {
      len += current.length;
      current = current.next;
    }
    return len;
  }

  get_string :: fn(self*) -> c_string {
    length := self.length();
    data : u8* = malloc(length + 1);
    data[length] = '\0';
    current := self.root;
    while current {
      strncat(data, current.data, current.length);
      current = current.next;
    }
    return data;
  }

  append :: fn(self*, str: c_string) {
    if !str then return;

    if !self.root { 
        self.root = String_Builder_Block::new();
        self.current = self.root;
    }

    length := strlen(str);
    remaining := STRING_BUILDER_BLOCK_MAX_LEN - self.current.length;

    while length > 0 {
      // simple append, no overflow.
      if length <= remaining {
        strncat(self.current.data + self.current.length, str, length);
        self.current.length += length;
        break;
      } else { // append with overflow.
        strncat(self.current.data + self.current.length, str, remaining);
        self.current.length += remaining;
        str += remaining;
        length -= remaining;

        self.current.next = String_Builder_Block::new();
        self.current = self.current.next;
        remaining = STRING_BUILDER_BLOCK_MAX_LEN;
      }
    }
  }
  append_char :: fn(self*, ch: char) {
    if !self.root { 
      self.root = String_Builder_Block::new();
      self.current = self.root;
    }
    remaining := STRING_BUILDER_BLOCK_MAX_LEN - self.current.length;
    if remaining > 0 {
      self.current.data[self.current.length] = ch;
      self.current.length += 1;
    } else {
      self.current.next = String_Builder_Block::new();
      self.current = self.current.next;
      self.current.data[0] = ch;
      self.current.length = 1;
    }
  }
}

