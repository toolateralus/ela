

string :: struct;
// Run a cleanup procedure implicitly when an object goes out of scope.
// Absolutely equivalent to a C++ Destructor.
// This could be called explicitly on pointers, but it's not reccomended.
Drop        :: interface {
  drop      :: fn(self*);
}

// Allow an object to be converted to a string
ToString    :: interface {
  // convert self to string::
  to_string :: fn(self*) -> c_string;
}

// equivalent to an explicit cast operator overload in C++,
// allow an object to be constructed from another.
From        :: interface![T] {
  // construct a self type from T.
  from :: fn(v: T) -> #self;
}

// A deep clone, versus assignment always being a shallow clone in Ela.
Clone       :: interface {
  // get a deep clone of self.
  clone     :: fn(self*) -> #self;
}

// An object used to iterate over a collection of items, or any sequence.
Enumerator   :: interface![T] {  
  // Return the current value this enumerator points to within the sequence it's iterating over.  
  current   :: fn(self*) -> T;
  // Advance the enumerator by one step.
  next      :: fn(self*) -> void;
  // Check whether the enumerator is complete, or should continue.
  // return true for 'done',
  // return false if needs to continue
  done      :: fn(self*) -> bool;
}

// A collection or range of items that can be enumerated over, with a for loop, or some other means.
Enumerable   :: interface![Enum, T] where Enum is Enumerator![T] { 
  // get the Enumerator object that was implemented for this type.
  enumerator      :: fn(self*) -> Enum;
}

// Iter is a generic struct that represents an iterator over a collection of type T.
// It contains a pointer to the current element (ptr) and a pointer to the end of the collection (end).

// It differs from Enumerator because it requires an incrementable piece of memory, so it must be a contiguous collection of data
// represented by a chunk of memory that can be trivially traversed.
Iter :: struct![T] {
  ptr: T*,  // Pointer to the current element in the collection.
  end: T*,  // Pointer to the end of the collection.
}

impl![T] Iter![T] {
  // Returns a pointer to the current element in the collection.
  current :: fn(self*) -> T* => self.ptr;

  // Advances the iterator to the next element in the collection.
  next :: fn(self*) {
    self.ptr++;
  }

  // Checks if the iterator has reached the end of the collection.
  done :: fn(self*) -> bool {
    return self.ptr >= self.end || self.ptr == self.end; 
  }
}

// Iterable is a generic interface that represents a collection that can be iterated over.
// It defines a single method, iter, which returns an iterator for the collection.
Iterable :: interface![T] {
  // Returns an iterator for the collection.
  iter :: fn(self*) -> Iter![T];
}

// Binary arithmetic operator overloads.
Arithmetic :: interface![Right] {
  add       :: fn(self, right: Right) -> #self;   // '+' operator.
  sub       :: fn(self, right: Right) -> #self;   // '-' operator.
  mul       :: fn(self, right: Right) -> #self;   // '*' operator.
  div       :: fn(self, right: Right) -> #self;   // '/' operator.
  modulo    :: fn(self, right: Right) -> #self;   // '%' operator.
}

// Binary bitwise operator overloading.
Bitwise :: interface![Right] {
  shr       :: fn(self, right: Right) -> #self;   // '>>' operator.
  shl       :: fn(self, right: Right) -> #self;   // '<<' operator.
  xor       :: fn(self, right: Right) -> #self;   //  '^' operator.
  or        :: fn(self, right: Right) -> #self;   //  '|' operator.
  and       :: fn(self, right: Right) -> #self;   //  '&' operator.
}

/* 
  The compiler will construct this object when you do something like:
  list := {0, 1, 2, 3, 4};

  If you want your types to be constructible from these, implement the interface 'From![Collection_Initializer]`
  You do not have to free anything, it will always be stack allocated memory. 
  freeing the 'data' field of this will certainly crash your program.

  As was said, this is basically a wrapper for a stack allocated array of homogenous-typed values.
  Do not store a reference to this anywhere, it should only be used for constructing types that represent sequences.

  ! This is not really implemented ! 
*/
Collection_Initializer :: struct![T] {
  data:   T*,
  length: u64,
}

Init :: interface![T] {
  init :: fn(init: Collection_Initializer![T]) -> #self;
}

// Obviously LIBC is only available when not in a freestanding environment.
#ifndef FREESTANDING {
  #foreign system :: fn(cmd: c_string) -> s32;

  #foreign free :: fn(ptr: void*) -> void;
  #foreign malloc :: fn(nbytes: u64) -> void*;
  #foreign calloc :: fn(num: u64, size: u64) -> void*;
  #foreign realloc :: fn(ptr: void*, size: u64) -> void*;

  #foreign memcpy :: fn(dest: void*, src: void*, n: u64) -> void*;
  #foreign memset :: fn(dest: void*, c: s32, n: u64) -> void*;
  #foreign memmove :: fn(dest: void*, src: void*, nbytes: s64) -> s32;

  #foreign printf :: fn(format: c_string, ...) -> s32;
  #foreign exit :: fn(code: s32);

  #foreign scanf :: fn(format: c_string, ...) -> s32;
  #foreign getchar :: fn() -> s32;

  #foreign sleep :: fn(seconds: s32);
  #foreign usleep :: fn(c: s32);

  #foreign strdup :: fn(str: c_string) -> c_string;
  #foreign strndup :: fn(str: c_string, n: u64) -> c_string;
  #foreign strerror :: fn(errnum: s32) -> c_string;
  #foreign strtol :: fn(str: c_string, endptr: c_string**, base: s32) -> s64;
  #foreign strtoul :: fn(str: c_string, endptr: c_string**, base: s32) -> u64;
  #foreign strtod :: fn(str: c_string, endptr: c_string**) -> f64;
  #foreign strtok :: fn(str: c_string, delim: c_string) -> c_string;
  #foreign strchr :: fn(str: c_string, c: s32) -> c_string;
  #foreign strrchr :: fn(str: c_string, c: s32) -> c_string;
  #foreign strstr :: fn(haystack: c_string, needle: c_string) -> c_string;
  #foreign strlen :: fn(str: c_string) -> s32;
  #foreign strcmp :: fn(str1: c_string, str2: c_string) -> s32;
  #foreign strcat :: fn(dest: c_string, src: c_string) -> c_string;
  #foreign strncat :: fn(dest: c_string, src: c_string, n: u64) -> c_string;
  #foreign snprintf :: fn(buffer: u8*, buffer_size: u64, format: c_string, ...) -> s32;
  #foreign sprintf :: fn(buffer: u8*, format: c_string, ...) -> s32;
  #foreign strncmp :: fn(str: c_string, str2: c_string, len: s32) -> s32;

  #foreign isalnum :: fn(c: s32) -> s32;
  #foreign isalpha :: fn(c: s32) -> s32;
  #foreign isspace :: fn(c: s32) -> s32;
  #foreign isdigit :: fn(c: s32) -> s32;
  #foreign islower :: fn(c: s32) -> s32;
  #foreign isupper :: fn(c: s32) -> s32;
  #foreign isprint :: fn(c: s32) -> s32;
  #foreign ispunct :: fn(c: s32) -> s32;

  #foreign atoi :: fn(v: c_string) -> s32;
  #foreign atof :: fn(v: c_string) -> f64;
}

Range :: struct {
  begin: s64,
  end:   s64,
}

Range_Enumerator :: struct {
  begin: s64,
  end:   s64,
  idx:   s64,
}

impl Enumerator![s64] for Range_Enumerator {
  current   :: fn(self*) -> s64 {
    return self.idx;
  }
  next      :: fn(self*) {
    self.idx++;
  };
  done      :: fn(self*) -> bool {
    return self.idx >= self.end;
  }
}

impl Enumerable![Range_Enumerator, s64] for Range {
  enumerator :: fn(self*) -> Range_Enumerator {
    return {
      begin: self.begin,
      end:   self.end,
      idx:          0,
    };
  }
}


// Basic allocator interface. Coupled with most heap allocated structures, such as List![T] and string::
Allocator :: interface {
  allocate :: fn![T](self*) -> T*;
  free :: fn![T](self*, ptr: T*);
  allocate_array :: fn![T](self*, n: u64) -> T*;
  resize :: fn![T](self*, ptr: T*, new_size: u64) -> T*;
  copy :: fn![T](self*, ptr: T*, n: u64) -> T*;
}

// The standard allocator is only available when not in a freestanding environement.
#ifndef FREESTANDING  {
  mem_zero :: fn![T](ptr: T*, count: u64) {
    memset(ptr, 0, sizeof(T) * count);
  }
  Std_Allocator :: struct {}

  impl Allocator for Std_Allocator {
    allocate :: fn![T](self*) -> T* {
      return malloc(sizeof(T)) as T*;
    }
    free :: fn![T](self*, ptr: T*) {
      free(ptr);
    }
    allocate_array :: fn![T](self*, n: u64) -> T* {
      return calloc(sizeof(T) * n) as T*;
    }
    resize :: fn![T](self*, ptr: T*, new_size: u64) -> T* {
      return realloc(ptr, sizeof(T) * new_size) as T*;
    }
    copy :: fn![T](self*, ptr: T*, n: u64) -> T* {
      newptr : T* = self.allocate_array![T](n);
      memcpy(newptr, ptr, n * sizeof(T));
      return newptr;
    }
  }

  impl Std_Allocator {
    get :: fn() -> #self {
      #static self: #self;
      return self;
    }
  }
}

string :: struct {
  data:    u8*,
  length:  s32,
}



#ifndef FREESTANDING {
  // TODO: reimplement all the helper functions we used to have.
  // Also, we should make this not null terminated, rather controlled by length.
  // Another thing: We should use u32 or u64 for length, but you have to cast to signed 32 for all the C functions anyway,
  // So we'll have to rewrite them all for that.
  impl string {
    empty :: fn() -> #self {
      return {};
    }
    from :: fn(data: c_string) -> #self{
      if !data then return {};
      return {
        length: strlen(data),
        data: strdup(data),
      };
    }
    from_ptr :: fn(begin: c_string, end: c_string) -> string {
      str: string;
      str.length = end - begin;
      str.data = malloc(str.length + 1);
      memcpy(str.data, begin, str.length);
      str.data[str.length] = 0;
      return str;
    }
    deinit :: fn(self*) {
      free(self.data);
      self.length = 0;
    }
    subscript :: fn(self*, idx: s64) -> u8 {
      return self.data[idx];
    }
    eq :: fn(self*, other: #self) -> bool {
      if self.length != other.length then return false;
      for idx in 0..self.length {
        if (*self)[idx] != other[idx] then return false;
      }
      return true;
    }
    starts_with :: fn(self*, prefix: c_string) -> bool {
      prefix_len := strlen(prefix);
      if self.length < prefix_len then return false;
      for i in 0..prefix_len {
        if self.data[i] != prefix[i] then return false;
      }
      return true;
    }
    ends_with :: fn(self*, suffix: c_string) -> bool {
      suffix_len := strlen(suffix);
      if self.length < suffix_len then return false;
      for i in 0..suffix_len {
        if self.data[self.length - suffix_len + i] != suffix[i] then return false;
      }
      return true;
    }
    replace :: fn(self*, old: c_string, replacement: c_string) -> string {
      old_len := strlen(old);
      new_len := strlen(replacement);
      result := string::empty();
      for i in 0..self.length {
        if strncmp(self.data + i, old, old_len) == 0 {
          result.data = realloc(result.data, result.length + new_len + 1);
          memcpy(result.data + result.length, replacement, new_len);
          result.length += new_len;
          i += old_len - 1;
        } else {
          result.data = realloc(result.data, result.length + 1 + 1);
          result.data[result.length] = self.data[i];
          result.length++;
        }
      }
      result.data[result.length] = 0;
      return result;
    }
    substr :: fn(self*, start: s64, length: s64) -> string {
      if start < 0 || length < 0 || start + length > self.length then return string::empty();
      return string::from_ptr(self.data + start, self.data + start + length);
    }
  }
}

impl Iterable![u8] for string { 
  iter :: fn(self*) -> Iter![u8] {
    return {
      ptr: self.data,
      end: self.data + self.length,
    }
  }
}



#alias Panic_Handler :: fn *(c_string);

panic_handler: Panic_Handler;

set_panic_handler :: fn(handler: Panic_Handler) {
  panic_handler = handler;
}

// if you set the panic handler to null, we will set it to it's default. If you want to do nothing for a panic
// just set it to an empty function


// We do this because we're restricted to not using lambdas in the global scope, currently. Perhaps in the future we will improve this.
panic :: fn(msg: c_string) {
  if !panic_handler {
    #ifndef FREESTANDING {
      panic_handler = fn(msg: c_string) {
        printf("panic(): %s\n", msg);
        exit(1);
      };
    } else {
      panic_handler = fn(msg: c_string) {
        // idk, segfault on panic?
        n : s32 * = null;
        *n = 10;
      }
    }
  }
  panic_handler(msg);
}

// This list type, (not to be confused with a linked list) is a dynamic array, Similar to C++/Rust 'std::vector/Vec'.
// Vector nomenclature is strange and ambiguous, so I think it's a good name, just as C# did. 
// Everyone knows what you mean when you say, I have a list of items etc.

// It's just a contiguous chunk of memory that dynamically resizes to fit any data pushed/popped into and out of it.
// As any other list, taking a reference to some memory within this array has a very high likelyhood to become invalid, if and when it resizes.
// If you need a static, unchanging list of items, just use a fixed array such as `T[1024]` or `Type[MAX_BUFFER_LEN]` or whatever.

// A note about this list type: as of the time of writing this, this list will be inherently unsafe when it comes to assignment.
// A simple assignment such as 'variable := some_list' will pose a very strange problem:
// The two lists will share MEMORY, but pushing into 'variable' will NOT update the length or capacity of 'some_list'!!!!
// This is very important, because taking a view is very practical and natural, it just happens. 
// But, mutating a view, will cause you serious bugs and headaches!!

// If you want to take a deep clone, meaning copying the entire data the list points to, and having a fully detached, new instance of a list
// that mirrors the original, call '.clone()' when assigning.

// If you want to mutate a list, when passing it into a function or whatever, just pass it by pointer like you would with any other type.
// There are no magic assignment or copy constructors in this language, nor destructors, so this is just an important thing to be aware of,
// because it applies to any type you create that holds dynamic memory, and also non-pointer values.

#ifndef FREESTANDING {
  List :: struct![T] {
    data:     T*,
    length:   u64,
    capacity: u64,
  }

  impl![T] List![T] {
    slice :: fn(self*, range: Range) -> #self {
      if range.begin < 0 || range.end > self.length || range.begin > range.end {
        return {};
      }
      len := range.end - range.begin;
      slice_data: T* = malloc(sizeof(T) * len);
      memcpy(slice_data, self.data + range.begin, len);
      return {
        data: slice_data,
        length: len,
        capacity: len
      }
    }

    view :: fn(self*, range: Range) -> #self {
      if range.begin < 0 || range.end > self.length || range.begin > range.end {
        return {};
      }
      len := range.end - range.begin;
      return {
        data: self.data + range.begin,
        length: len,
        capacity: len
      }
    }

    // You should probably not call this function, and you do not need to for normal push operations.
    // In the case you want to shrink your array, you can pass in array.length or whatever you want to shrink to,
    // and this will set your length appropriately.
    resize :: fn(self*, new_capacity: u64) {
      if new_capacity < self.capacity && new_capacity < self.length then self.length = new_capacity; // Truncating.

      self.capacity = new_capacity;
      self.data = realloc(self.data, sizeof(T) * self.capacity);
      if !self.data then panic("Failed to allocate in List![{#type(T).name}]");
    }

    push   :: fn(self*, v: T) {
      if self.length + 1 >= self.capacity {
        if self.capacity == 0 then self.capacity = 4;
        self.resize(self.capacity * 2);
      }
      self.data[self.length] = v;
      self.length++;
    }

    pop    :: fn(self*) -> T {
      if self.length == 0 then panic("Attempted to pop from an empty List![{#type(T).name}]");
      value := self.data[self.length - 1];
      self.length -= 1;
      return value;
    }

    // This does not actually deinit any of members in the list.
    // We should have some compile time way to have alternatives based on a specializiation
    // like #if T: Deinit { } .. else {}

    // that causes an odd problem, though. Not really a problem, just an oddity:
    // some specializations would have functions where others would not.
    // you may expect a Type![T] to have a function and depending on a hidden where condition,
    // it may just not have it, and that would probably be a really confusing issue, where you call a known function on one generic
    // instantiation, but another jsut doesn't have it. We could have nice descriptive errors to combat this?
    deinit :: fn(self*) {
      free(self.data);
      self.data = null;
      self.length = 0;
    }

    at :: fn(self*, index: u64) -> T {
      return self.data[index];
    }
  }

  impl![T] Clone for List![T] {
    clone :: fn(self*) -> #self {
      new_data := malloc(sizeof(T) * self.capacity);
      if !new_data then panic("Failed to allocate in List clone");
      memcpy(new_data, self.data, sizeof(T) * self.length);
      return {
        data: new_data,
        length: self.length,
        capacity: self.capacity,
      }
    } 
  }

  impl![T] Iterable![T] for List![T] {
    iter :: fn(self*) -> Iter![T] {
      return {
        ptr: self.data,
        end: (self.data + self.length) as T*,
      }
    }
  }

  impl![T] List![T] {
    subscript :: fn(self*, idx: s64) -> T {
      return self.data[idx];
    }
  }

  impl![T] Init![T] for List![T] {
    init :: fn(init: Collection_Initializer![T]) -> #self {
      self: #self;
      for idx in 0..init.length {
        self.push(init.data[idx]);
      }
      return self;
    }
  }
}


#ifdef FREESTANDING  {
  Env :: struct {
    m_args: c_string*,
    length: u64,
  };
  impl Env {
    current :: fn() -> #self* {
      #static self: #self;
      return &self;
    }
    args :: fn(self*) -> (c_string*, u64) {
      return (self.m_args, self.length);
    }
    initialize :: fn(argc: s32, argv: c_string*) {
      self := #self::current();
      self.m_args = argv;
      self.length = argc;
    }
  }
} else {
  Env :: struct {
    m_args: c_string[],
  };
  impl Env {
    current :: fn() -> #self* {
      #static self: #self;
      return &self;
    }
    args :: fn() -> c_string[] {
      return #self::current().m_args.clone();
    }
    initialize :: fn(argc: s32, argv: c_string*) {
      self := #self::current();
      for i in 0..argc {
        self.m_args.push(argv[i]);
      }
    }
  }
}

#ifndef FREESTANDING {
  any :: struct {
    ptr: void*,
    type: Type*
  };

  impl any {
    new :: fn![T](t: T*) -> #self {
      #static type: Type*;
      if !type then type = #type(T);
      return {
        ptr: t,
        type: type,
      }
    }

    // return the pointer behind this any, or if the type isn't matched,
    // return null.
    cast :: fn![T](self*) -> T* {
      #static type: Type*;
      if !type then type = #type(T);
      if type != self.type then return null;
      return self.ptr as T*;
    }

    // an unchecked version of the 'cast' method.
    // this will return junk data, or worse, if you pass in the wrong type to cast to.
    // use cast anywhere you can, it's much more type safe.
    unwrap :: fn![T](self*) -> T {
      return *(self.ptr as T*);
    }
  }

  Element :: struct;
  Type :: struct;

  Field :: struct {
    name: c_string,
    type: Type*,
    size: u64,
    offset: u64,
  };

  Type :: struct {
    id: s32,                                                // the integer ID used to identify this type.
    name: c_string,                                         // the type's name.
    size: u64,                                              // sizeof(T)
    flags: u64,                                             // defined in reflection.ela and emit.cpp, the values of the flags.
    fields: List![Field],                                   // get a list of struct fields, enum variants.
    elements: fn*(c_string) -> List![Element],              // get a list of the Elements, which can be used to reflect on arrays.
    element_type: Type*,                                    // the type this type has a pointer to, is an array of, etc.
  };

  impl Field {
    set :: fn![T, T1](self*, target: T, data: T1) {
      memcpy((target as u8*) + self.offset, (&data) as u8*, sizeof(T1));
    }
    get :: fn![T](self*, source: T) -> u8* {
      return ((&source) as u8*) + self.offset;
    }
  }

  Element :: struct {
    data: u8*,
    type: Type*,
  };

  _type_info: Type*[];  
}

#ifdef LIST_TESTS {
  // TODO:
  // We need to have a way for #import'ed files to purge out their #test functions, and any code behind an #ifdef TESTING {...}
  // Right now, if you include a library, you inherit all of it's testing, which is garbage. 
  #test test_List_push_at :: fn() {
    array : List![s64];

    {
      defer array.deinit();
      for i in 0..100 {
        array.push(i);
      }
      assert("Array push failed to meet expected length", array.length == 100);
      for i in 0..100 {
        assert("array.at(i) != i", array.at(i) == i);
      }
    }

    assert("List failed to deinit", array.data == null && array.length == 0);  
  }

  #test test_List_pop :: fn() {
    array : List![s64];

    {
      defer array.deinit();
      for i in 0..100 {
        array.push(i);
      }
      for i in 0..100 {
        value := array.pop();
        assert("array.pop() != 99 - i", value == 99 - i);
      }
      assert("Array pop failed to meet expected length", array.length == 0);
    }

    assert("List failed to deinit", array.data == null && array.length == 0);
  }

  #test test_List_resize :: fn() {
    array : List![s64];

    {
      defer array.deinit();
      array.resize(2);
      assert("Array resize failed to set capacity", array.capacity == 2);
      for i in 0..2 {
        array.push(i);
      }
      assert("Array resize failed to meet expected length", array.length == 2);
    }

    assert("List failed to deinit", array.data == null && array.length == 0);
  }

  #test test_List_shrink :: fn() {
    array : List![s64];

    {
      defer array.deinit();
      for i in 0..100 {
        array.push(i);
      }
      assert("Array push failed to meet expected length", array.length == 100);

      array.resize(50);
      assert("Array shrink failed to meet expected length", array.length == 50);
      assert("Array shrink failed to set capacity", array.capacity == 50);

      for i in 0..50 {
        assert("array.at(i) != i", array.at(i) == i);
      }
    }

    assert("List failed to deinit", array.data == null && array.length == 0);
  }

  #test test_List_clone :: fn() {
    array : List![s64];
    clone : List![s64];
    {
      defer array.deinit();
      for i in 0..100 {
        array.push(i);
      }

      clone = array.clone();
      defer clone.deinit();


      assert("Array clone failed to meet expected length", clone.length == 100);
      for i in 0..100 {
        assert("lone.at(i) != i", clone.at(i) == i);
      }

      // Modify the original array and check if the clone does not reflect the changes
      array.push(100);
      assert("Clone should not reflect changes in the original array", clone.length == 100);
      assert("lone.at(100) should not exist", clone.length == 100);
    }

    assert("List failed to deinit", array.data == null && array.length == 0);
    assert("Clone List failed to deinit", clone.data == null && clone.length == 0);
  }

  #test test_List_view :: fn() {
    array : List![s64];
    view  : List![s64];
    {
      defer array.deinit();
      for i in 0..100 {
        array.push(i);
      }

      // Take a view of the array
      view = array;

      assert("Array view failed to meet expected length", view.length == 100);
      for i in 0..100 {
        assert("view.at(i) != i", view.at(i) == i);
      }

      array.push(100);
      assert("View should reflect changes in the original array", view.length == 100);
      assert("view.at(100) != 100", view.at(100) == 100);
    }

    assert("List failed to deinit", array.data == null && array.length == 0);
  }

  #test test_List_for_loop :: fn() {
    array : List![s64];

    // ! BUG: 
    // ! We have to call these explicitly before using a for loop, 
    // ! Because otherwise the generic impl never gets instantiated.
    iter := array.iter();
    iter.current();

    {
      defer array.deinit();
      for i in 0..100 {
        array.push(i);
      }

      // Test 'for v in array'
      idx := 0;
      for v in array {
        assert("for v in array failed", v == idx);
        idx++;
      }

      assert("for v in array failed to iterate correctly", idx == 100);

      // Test 'for *v in array'
      idx = 0;
      for *v in array {
        assert("for *v in array failed", *v == idx);
        idx++;
      }
      assert("for *v in array failed to iterate correctly", idx == 100);
    }

    assert("List failed to deinit", array.data == null && array.length == 0);
  }
}

/* 
  * `any` is unfinished, it's just experimental.
*/

#import reflection;
#ifndef FREESTANDING {
  // TODO: expand this, add support for other stuff.
  // This is only for numerical types, bools, and strings / any pointer.
  to_string :: fn![T](value: T) -> c_string {
    buffer: u8[64];
    type := #type(T);
    format : c_string;

    if type.is_bool() {
      if value {
        return strdup("true");
      } else {
        return strdup("false");
      }
    }

    if type.is_integral() {
      format = "%lld";
    } else if type.is_float() {
      format = "%.2lf";               //  * using to_string has a trade off of less control for slight convenience. Oh well! use snprintf instead.
    } else if type.is_string() {
      format = "%s";
    } else if type.is_pointer() {
      format = "%p";
    } else if type == #type(u8) || type == #type(u8) {
      format = "%c";
    } else {
      format = "(unsupported type)";  // * do we throw an error here? format = null?
    } 

    snprintf(buffer, sizeof(buffer), format, value);
    return strdup(buffer) as c_string;
  } 


  // TODO: remove this.
  string_concat :: fn(a: c_string, b: c_string) -> c_string {
    len_a := strlen(a);
    len_b := strlen(b);
    result := malloc(len_a + len_b + 1) as u8*;
    memcpy(result, a, len_a);
    memcpy(result + len_a, b, len_b);
    result[len_a + len_b] = '\0';
    return result as c_string;
  }

  #static print :: fn![T](str: T) {
    s := to_string(str);
    printf("%s", s);
    free(s);
  }

  #static println :: fn![T](str: T) {
    s := to_string(str)
    printf("%s\n", s);
    free(s);
  }
  // This seems pretty chunky,
  // it might be more performant for building large strings,
  // but perhaps this is a setting we can have the user pass in.
  STRING_BUILDER_BLOCK_MAX_LEN :: 8192;

  String_Builder_Block :: struct {
    data: u8*,
    length: u64,
    next: String_Builder_Block*,
  }

  impl String_Builder_Block {
    new :: fn() -> #self* {
      self : #self* =  malloc(sizeof(String_Builder_Block));
      self.data = calloc(sizeof(u8), STRING_BUILDER_BLOCK_MAX_LEN);
      return self;
    }
    deinit :: fn(self*) {
      if self.data then free(self.data);
      if self.next { 
        self.next.deinit();
        free(self.next);
      }
      self.data = null;
      self.next = null;
      self.length = 0;
    } 
  }

  String_Builder :: struct {
    root: String_Builder_Block*,
    current: String_Builder_Block*,
  }

  impl String_Builder {
    deinit :: fn(self*) {
      if self.root then self.root.deinit();
      self.root = null;
      self.current = null;
    }

    // just here for 'clarity' (no pun intended)
    clear :: fn(self*) {
      self.deinit();
    }

    length :: fn(self*) -> u64 {
      if !self.root then return 0;
      current := self.root;
      len: u64;
      while current {
        len += current.length;
        current = current.next;
      }
      return len;
    }

    get_string :: fn(self*) -> c_string {
      length := self.length();
      data : u8* = malloc(length + 1);
      data[length] = '\0'; // Null-terminate the final string
      current := self.root;
      offset := 0;
      while current {
        memcpy(data + offset, current.data, current.length);
        offset += current.length;
        current = current.next;
      }
      return data;
    }

    append :: fn(self*, str: c_string) {
      if !str then return;
      if !self.root { 
        self.root = String_Builder_Block::new();
        self.current = self.root;
      }
      length := strlen(str);
      remaining := STRING_BUILDER_BLOCK_MAX_LEN - self.current.length;
      while length > 0 {
        // Simple append, no overflow
        if length <= remaining {
          memcpy(self.current.data + self.current.length, str, length);
          self.current.length += length;
          break;
        } else { // Append with overflow
          memcpy(self.current.data + self.current.length, str, remaining);
          self.current.length += remaining;
          str += remaining;
          length -= remaining;

          self.current.next = String_Builder_Block::new();
          self.current = self.current.next;
          remaining = STRING_BUILDER_BLOCK_MAX_LEN;
        }
      }
    }

    append_then_free :: fn(self*, str: c_string) {
      self.append(str);
      free(str);
    }

    append_concat :: fn(self*, list: Collection_Initializer![c_string]) {
      for i in 0..list.length {
        self.append(list.data[i]);
      }
    }

    append_concat_then_free :: fn(self*, list: Collection_Initializer![c_string], free_list: Collection_Initializer![bool]) {
      if free_list.length != list.length {
        printf("append_concat_then_free() requires that the string initializer and the free_list are the same length\n");
        exit(1); // we shouldn't have to panic here, but whatever.
      }
      for i in 0..list.length {
        self.append(list.data[i]);
        if free_list.data[i] then free(list.data[i]);
      }
    }
    append_u8 :: fn(self*, ch: u8) {
      if !self.root { 
        self.root = String_Builder_Block::new();
        self.current = self.root;
      }
      remaining := STRING_BUILDER_BLOCK_MAX_LEN - self.current.length;
      if remaining > 0 {
        self.current.data[self.current.length] = ch;
        self.current.length += 1;
      } else {
        self.current.next = String_Builder_Block::new();
        self.current = self.current.next;
        self.current.data[0] = ch;
        self.current.length = 1;
      }
    }

    
  }

  // TODO: improve the Collection_Initializer![any] so we can implicitly take any...
  // and just have it automatically do that for us.
  // Also, doing any::new(&value) is obnoxious, we should be able to implicitly cast anything
  // to any, even literals. see any-cast.idea.c in the root of the project for how we'd
  // compile that.

  // Additionally, it would be nice to have a compile time version of this,
  // where we have a ![T...] var arg list, so we don't have to recalculate the format string every call.
  format :: fn(fmt : c_string, list: Collection_Initializer![any]) -> c_string {
    if !fmt {
      return null;
    }

    builder: String_Builder;
    value_index := 0;

    while *fmt {
      if (*fmt) == '%' && *(fmt + 1) == '%' {
        builder.append_u8('%');
        fmt += 2;
        continue;
      }

      if (*fmt) == '%' {
        value := list.data[value_index];
        if value.ptr == null {
          builder.append("null");
        } else if value.type == #type(u8*) { 
          builder.append(value.unwrap![u8*]()); 
        } else if value.type.is_pointer() {
          builder.append_then_free(to_string(value.ptr));
        } else if value.type.is_enum() {
          builder.append_then_free(to_string(value.unwrap![s32]()));
        } else {
          switch value.type {
            #type(u8):  { builder.append_then_free(to_string(value.unwrap![u8]()));  }
            #type(u16): { builder.append_then_free(to_string(value.unwrap![u16]())); }
            #type(u32): { builder.append_then_free(to_string(value.unwrap![u32]())); }
            #type(u64): { builder.append_then_free(to_string(value.unwrap![u64]())); }

            #type(s8):  { builder.append_then_free(to_string(value.unwrap![s8]()));  }
            #type(s16): { builder.append_then_free(to_string(value.unwrap![s16]())); }
            #type(s32): { builder.append_then_free(to_string(value.unwrap![s32]())); }
            #type(s64): { builder.append_then_free(to_string(value.unwrap![s64]())); }

            #type(s32): { builder.append_then_free(to_string(value.unwrap![s32]())); }

            #type(f32):    { builder.append_then_free(to_string(value.unwrap![f32]()));    }
            #type(f32):  { builder.append_then_free(to_string(value.unwrap![f32]()));  }
            #type(f64):  { builder.append_then_free(to_string(value.unwrap![f64]()));  }

            #type(bool): { builder.append_then_free(to_string(value.unwrap![bool]())); }
            
            #type(u8): { builder.append_then_free(to_string(value.unwrap![u8]())); }
          }
        }
        value_index++;
      } else {
        builder.append_u8(*fmt);
      }
      fmt++;
    }

    return builder.get_string();
  }
}

