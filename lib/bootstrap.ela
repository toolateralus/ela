// General utilities. Needs to be expanded for full libc support.

#foreign system :: fn(cmd: c_string) -> int;
#foreign printf :: fn(format: c_string, ...) -> int;
#foreign exit :: fn(code: int);


// General memory utilities. Missing a TON of them, to be expanded too.
#foreign free :: fn(ptr: void*) -> void;
#foreign malloc :: fn(nbytes: u64) -> void*;
#foreign calloc :: fn(num: u64, size: u64) -> void*;
#foreign realloc :: fn(ptr: void*, size: u64) -> void*;#foreign free :: fn(ptr: void*) -> void;

#foreign memset :: fn(dest: void*, c: int, n: u64) -> void*;
#foreign memmove :: fn(dest: void*, src: void*, nbytes: s64) -> int;
#foreign memcpy :: fn(dest: void*, src: void*, n: u64) -> void*;

#foreign strdup :: fn(str: c_string) -> c_string;
#foreign strndup :: fn(str: c_string, n: u64) -> c_string;
#foreign strerror :: fn(errnum: int) -> c_string;
#foreign strtol :: fn(str: c_string, endptr: c_string**, base: int) -> s64;
#foreign strtoul :: fn(str: c_string, endptr: c_string**, base: int) -> u64;
#foreign strtod :: fn(str: c_string, endptr: c_string**) -> float64;
#foreign strtok :: fn(str: c_string, delim: c_string) -> c_string;
#foreign strchr :: fn(str: c_string, c: int) -> c_string;
#foreign strrchr :: fn(str: c_string, c: int) -> c_string;
#foreign strstr :: fn(haystack: c_string, needle: c_string) -> c_string;
#foreign strlen :: fn(str: c_string) -> int;
#foreign strcmp :: fn(str1: c_string, str2: c_string) -> int;
#foreign strcat :: fn(dest: c_string, src: c_string) -> c_string;
#foreign snprintf :: fn(buffer: u8*, buffer_size: u64, format: c_string, ...) -> int;
#foreign sprintf :: fn(buffer: u8*, format: c_string, ...) -> int;
#foreign strncmp :: fn(str: c_string, str2: c_string, len: int) -> int;

#foreign isalnum :: fn(c: int) -> int;
#foreign isalpha :: fn(c: int) -> int;
#foreign isspace :: fn(c: int) -> int;
#foreign isdigit :: fn(c: int) -> int;
#foreign islower :: fn(c: int) -> int;
#foreign isupper :: fn(c: int) -> int;
#foreign isprint :: fn(c: int) -> int;
#foreign ispunct :: fn(c: int) -> int;

// TODO: fix the mismatch in signedness.
string :: struct {
  data:    char*;
  length:  s32;
}

Env :: struct {};

impl Env {
  args :: fn() -> string[]* {
    #static values: string[];
    return &values;
  }
}

impl string {
  empty :: fn() -> #self {
    return {};
  }
  from :: fn(data: c_string) -> #self{
    len := strlen(data);
    str: string;
    str.data = strdup(data);
    str.length = len;
    return str;
  }
  from_ptr :: fn(begin: c_string, end: c_string) -> string {
    str: string;
    str.length = end - begin;
    str.data = malloc(str.length + 1);
    memcpy(str.data, begin, str.length);
    str.data[str.length] = 0;
    return str;
  }
}
