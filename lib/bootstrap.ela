// General utilities. Needs to be expanded for full libc support.

#foreign system :: fn(cmd: c_string) -> int;
#foreign printf :: fn(format: c_string, ...) -> int;
#foreign exit :: fn(code: int);


// General memory utilities. Missing a TON of them, to be expanded too.
#foreign free :: fn(ptr: void*) -> void;
#foreign malloc :: fn(nbytes: u64) -> void*;
#foreign calloc :: fn(num: u64, size: u64) -> void*;
#foreign realloc :: fn(ptr: void*, size: u64) -> void*;#foreign free :: fn(ptr: void*) -> void;

#foreign memset :: fn(dest: void*, c: int, n: u64) -> void*;
#foreign memmove :: fn(dest: void*, src: void*, nbytes: s64) -> int;
#foreign memcpy :: fn(dest: void*, src: void*, n: u64) -> void*;

#foreign strdup :: fn(str: c_string) -> c_string;
#foreign strndup :: fn(str: c_string, n: u64) -> c_string;
#foreign strerror :: fn(errnum: int) -> c_string;
#foreign strtol :: fn(str: c_string, endptr: c_string**, base: int) -> s64;
#foreign strtoul :: fn(str: c_string, endptr: c_string**, base: int) -> u64;
#foreign strtod :: fn(str: c_string, endptr: c_string**) -> float64;
#foreign strtok :: fn(str: c_string, delim: c_string) -> c_string;
#foreign strchr :: fn(str: c_string, c: int) -> c_string;
#foreign strrchr :: fn(str: c_string, c: int) -> c_string;
#foreign strstr :: fn(haystack: c_string, needle: c_string) -> c_string;
#foreign strlen :: fn(str: c_string) -> int;
#foreign strcmp :: fn(str1: c_string, str2: c_string) -> int;
#foreign strcat :: fn(dest: c_string, src: c_string) -> c_string;
#foreign snprintf :: fn(buffer: u8*, buffer_size: u64, format: c_string, ...) -> int;
#foreign sprintf :: fn(buffer: u8*, format: c_string, ...) -> int;
#foreign strncmp :: fn(str: c_string, str2: c_string, len: int) -> int;

#foreign isalnum :: fn(c: int) -> int;
#foreign isalpha :: fn(c: int) -> int;
#foreign isspace :: fn(c: int) -> int;
#foreign isdigit :: fn(c: int) -> int;
#foreign islower :: fn(c: int) -> int;
#foreign isupper :: fn(c: int) -> int;
#foreign isprint :: fn(c: int) -> int;
#foreign ispunct :: fn(c: int) -> int;

// TODO: fix the mismatch in signedness.
string :: struct {
  data:    char*;
  length:  s32;
}

Env :: struct {};

impl Env {
  args :: fn() -> string[]* {
    #static values: string[];
    return &values;
  }
}

impl string {
  empty :: fn() -> #self {
    return {};
  }
  from :: fn(data: c_string) -> #self{
    len := strlen(data);
    str: string;
    str.data = strdup(data);
    str.length = len;
    return str;
  }
  from_ptr :: fn(begin: c_string, end: c_string) -> string {
    str: string;
    str.length = end - begin;
    str.data = malloc(str.length + 1);
    memcpy(str.data, begin, str.length);
    str.data[str.length] = 0;
    return str;
  }
}


#foreign printf :: fn(s: c_string, ...) -> int;


Range_Base :: struct![T] {
  begin: T;
  end:   T;
}

#alias Range :: Range_Base![s64];

// An object used to iterate over a collection of items, or any sequence.
Enumerator   :: interface![T] {  
  // Return the current value this enumerator points to within the sequence it's iterating over.  
  current   :: fn(self*) -> T;
  // Advance the enumerator by one step.
  next      :: fn(self*) -> void;
  // Check whether the enumerator is complete, or should continue.
  // return true for 'done',
  // return false if needs to continue
  done      :: fn(self*) -> bool;
}

// A collection or range of items that can be enumerated over, with a for loop, or some other means.
Enumerable   :: interface![Enum, T] where Enum is Enumerator![T] { 
  // get the Enumerator object that was implemented for this type.
  enumerator      :: fn(self*) -> Enum;
}

// TODO: support reverse enumeration for this as well.
Range_Base_Enumerator :: struct![T] {
  begin: T;
  end:   T;
  idx:   T;
}

impl Enumerator![T] for Range_Base_Enumerator {
  current   :: fn(self*) -> s64 {
    return self.idx;
  }
  next      :: fn(self*) {
    self.idx++;
  };
  done      :: fn(self*) -> bool {
    return self.idx >= self.end;
  }
}

impl![T] Enumerable![Range_Base_Enumerator, T] for Range_Base {
  enumerator :: fn(self*) -> Range_Base_Enumerator {
    return {
      begin: self.first,
      end: self.last,
      idx: 0,
    };
  }
}
