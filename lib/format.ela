#import builder;

// TODO: expand this, add support for other stuff.
// This is only for numerical types, bools, and strings / any pointer.
// We kinda need generic specialization to do more with this.
to_string :: fn![T](value: T) -> String {
  buffer: u8[64];
  type := #type(T);
  format : str;
  
  if type.is_bool() {
    if value {
      return "true".as_string();
    } else {
      return "false".as_string();
    }
  }

  if type.is_enum() {
    for field in type.fields {
      if value == field.enum_value {
        return String::from(field.name);
      }
    }
  }


  if type == #type(u8) {
    format = "%c";
  } else if type.is_integral() {
    format = "%lld";
  } else if type.is_float() {
    format = "%.2lf";               //  * using to_string has a trade off of less control for slight convenience. Oh well! use snprintf instead.
  } else if type.is_string() {
    format = "%s";
  } else if type.is_pointer() {
    format = "%p";
  } else {
    format = "(unsupported type)";  // * do we throw an error here? format = null?
  } 

  snprintf(buffer, 64 * sizeof(u8), format.data, value);
  return String::from(strdup(buffer));
} 

format :: fn(fmt : str, list: Init_List![any]) -> String {
  if fmt.length == 0 {
    return {};
  }

  builder: String_Builder;
  value_index := 0;

  while *fmt.data {
    if (*fmt.data) == '%' && *(fmt.data + 1) == '%' {
      builder.append![u32]('%');
      fmt.data += 2;
      continue;
    }

    if (*fmt.data) == '%' {
      value := list.data[value_index];
      if value.ptr == null {
        builder.append("null");
      } else if value.type == #type(u8*) { 
        builder.append(String::from(value.unwrap![u8*]())); 
      } else if value.type.is_pointer() {
        builder.append_then_free(to_string(value.ptr));
      } else if value.type.is_enum() {
        builder.append_then_free(to_string(value.unwrap![s32]()));
      } else {
        switch value.type {
          #type(u8):  { builder.append_then_free(to_string(value.unwrap![u8]()));  }
          #type(u16): { builder.append_then_free(to_string(value.unwrap![u16]())); }
          #type(u32): { builder.append_then_free(to_string(value.unwrap![u32]())); }
          #type(u64): { builder.append_then_free(to_string(value.unwrap![u64]())); }

          #type(s8):  { builder.append_then_free(to_string(value.unwrap![s8]()));  }
          #type(s16): { builder.append_then_free(to_string(value.unwrap![s16]())); }
          #type(s32): { builder.append_then_free(to_string(value.unwrap![s32]())); }
          #type(s64): { builder.append_then_free(to_string(value.unwrap![s64]())); }

          #type(s32): { builder.append_then_free(to_string(value.unwrap![s32]())); }

          #type(f32):    { builder.append_then_free(to_string(value.unwrap![f32]()));    }
          #type(f32):  { builder.append_then_free(to_string(value.unwrap![f32]()));  }
          #type(f64):  { builder.append_then_free(to_string(value.unwrap![f64]()));  }

          #type(bool): { builder.append_then_free(to_string(value.unwrap![bool]())); }
          #type(String): { builder.append(*(value.ptr as String*));   }
          #type(str): { builder.append((*(value.ptr as str*)).as_string());   }
        }
      }
      value_index++;
    } else {
      builder.append((*fmt.data) as u32);
    }
    fmt.data++;
  }

  return builder.get_string();
}

#static print :: fn![T](message: T) {
  formatted := format("%", {any::new(&message)});
  printf("%s"c, formatted.data);
  formatted.deinit();
}

#static println :: fn![T](message: T) {
  formatted := format("%", {any::new(&message)});
  printf("%s\n"c, formatted.data);
  formatted.deinit();
}

// format, print, and deinit a String via `format` function.
#static printlnf :: fn(fmt: str, list: Init_List![any]) {
  formatted := format(fmt, list);
  printf("%s\n"c, formatted.data);
  formatted.deinit();
}
