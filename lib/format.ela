// TODO: expand this, add support for other stuff.
// This is only for numerical types, bools, and strings / any pointer.
// We kinda need generic specialization to do more with this.
to_string :: fn![T](value: T) -> String {
  buffer: u8[64];
  type := #type(T);
  format : str;

  if type.is_bool() {
    if value {
      return "true".as_string();
    } else {
      return "false".as_string();
    }
  }

  if type == #type(u8) {
    format = "%c";
  } else if type.is_integral() {
    format = "%lld";
  } else if type.is_float() {
    format = "%.2lf";               //  * using to_string has a trade off of less control for slight convenience. Oh well! use snprintf instead.
  } else if type.is_string() {
    format = "%s";
  } else if type.is_pointer() {
    format = "%p";
  } else {
    format = "(unsupported type)";  // * do we throw an error here? format = null?
  } 

  snprintf(buffer, sizeof(buffer), format.data, value);
  return String::from(strdup(buffer));
} 

// TODO: remove this.
string_concat :: fn(a: u8*, b: u8*) -> u8* {
  len_a := strlen(a);
  len_b := strlen(b);
  result := malloc(sizeof(u8) * (len_a + len_b + 1)) as u8*;
  memcpy(result, a, len_a);
  memcpy(result + len_a, b, len_b);
  result[len_a + len_b] = '\0';
  return result as u8*;
}

#static print :: fn![T](str: T) {
  s := to_string(str);
  printf("%s", s);
  free(s);
}

#static println :: fn![T](str: T) {
  s := to_string(str)
  printf("%s\n", s);
  free(s);
}

// TODO: improve the Collection_Initializer![any] so we can implicitly take any...
// and just have it automatically do that for us.
// Also, doing any::new(&value) is obnoxious, we should be able to implicitly cast anything
// to any, even literals. see any-cast.idea.c in the root of the project for how we'd
// compile that.

// Additionally, it would be nice to have a compile time version of this,
// where we have a ![T...] var arg list, so we don't have to recalculate the format str every call.
format :: fn(fmt : u8*, list: Collection_Initializer![any]) -> String {
  if !fmt {
    return {};
  }

  builder: String_Builder;
  value_index := 0;

  while *fmt {
    if (*fmt) == '%' && *(fmt + 1) == '%' {
      builder.append![u32]('%');
      fmt += 2;
      continue;
    }

    if (*fmt) == '%' {
      value := list.data[value_index];
      if value.ptr == null {
        builder.append("null");
      } else if value.type == #type(u8*) { 
        builder.append(String::from(value.unwrap![u8*]())); 
      } else if value.type.is_pointer() {
        builder.append_then_free(to_string(value.ptr));
      } else if value.type.is_enum() {
        builder.append_then_free(to_string(value.unwrap![s32]()));
      } else {
        switch value.type {
          #type(u8):  { builder.append_then_free(to_string(value.unwrap![u8]()));  }
          #type(u16): { builder.append_then_free(to_string(value.unwrap![u16]())); }
          #type(u32): { builder.append_then_free(to_string(value.unwrap![u32]())); }
          #type(u64): { builder.append_then_free(to_string(value.unwrap![u64]())); }

          #type(s8):  { builder.append_then_free(to_string(value.unwrap![s8]()));  }
          #type(s16): { builder.append_then_free(to_string(value.unwrap![s16]())); }
          #type(s32): { builder.append_then_free(to_string(value.unwrap![s32]())); }
          #type(s64): { builder.append_then_free(to_string(value.unwrap![s64]())); }

          #type(s32): { builder.append_then_free(to_string(value.unwrap![s32]())); }

          #type(f32):    { builder.append_then_free(to_string(value.unwrap![f32]()));    }
          #type(f32):  { builder.append_then_free(to_string(value.unwrap![f32]()));  }
          #type(f64):  { builder.append_then_free(to_string(value.unwrap![f64]()));  }

          #type(bool): { builder.append_then_free(to_string(value.unwrap![bool]())); }

        }
      }
      value_index++;
    } else {
      builder.append_char(*fmt);
    }
    fmt++;
  }

  return builder.get_string();
}