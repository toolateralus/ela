#import builder;
// TODO: expand this, add support for other stuff.
// This is only for numerical types, bools, and strings / any pointer.
// We kinda need generic specialization to do more with this.

to_string :: fn![T](value: T) -> String {
  buffer: u8[64];
  type := #type(T);
  format : str;
  
  if type.is_bool() {
    if value {
      return "true".as_string();
    } else {
      return "false".as_string();
    }
  }

  if type == #type(u8) {
    format = "%c";
  } else if type.is_integral() {
    format = "%lld";
  } else if type.is_float() {
    format = "%.2lf";               //  * using to_string has a trade off of less control for slight convenience. Oh well! use snprintf instead.
  } else if type.is_string() {
    format = "%s";
  } else if type.is_pointer() {
    format = "%p";
  } else {
    format = "(unsupported type)";  // * do we throw an error here? format = null?
  } 

  snprintf(buffer, sizeof(buffer), format.data, value);
  return String::from(strdup(buffer));
} 

#static print :: fn![T](str: T) {
  s := to_string(str);
  printf("%s", s);
  free(s);
}

#static println :: fn![T](str: T) {
  s := to_string(str)
  printf("%s\n", s);
  free(s);
}

format :: fn(fmt : u8*, list: Init_List![any]) -> String {
  if !fmt {
    return {};
  }

  builder: String_Builder;
  value_index := 0;

  while *fmt {
    if (*fmt) == '%' && *(fmt + 1) == '%' {
      builder.append![u32]('%');
      fmt += 2;
      continue;
    }

    if (*fmt) == '%' {
      value := list.data[value_index];
      if value.ptr == null {
        builder.append("null");
      } else if value.type == #type(u8*) { 
        builder.append(String::from(value.unwrap![u8*]())); 
      } else if value.type.is_pointer() {
        builder.append_then_free(to_string(value.ptr));
      } else if value.type.is_enum() {
        builder.append_then_free(to_string(value.unwrap![s32]()));
      } else {
        switch value.type {
          #type(u8):  { builder.append_then_free(to_string(value.unwrap![u8]()));  }
          #type(u16): { builder.append_then_free(to_string(value.unwrap![u16]())); }
          #type(u32): { builder.append_then_free(to_string(value.unwrap![u32]())); }
          #type(u64): { builder.append_then_free(to_string(value.unwrap![u64]())); }

          #type(s8):  { builder.append_then_free(to_string(value.unwrap![s8]()));  }
          #type(s16): { builder.append_then_free(to_string(value.unwrap![s16]())); }
          #type(s32): { builder.append_then_free(to_string(value.unwrap![s32]())); }
          #type(s64): { builder.append_then_free(to_string(value.unwrap![s64]())); }

          #type(s32): { builder.append_then_free(to_string(value.unwrap![s32]())); }

          #type(f32):    { builder.append_then_free(to_string(value.unwrap![f32]()));    }
          #type(f32):  { builder.append_then_free(to_string(value.unwrap![f32]()));  }
          #type(f64):  { builder.append_then_free(to_string(value.unwrap![f64]()));  }

          #type(bool): { builder.append_then_free(to_string(value.unwrap![bool]())); }

        }
      }
      value_index++;
    } else {
      builder.append((*fmt) as u32);
    }
    fmt++;
  }

  return builder.get_string();
}