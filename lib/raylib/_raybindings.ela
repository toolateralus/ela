/*
  These bindings were auto generated by 'ela-bindings-generator'. 
*/
Vector2 :: struct {
  x : float32;
  y : float32;
};
Vector3 :: struct {
  x : float32;
  y : float32;
  z : float32;
};
Vector4 :: struct {
  x : float32;
  y : float32;
  z : float32;
  w : float32;
};
#alias Quaternion :: Vector4;
Matrix :: struct {
  m0 : float32;
  m4 : float32;
  m8 : float32;
  m12 : float32;
  m1 : float32;
  m5 : float32;
  m9 : float32;
  m13 : float32;
  m2 : float32;
  m6 : float32;
  m10 : float32;
  m14 : float32;
  m3 : float32;
  m7 : float32;
  m11 : float32;
  m15 : float32;
};
Color :: struct {
  r : u8;
  g : u8;
  b : u8;
  a : u8;
};


Rectangle :: struct {
  x : float32;
  y : float32;
  width : float32;
  height : float32;
};
Image :: struct {
  data : void *;
  width : s32;
  height : s32;
  mipmaps : s32;
  format : s32;
};
Texture :: struct {
  id : u32;
  width : s32;
  height : s32;
  mipmaps : s32;
  format : s32;
};
#alias Texture2D :: Texture;
#alias TextureCubemap :: Texture;
RenderTexture :: struct {
  id : u32;
  texture : Texture;
  depth : Texture;
};
#alias RenderTexture2D :: RenderTexture;
NPatchInfo :: struct {
  source : Rectangle;
  left : s32;
  top : s32;
  right : s32;
  bottom : s32;
  layout : s32;
};
GlyphInfo :: struct {
  value : s32;
  offsetX : s32;
  offsetY : s32;
  advanceX : s32;
  image : Image;
};
Font :: struct {
  baseSize : s32;
  glyphCount : s32;
  glyphPadding : s32;
  texture : Texture2D;
  recs : Rectangle *;
  glyphs : GlyphInfo *;
};
Camera3D :: struct {
  position : Vector3;
  target : Vector3;
  up : Vector3;
  fovy : float32;
  projection : s32;
};
#alias Camera :: Camera3D;
Camera2D :: struct {
  offset : Vector2;
  target : Vector2;
  rotation : float32;
  zoom : float32;
};
Mesh :: struct {
  vertexCount : s32;
  triangleCount : s32;
  vertices : float32 *;
  texcoords : float32 *;
  texcoords2 : float32 *;
  normals : float32 *;
  tangents : float32 *;
  colors : u8 *;
  indices : u16 *;
  animVertices : float32 *;
  animNormals : float32 *;
  boneIds : u8 *;
  boneWeights : float32 *;
  boneMatrices : Matrix *;
  boneCount : s32;
  vaoId : u32;
  vboId : u32 *;
};
Shader :: struct {
  id : u32;
  locs : s32 *;
};
MaterialMap :: struct {
  texture : Texture2D;
  color : Color;
  value : float32;
};
Material :: struct {
  shader : Shader;
  maps : MaterialMap *;
  params : float32[4];
};
Transform :: struct {
  translation : Vector3;
  rotation : Quaternion;
  scale : Vector3;
};
BoneInfo :: struct {
  name : u8[32];
  parent : s32;
};
Model :: struct {
  transform : Matrix;
  meshCount : s32;
  materialCount : s32;
  meshes : Mesh *;
  materials : Material *;
  meshMaterial : s32 *;
  boneCount : s32;
  bones : BoneInfo *;
  bindPose : Transform *;
};
ModelAnimation :: struct {
  boneCount : s32;
  frameCount : s32;
  bones : BoneInfo *;
  framePoses : Transform * *;
  name : u8[32];
};
Ray :: struct {
  position : Vector3;
  direction : Vector3;
};
RayCollision :: struct {
  hit : bool;
  distance : float32;
  point : Vector3;
  normal : Vector3;
};
BoundingBox :: struct {
  min : Vector3;
  max : Vector3;
};
Wave :: struct {
  frameCount : u32;
  sampleRate : u32;
  sampleSize : u32;
  channels : u32;
  data : void *;
};
rAudioBuffer :: struct {
};
rAudioProcessor :: struct {
};
AudioStream :: struct {
  buffer : rAudioBuffer *;
  processor : rAudioProcessor *;
  sampleRate : u32;
  sampleSize : u32;
  channels : u32;
};
Sound :: struct {
  stream : AudioStream;
  frameCount : u32;
};
Music :: struct {
  stream : AudioStream;
  frameCount : u32;
  looping : bool;
  ctxType : s32;
  ctxData : void *;
};
VrDeviceInfo :: struct {
  hResolution : s32;
  vResolution : s32;
  hScreenSize : float32;
  vScreenSize : float32;
  eyeToScreenDistance : float32;
  lensSeparationDistance : float32;
  interpupillaryDistance : float32;
  lensDistortionValues : float32[4];
  chromaAbCorrection : float32[4];
};
VrStereoConfig :: struct {
  projection : Matrix[2];
  viewOffset : Matrix[2];
  leftLensCenter : float32[2];
  rightLensCenter : float32[2];
  leftScreenCenter : float32[2];
  rightScreenCenter : float32[2];
  scale : float32[2];
  scaleIn : float32[2];
};
FilePathList :: struct {
  capacity : u32;
  count : u32;
  paths : u8 * *;
};
AutomationEvent :: struct {
  frame : u32;
  type : u32;
  params : s32[4];
};
AutomationEventList :: struct {
  capacity : u32;
  count : u32;
  events : AutomationEvent *;
};
ConfigFlags :: enum {
  FLAG_VSYNC_HINT = 64,
  FLAG_FULLSCREEN_MODE = 2,
  FLAG_WINDOW_RESIZABLE = 4,
  FLAG_WINDOW_UNDECORATED = 8,
  FLAG_WINDOW_HIDDEN = 128,
  FLAG_WINDOW_MINIMIZED = 512,
  FLAG_WINDOW_MAXIMIZED = 1024,
  FLAG_WINDOW_UNFOCUSED = 2048,
  FLAG_WINDOW_TOPMOST = 4096,
  FLAG_WINDOW_ALWAYS_RUN = 256,
  FLAG_WINDOW_TRANSPARENT = 16,
  FLAG_WINDOW_HIGHDPI = 8192,
  FLAG_WINDOW_MOUSE_PASSTHROUGH = 16384,
  FLAG_BORDERLESS_WINDOWED_MODE = 32768,
  FLAG_MSAA_4X_HINT = 32,
  FLAG_INTERLACED_HINT = 65536,
};
TraceLogLevel :: enum {
  LOG_ALL = 0,
  LOG_TRACE = 1,
  LOG_DEBUG = 2,
  LOG_INFO = 3,
  LOG_WARNING = 4,
  LOG_ERROR = 5,
  LOG_FATAL = 6,
  LOG_NONE = 7,
};
KeyboardKey :: enum {
  KEY_NULL = 0,
  KEY_APOSTROPHE = 39,
  KEY_COMMA = 44,
  KEY_MINUS = 45,
  KEY_PERIOD = 46,
  KEY_SLASH = 47,
  KEY_ZERO = 48,
  KEY_ONE = 49,
  KEY_TWO = 50,
  KEY_THREE = 51,
  KEY_FOUR = 52,
  KEY_FIVE = 53,
  KEY_SIX = 54,
  KEY_SEVEN = 55,
  KEY_EIGHT = 56,
  KEY_NINE = 57,
  KEY_SEMICOLON = 59,
  KEY_EQUAL = 61,
  KEY_A = 65,
  KEY_B = 66,
  KEY_C = 67,
  KEY_D = 68,
  KEY_E = 69,
  KEY_F = 70,
  KEY_G = 71,
  KEY_H = 72,
  KEY_I = 73,
  KEY_J = 74,
  KEY_K = 75,
  KEY_L = 76,
  KEY_M = 77,
  KEY_N = 78,
  KEY_O = 79,
  KEY_P = 80,
  KEY_Q = 81,
  KEY_R = 82,
  KEY_S = 83,
  KEY_T = 84,
  KEY_U = 85,
  KEY_V = 86,
  KEY_W = 87,
  KEY_X = 88,
  KEY_Y = 89,
  KEY_Z = 90,
  KEY_LEFT_BRACKET = 91,
  KEY_BACKSLASH = 92,
  KEY_RIGHT_BRACKET = 93,
  KEY_GRAVE = 96,
  KEY_SPACE = 32,
  KEY_ESCAPE = 256,
  KEY_ENTER = 257,
  KEY_TAB = 258,
  KEY_BACKSPACE = 259,
  KEY_INSERT = 260,
  KEY_DELETE = 261,
  KEY_RIGHT = 262,
  KEY_LEFT = 263,
  KEY_DOWN = 264,
  KEY_UP = 265,
  KEY_PAGE_UP = 266,
  KEY_PAGE_DOWN = 267,
  KEY_HOME = 268,
  KEY_END = 269,
  KEY_CAPS_LOCK = 280,
  KEY_SCROLL_LOCK = 281,
  KEY_NUM_LOCK = 282,
  KEY_PRINT_SCREEN = 283,
  KEY_PAUSE = 284,
  KEY_F1 = 290,
  KEY_F2 = 291,
  KEY_F3 = 292,
  KEY_F4 = 293,
  KEY_F5 = 294,
  KEY_F6 = 295,
  KEY_F7 = 296,
  KEY_F8 = 297,
  KEY_F9 = 298,
  KEY_F10 = 299,
  KEY_F11 = 300,
  KEY_F12 = 301,
  KEY_LEFT_SHIFT = 340,
  KEY_LEFT_CONTROL = 341,
  KEY_LEFT_ALT = 342,
  KEY_LEFT_SUPER = 343,
  KEY_RIGHT_SHIFT = 344,
  KEY_RIGHT_CONTROL = 345,
  KEY_RIGHT_ALT = 346,
  KEY_RIGHT_SUPER = 347,
  KEY_KB_MENU = 348,
  KEY_KP_0 = 320,
  KEY_KP_1 = 321,
  KEY_KP_2 = 322,
  KEY_KP_3 = 323,
  KEY_KP_4 = 324,
  KEY_KP_5 = 325,
  KEY_KP_6 = 326,
  KEY_KP_7 = 327,
  KEY_KP_8 = 328,
  KEY_KP_9 = 329,
  KEY_KP_DECIMAL = 330,
  KEY_KP_DIVIDE = 331,
  KEY_KP_MULTIPLY = 332,
  KEY_KP_SUBTRACT = 333,
  KEY_KP_ADD = 334,
  KEY_KP_ENTER = 335,
  KEY_KP_EQUAL = 336,
  KEY_BACK = 4,
  KEY_MENU = 5,
  KEY_VOLUME_UP = 24,
  KEY_VOLUME_DOWN = 25,
};
MouseButton :: enum {
  MOUSE_BUTTON_LEFT = 0,
  MOUSE_BUTTON_RIGHT = 1,
  MOUSE_BUTTON_MIDDLE = 2,
  MOUSE_BUTTON_SIDE = 3,
  MOUSE_BUTTON_EXTRA = 4,
  MOUSE_BUTTON_FORWARD = 5,
  MOUSE_BUTTON_BACK = 6,
};
MouseCursor :: enum {
  MOUSE_CURSOR_DEFAULT = 0,
  MOUSE_CURSOR_ARROW = 1,
  MOUSE_CURSOR_IBEAM = 2,
  MOUSE_CURSOR_CROSSHAIR = 3,
  MOUSE_CURSOR_POINTING_HAND = 4,
  MOUSE_CURSOR_RESIZE_EW = 5,
  MOUSE_CURSOR_RESIZE_NS = 6,
  MOUSE_CURSOR_RESIZE_NWSE = 7,
  MOUSE_CURSOR_RESIZE_NESW = 8,
  MOUSE_CURSOR_RESIZE_ALL = 9,
  MOUSE_CURSOR_NOT_ALLOWED = 10,
};
GamepadButton :: enum {
  GAMEPAD_BUTTON_UNKNOWN = 0,
  GAMEPAD_BUTTON_LEFT_FACE_UP = 1,
  GAMEPAD_BUTTON_LEFT_FACE_RIGHT = 2,
  GAMEPAD_BUTTON_LEFT_FACE_DOWN = 3,
  GAMEPAD_BUTTON_LEFT_FACE_LEFT = 4,
  GAMEPAD_BUTTON_RIGHT_FACE_UP = 5,
  GAMEPAD_BUTTON_RIGHT_FACE_RIGHT = 6,
  GAMEPAD_BUTTON_RIGHT_FACE_DOWN = 7,
  GAMEPAD_BUTTON_RIGHT_FACE_LEFT = 8,
  GAMEPAD_BUTTON_LEFT_TRIGGER_1 = 9,
  GAMEPAD_BUTTON_LEFT_TRIGGER_2 = 10,
  GAMEPAD_BUTTON_RIGHT_TRIGGER_1 = 11,
  GAMEPAD_BUTTON_RIGHT_TRIGGER_2 = 12,
  GAMEPAD_BUTTON_MIDDLE_LEFT = 13,
  GAMEPAD_BUTTON_MIDDLE = 14,
  GAMEPAD_BUTTON_MIDDLE_RIGHT = 15,
  GAMEPAD_BUTTON_LEFT_THUMB = 16,
  GAMEPAD_BUTTON_RIGHT_THUMB = 17,
};
GamepadAxis :: enum {
  GAMEPAD_AXIS_LEFT_X = 0,
  GAMEPAD_AXIS_LEFT_Y = 1,
  GAMEPAD_AXIS_RIGHT_X = 2,
  GAMEPAD_AXIS_RIGHT_Y = 3,
  GAMEPAD_AXIS_LEFT_TRIGGER = 4,
  GAMEPAD_AXIS_RIGHT_TRIGGER = 5,
};
MaterialMapIndex :: enum {
  MATERIAL_MAP_ALBEDO = 0,
  MATERIAL_MAP_METALNESS = 1,
  MATERIAL_MAP_NORMAL = 2,
  MATERIAL_MAP_ROUGHNESS = 3,
  MATERIAL_MAP_OCCLUSION = 4,
  MATERIAL_MAP_EMISSION = 5,
  MATERIAL_MAP_HEIGHT = 6,
  MATERIAL_MAP_CUBEMAP = 7,
  MATERIAL_MAP_IRRADIANCE = 8,
  MATERIAL_MAP_PREFILTER = 9,
  MATERIAL_MAP_BRDF = 10,
};
ShaderLocationIndex :: enum {
  SHADER_LOC_VERTEX_POSITION = 0,
  SHADER_LOC_VERTEX_TEXCOORD01 = 1,
  SHADER_LOC_VERTEX_TEXCOORD02 = 2,
  SHADER_LOC_VERTEX_NORMAL = 3,
  SHADER_LOC_VERTEX_TANGENT = 4,
  SHADER_LOC_VERTEX_COLOR = 5,
  SHADER_LOC_MATRIX_MVP = 6,
  SHADER_LOC_MATRIX_VIEW = 7,
  SHADER_LOC_MATRIX_PROJECTION = 8,
  SHADER_LOC_MATRIX_MODEL = 9,
  SHADER_LOC_MATRIX_NORMAL = 10,
  SHADER_LOC_VECTOR_VIEW = 11,
  SHADER_LOC_COLOR_DIFFUSE = 12,
  SHADER_LOC_COLOR_SPECULAR = 13,
  SHADER_LOC_COLOR_AMBIENT = 14,
  SHADER_LOC_MAP_ALBEDO = 15,
  SHADER_LOC_MAP_METALNESS = 16,
  SHADER_LOC_MAP_NORMAL = 17,
  SHADER_LOC_MAP_ROUGHNESS = 18,
  SHADER_LOC_MAP_OCCLUSION = 19,
  SHADER_LOC_MAP_EMISSION = 20,
  SHADER_LOC_MAP_HEIGHT = 21,
  SHADER_LOC_MAP_CUBEMAP = 22,
  SHADER_LOC_MAP_IRRADIANCE = 23,
  SHADER_LOC_MAP_PREFILTER = 24,
  SHADER_LOC_MAP_BRDF = 25,
  SHADER_LOC_VERTEX_BONEIDS = 26,
  SHADER_LOC_VERTEX_BONEWEIGHTS = 27,
  SHADER_LOC_BONE_MATRICES = 28,
  SHADER_LOC_VERTEX_INSTANCE_TX = 29,
};
ShaderUniformDataType :: enum {
  SHADER_UNIFORM_FLOAT = 0,
  SHADER_UNIFORM_VEC2 = 1,
  SHADER_UNIFORM_VEC3 = 2,
  SHADER_UNIFORM_VEC4 = 3,
  SHADER_UNIFORM_INT = 4,
  SHADER_UNIFORM_IVEC2 = 5,
  SHADER_UNIFORM_IVEC3 = 6,
  SHADER_UNIFORM_IVEC4 = 7,
  SHADER_UNIFORM_UINT = 8,
  SHADER_UNIFORM_UIVEC2 = 9,
  SHADER_UNIFORM_UIVEC3 = 10,
  SHADER_UNIFORM_UIVEC4 = 11,
  SHADER_UNIFORM_SAMPLER2D = 12,
};
ShaderAttributeDataType :: enum {
  SHADER_ATTRIB_FLOAT = 0,
  SHADER_ATTRIB_VEC2 = 1,
  SHADER_ATTRIB_VEC3 = 2,
  SHADER_ATTRIB_VEC4 = 3,
};
PixelFormat :: enum {
  PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1,
  PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = 2,
  PIXELFORMAT_UNCOMPRESSED_R5G6B5 = 3,
  PIXELFORMAT_UNCOMPRESSED_R8G8B8 = 4,
  PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = 5,
  PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = 6,
  PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = 7,
  PIXELFORMAT_UNCOMPRESSED_R32 = 8,
  PIXELFORMAT_UNCOMPRESSED_R32G32B32 = 9,
  PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = 10,
  PIXELFORMAT_UNCOMPRESSED_R16 = 11,
  PIXELFORMAT_UNCOMPRESSED_R16G16B16 = 12,
  PIXELFORMAT_UNCOMPRESSED_R16G16B16A16 = 13,
  PIXELFORMAT_COMPRESSED_DXT1_RGB = 14,
  PIXELFORMAT_COMPRESSED_DXT1_RGBA = 15,
  PIXELFORMAT_COMPRESSED_DXT3_RGBA = 16,
  PIXELFORMAT_COMPRESSED_DXT5_RGBA = 17,
  PIXELFORMAT_COMPRESSED_ETC1_RGB = 18,
  PIXELFORMAT_COMPRESSED_ETC2_RGB = 19,
  PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = 20,
  PIXELFORMAT_COMPRESSED_PVRT_RGB = 21,
  PIXELFORMAT_COMPRESSED_PVRT_RGBA = 22,
  PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = 23,
  PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = 24,
};
TextureFilter :: enum {
  TEXTURE_FILTER_POINT = 0,
  TEXTURE_FILTER_BILINEAR = 1,
  TEXTURE_FILTER_TRILINEAR = 2,
  TEXTURE_FILTER_ANISOTROPIC_4X = 3,
  TEXTURE_FILTER_ANISOTROPIC_8X = 4,
  TEXTURE_FILTER_ANISOTROPIC_16X = 5,
};
TextureWrap :: enum {
  TEXTURE_WRAP_REPEAT = 0,
  TEXTURE_WRAP_CLAMP = 1,
  TEXTURE_WRAP_MIRROR_REPEAT = 2,
  TEXTURE_WRAP_MIRROR_CLAMP = 3,
};
CubemapLayout :: enum {
  CUBEMAP_LAYOUT_AUTO_DETECT = 0,
  CUBEMAP_LAYOUT_LINE_VERTICAL = 1,
  CUBEMAP_LAYOUT_LINE_HORIZONTAL = 2,
  CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR = 3,
  CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE = 4,
};
FontType :: enum {
  FONT_DEFAULT = 0,
  FONT_BITMAP = 1,
  FONT_SDF = 2,
};
BlendMode :: enum {
  BLEND_ALPHA = 0,
  BLEND_ADDITIVE = 1,
  BLEND_MULTIPLIED = 2,
  BLEND_ADD_COLORS = 3,
  BLEND_SUBTRACT_COLORS = 4,
  BLEND_ALPHA_PREMULTIPLY = 5,
  BLEND_CUSTOM = 6,
  BLEND_CUSTOM_SEPARATE = 7,
};
Gesture :: enum {
  GESTURE_NONE = 0,
  GESTURE_TAP = 1,
  GESTURE_DOUBLETAP = 2,
  GESTURE_HOLD = 4,
  GESTURE_DRAG = 8,
  GESTURE_SWIPE_RIGHT = 16,
  GESTURE_SWIPE_LEFT = 32,
  GESTURE_SWIPE_UP = 64,
  GESTURE_SWIPE_DOWN = 128,
  GESTURE_PINCH_IN = 256,
  GESTURE_PINCH_OUT = 512,
};
CameraMode :: enum {
  CAMERA_CUSTOM = 0,
  CAMERA_FREE = 1,
  CAMERA_ORBITAL = 2,
  CAMERA_FIRST_PERSON = 3,
  CAMERA_THIRD_PERSON = 4,
};
CameraProjection :: enum {
  CAMERA_PERSPECTIVE = 0,
  CAMERA_ORTHOGRAPHIC = 1,
};
NPatchLayout :: enum {
  NPATCH_NINE_PATCH = 0,
  NPATCH_THREE_PATCH_VERTICAL = 1,
  NPATCH_THREE_PATCH_HORIZONTAL = 2,
};
#alias LoadFileDataCallback :: fn*(u8 *, s32 *) -> u8 *;
#alias SaveFileDataCallback :: fn*(u8 *, void *, s32) -> bool;
#alias LoadFileTextCallback :: fn*(u8 *) -> u8 *;
#alias SaveFileTextCallback :: fn*(u8 *, u8 *) -> bool;
#foreign InitWindow :: fn(width: s32, height: s32, title: u8 *) -> void;
#foreign CloseWindow :: fn() -> void;
#foreign WindowShouldClose :: fn() -> bool;
#foreign IsWindowReady :: fn() -> bool;
#foreign IsWindowFullscreen :: fn() -> bool;
#foreign IsWindowHidden :: fn() -> bool;
#foreign IsWindowMinimized :: fn() -> bool;
#foreign IsWindowMaximized :: fn() -> bool;
#foreign IsWindowFocused :: fn() -> bool;
#foreign IsWindowResized :: fn() -> bool;
#foreign IsWindowState :: fn(flag: u32) -> bool;
#foreign SetWindowState :: fn(flags: u32) -> void;
#foreign ClearWindowState :: fn(flags: u32) -> void;
#foreign ToggleFullscreen :: fn() -> void;
#foreign ToggleBorderlessWindowed :: fn() -> void;
#foreign MaximizeWindow :: fn() -> void;
#foreign MinimizeWindow :: fn() -> void;
#foreign RestoreWindow :: fn() -> void;
#foreign SetWindowIcon :: fn(image: Image) -> void;
#foreign SetWindowIcons :: fn(images: Image *, count: s32) -> void;
#foreign SetWindowTitle :: fn(title: u8 *) -> void;
#foreign SetWindowPosition :: fn(x: s32, y: s32) -> void;
#foreign SetWindowMonitor :: fn(monitor: s32) -> void;
#foreign SetWindowMinSize :: fn(width: s32, height: s32) -> void;
#foreign SetWindowMaxSize :: fn(width: s32, height: s32) -> void;
#foreign SetWindowSize :: fn(width: s32, height: s32) -> void;
#foreign SetWindowOpacity :: fn(opacity: float32) -> void;
#foreign SetWindowFocused :: fn() -> void;
#foreign GetWindowHandle :: fn() -> void *;
#foreign GetScreenWidth :: fn() -> s32;
#foreign GetScreenHeight :: fn() -> s32;
#foreign GetRenderWidth :: fn() -> s32;
#foreign GetRenderHeight :: fn() -> s32;
#foreign GetMonitorCount :: fn() -> s32;
#foreign GetCurrentMonitor :: fn() -> s32;
#foreign GetMonitorPosition :: fn(monitor: s32) -> Vector2;
#foreign GetMonitorWidth :: fn(monitor: s32) -> s32;
#foreign GetMonitorHeight :: fn(monitor: s32) -> s32;
#foreign GetMonitorPhysicalWidth :: fn(monitor: s32) -> s32;
#foreign GetMonitorPhysicalHeight :: fn(monitor: s32) -> s32;
#foreign GetMonitorRefreshRate :: fn(monitor: s32) -> s32;
#foreign GetWindowPosition :: fn() -> Vector2;
#foreign GetWindowScaleDPI :: fn() -> Vector2;
#foreign GetMonitorName :: fn(monitor: s32) -> u8 *;
#foreign SetClipboardText :: fn(text: u8 *) -> void;
#foreign GetClipboardText :: fn() -> u8 *;
#foreign GetClipboardImage :: fn() -> Image;
#foreign EnableEventWaiting :: fn() -> void;
#foreign DisableEventWaiting :: fn() -> void;
#foreign ShowCursor :: fn() -> void;
#foreign HideCursor :: fn() -> void;
#foreign IsCursorHidden :: fn() -> bool;
#foreign EnableCursor :: fn() -> void;
#foreign DisableCursor :: fn() -> void;
#foreign IsCursorOnScreen :: fn() -> bool;
#foreign ClearBackground :: fn(color: Color) -> void;
#foreign BeginDrawing :: fn() -> void;
#foreign EndDrawing :: fn() -> void;
#foreign BeginMode2D :: fn(camera: Camera2D) -> void;
#foreign EndMode2D :: fn() -> void;
#foreign BeginMode3D :: fn(camera: Camera3D) -> void;
#foreign EndMode3D :: fn() -> void;
#foreign BeginTextureMode :: fn(target: RenderTexture2D) -> void;
#foreign EndTextureMode :: fn() -> void;
#foreign BeginShaderMode :: fn(shader: Shader) -> void;
#foreign EndShaderMode :: fn() -> void;
#foreign BeginBlendMode :: fn(mode: s32) -> void;
#foreign EndBlendMode :: fn() -> void;
#foreign BeginScissorMode :: fn(x: s32, y: s32, width: s32, height: s32) -> void;
#foreign EndScissorMode :: fn() -> void;
#foreign BeginVrStereoMode :: fn(config: VrStereoConfig) -> void;
#foreign EndVrStereoMode :: fn() -> void;
#foreign LoadVrStereoConfig :: fn(device: VrDeviceInfo) -> VrStereoConfig;
#foreign UnloadVrStereoConfig :: fn(config: VrStereoConfig) -> void;
#foreign LoadShader :: fn(vsFileName: u8 *, fsFileName: u8 *) -> Shader;
#foreign LoadShaderFromMemory :: fn(vsCode: u8 *, fsCode: u8 *) -> Shader;
#foreign IsShaderValid :: fn(shader: Shader) -> bool;
#foreign GetShaderLocation :: fn(shader: Shader, uniformName: u8 *) -> s32;
#foreign GetShaderLocationAttrib :: fn(shader: Shader, attribName: u8 *) -> s32;
#foreign SetShaderValue :: fn(shader: Shader, locIndex: s32, value: void *, uniformType: s32) -> void;
#foreign SetShaderValueV :: fn(shader: Shader, locIndex: s32, value: void *, uniformType: s32, count: s32) -> void;
#foreign SetShaderValueMatrix :: fn(shader: Shader, locIndex: s32, mat: Matrix) -> void;
#foreign SetShaderValueTexture :: fn(shader: Shader, locIndex: s32, texture: Texture2D) -> void;
#foreign UnloadShader :: fn(shader: Shader) -> void;
#foreign GetScreenToWorldRay :: fn(position: Vector2, camera: Camera) -> Ray;
#foreign GetScreenToWorldRayEx :: fn(position: Vector2, camera: Camera, width: s32, height: s32) -> Ray;
#foreign GetWorldToScreen :: fn(position: Vector3, camera: Camera) -> Vector2;
#foreign GetWorldToScreenEx :: fn(position: Vector3, camera: Camera, width: s32, height: s32) -> Vector2;
#foreign GetWorldToScreen2D :: fn(position: Vector2, camera: Camera2D) -> Vector2;
#foreign GetScreenToWorld2D :: fn(position: Vector2, camera: Camera2D) -> Vector2;
#foreign GetCameraMatrix :: fn(camera: Camera) -> Matrix;
#foreign GetCameraMatrix2D :: fn(camera: Camera2D) -> Matrix;
#foreign SetTargetFPS :: fn(fps: s32) -> void;
#foreign GetFrameTime :: fn() -> float32;
#foreign GetTime :: fn() -> float64;
#foreign GetFPS :: fn() -> s32;
#foreign SwapScreenBuffer :: fn() -> void;
#foreign PollInputEvents :: fn() -> void;
#foreign WaitTime :: fn(seconds: float64) -> void;
#foreign SetRandomSeed :: fn(seed: u32) -> void;
#foreign GetRandomValue :: fn(min: s32, max: s32) -> s32;
#foreign LoadRandomSequence :: fn(count: u32, min: s32, max: s32) -> s32 *;
#foreign UnloadRandomSequence :: fn(sequence: s32 *) -> void;
#foreign TakeScreenshot :: fn(fileName: u8 *) -> void;
#foreign SetConfigFlags :: fn(flags: u32) -> void;
#foreign OpenURL :: fn(url: u8 *) -> void;
#foreign TraceLog :: fn(logLevel: s32, text: u8 *) -> void;
#foreign SetTraceLogLevel :: fn(logLevel: s32) -> void;
#foreign MemAlloc :: fn(size: u32) -> void *;
#foreign MemRealloc :: fn(ptr: void *, size: u32) -> void *;
#foreign MemFree :: fn(ptr: void *) -> void;

#alias TraceLogCallback :: fn*(s32, u8 *);
#foreign SetTraceLogCallback :: fn(callback: TraceLogCallback) -> void;
#foreign SetLoadFileDataCallback :: fn(callback: LoadFileDataCallback) -> void;
#foreign SetSaveFileDataCallback :: fn(callback: SaveFileDataCallback) -> void;
#foreign SetLoadFileTextCallback :: fn(callback: LoadFileTextCallback) -> void;
#foreign SetSaveFileTextCallback :: fn(callback: SaveFileTextCallback) -> void;

#foreign LoadFileData :: fn(fileName: u8 *, dataSize: s32 *) -> u8 *;
#foreign UnloadFileData :: fn(data: u8 *) -> void;
#foreign SaveFileData :: fn(fileName: u8 *, data: void *, dataSize: s32) -> bool;
#foreign ExportDataAsCode :: fn(data: u8 *, dataSize: s32, fileName: u8 *) -> bool;
#foreign LoadFileText :: fn(fileName: u8 *) -> u8 *;
#foreign UnloadFileText :: fn(text: u8 *) -> void;
#foreign SaveFileText :: fn(fileName: u8 *, text: u8 *) -> bool;
#foreign FileExists :: fn(fileName: u8 *) -> bool;
#foreign DirectoryExists :: fn(dirPath: u8 *) -> bool;
#foreign IsFileExtension :: fn(fileName: u8 *, ext: u8 *) -> bool;
#foreign GetFileLength :: fn(fileName: u8 *) -> s32;
#foreign GetFileExtension :: fn(fileName: u8 *) -> u8 *;
#foreign GetFileName :: fn(filePath: u8 *) -> u8 *;
#foreign GetFileNameWithoutExt :: fn(filePath: u8 *) -> u8 *;
#foreign GetDirectoryPath :: fn(filePath: u8 *) -> u8 *;
#foreign GetPrevDirectoryPath :: fn(dirPath: u8 *) -> u8 *;
#foreign GetWorkingDirectory :: fn() -> u8 *;
#foreign GetApplicationDirectory :: fn() -> u8 *;
#foreign MakeDirectory :: fn(dirPath: u8 *) -> s32;
#foreign ChangeDirectory :: fn(dir: u8 *) -> bool;
#foreign IsPathFile :: fn(path: u8 *) -> bool;
#foreign IsFileNameValid :: fn(fileName: u8 *) -> bool;
#foreign LoadDirectoryFiles :: fn(dirPath: u8 *) -> FilePathList;
#foreign LoadDirectoryFilesEx :: fn(basePath: u8 *, filter: u8 *, scanSubdirs: bool) -> FilePathList;
#foreign UnloadDirectoryFiles :: fn(files: FilePathList) -> void;
#foreign IsFileDropped :: fn() -> bool;
#foreign LoadDroppedFiles :: fn() -> FilePathList;
#foreign UnloadDroppedFiles :: fn(files: FilePathList) -> void;
#foreign GetFileModTime :: fn(fileName: u8 *) -> s64;
#foreign CompressData :: fn(data: u8 *, dataSize: s32, compDataSize: s32 *) -> u8 *;
#foreign DecompressData :: fn(compData: u8 *, compDataSize: s32, dataSize: s32 *) -> u8 *;
#foreign EncodeDataBase64 :: fn(data: u8 *, dataSize: s32, outputSize: s32 *) -> u8 *;
#foreign DecodeDataBase64 :: fn(data: u8 *, outputSize: s32 *) -> u8 *;
#foreign ComputeCRC32 :: fn(data: u8 *, dataSize: s32) -> u32;
#foreign ComputeMD5 :: fn(data: u8 *, dataSize: s32) -> u32 *;
#foreign ComputeSHA1 :: fn(data: u8 *, dataSize: s32) -> u32 *;
#foreign LoadAutomationEventList :: fn(fileName: u8 *) -> AutomationEventList;
#foreign UnloadAutomationEventList :: fn(list: AutomationEventList) -> void;
#foreign ExportAutomationEventList :: fn(list: AutomationEventList, fileName: u8 *) -> bool;
#foreign SetAutomationEventList :: fn(list: AutomationEventList *) -> void;
#foreign SetAutomationEventBaseFrame :: fn(frame: s32) -> void;
#foreign StartAutomationEventRecording :: fn() -> void;
#foreign StopAutomationEventRecording :: fn() -> void;
#foreign PlayAutomationEvent :: fn(event: AutomationEvent) -> void;
#foreign IsKeyPressed :: fn(key: s32) -> bool;
#foreign IsKeyPressedRepeat :: fn(key: s32) -> bool;
#foreign IsKeyDown :: fn(key: s32) -> bool;
#foreign IsKeyReleased :: fn(key: s32) -> bool;
#foreign IsKeyUp :: fn(key: s32) -> bool;
#foreign GetKeyPressed :: fn() -> s32;
#foreign GetCharPressed :: fn() -> s32;
#foreign GetKeyName :: fn(key: s32) -> u8 *;
#foreign SetExitKey :: fn(key: s32) -> void;
#foreign IsGamepadAvailable :: fn(gamepad: s32) -> bool;
#foreign GetGamepadName :: fn(gamepad: s32) -> u8 *;
#foreign IsGamepadButtonPressed :: fn(gamepad: s32, button: s32) -> bool;
#foreign IsGamepadButtonDown :: fn(gamepad: s32, button: s32) -> bool;
#foreign IsGamepadButtonReleased :: fn(gamepad: s32, button: s32) -> bool;
#foreign IsGamepadButtonUp :: fn(gamepad: s32, button: s32) -> bool;
#foreign GetGamepadButtonPressed :: fn() -> s32;
#foreign GetGamepadAxisCount :: fn(gamepad: s32) -> s32;
#foreign GetGamepadAxisMovement :: fn(gamepad: s32, axis: s32) -> float32;
#foreign SetGamepadMappings :: fn(mappings: u8 *) -> s32;
#foreign SetGamepadVibration :: fn(gamepad: s32, leftMotor: float32, rightMotor: float32, duration: float32) -> void;
#foreign IsMouseButtonPressed :: fn(button: s32) -> bool;
#foreign IsMouseButtonDown :: fn(button: s32) -> bool;
#foreign IsMouseButtonReleased :: fn(button: s32) -> bool;
#foreign IsMouseButtonUp :: fn(button: s32) -> bool;
#foreign GetMouseX :: fn() -> s32;
#foreign GetMouseY :: fn() -> s32;
#foreign GetMousePosition :: fn() -> Vector2;
#foreign GetMouseDelta :: fn() -> Vector2;
#foreign SetMousePosition :: fn(x: s32, y: s32) -> void;
#foreign SetMouseOffset :: fn(offsetX: s32, offsetY: s32) -> void;
#foreign SetMouseScale :: fn(scaleX: float32, scaleY: float32) -> void;
#foreign GetMouseWheelMove :: fn() -> float32;
#foreign GetMouseWheelMoveV :: fn() -> Vector2;
#foreign SetMouseCursor :: fn(cursor: s32) -> void;
#foreign GetTouchX :: fn() -> s32;
#foreign GetTouchY :: fn() -> s32;
#foreign GetTouchPosition :: fn(index: s32) -> Vector2;
#foreign GetTouchPointId :: fn(index: s32) -> s32;
#foreign GetTouchPointCount :: fn() -> s32;
#foreign SetGesturesEnabled :: fn(flags: u32) -> void;
#foreign IsGestureDetected :: fn(gesture: u32) -> bool;
#foreign GetGestureDetected :: fn() -> s32;
#foreign GetGestureHoldDuration :: fn() -> float32;
#foreign GetGestureDragVector :: fn() -> Vector2;
#foreign GetGestureDragAngle :: fn() -> float32;
#foreign GetGesturePinchVector :: fn() -> Vector2;
#foreign GetGesturePinchAngle :: fn() -> float32;
#foreign UpdateCamera :: fn(camera: Camera *, mode: s32) -> void;
#foreign UpdateCameraPro :: fn(camera: Camera *, movement: Vector3, rotation: Vector3, zoom: float32) -> void;
#foreign SetShapesTexture :: fn(texture: Texture2D, source: Rectangle) -> void;
#foreign GetShapesTexture :: fn() -> Texture2D;
#foreign GetShapesTextureRectangle :: fn() -> Rectangle;
#foreign DrawPixel :: fn(posX: s32, posY: s32, color: Color) -> void;
#foreign DrawPixelV :: fn(position: Vector2, color: Color) -> void;
#foreign DrawLine :: fn(startPosX: s32, startPosY: s32, endPosX: s32, endPosY: s32, color: Color) -> void;
#foreign DrawLineV :: fn(startPos: Vector2, endPos: Vector2, color: Color) -> void;
#foreign DrawLineEx :: fn(startPos: Vector2, endPos: Vector2, thick: float32, color: Color) -> void;
#foreign DrawLineStrip :: fn(points: Vector2 *, pointCount: s32, color: Color) -> void;
#foreign DrawLineBezier :: fn(startPos: Vector2, endPos: Vector2, thick: float32, color: Color) -> void;
#foreign DrawCircle :: fn(centerX: s32, centerY: s32, radius: float32, color: Color) -> void;
#foreign DrawCircleSector :: fn(center: Vector2, radius: float32, startAngle: float32, endAngle: float32, segments: s32, color: Color) -> void;
#foreign DrawCircleSectorLines :: fn(center: Vector2, radius: float32, startAngle: float32, endAngle: float32, segments: s32, color: Color) -> void;
#foreign DrawCircleGradient :: fn(centerX: s32, centerY: s32, radius: float32, inner: Color, outer: Color) -> void;
#foreign DrawCircleV :: fn(center: Vector2, radius: float32, color: Color) -> void;
#foreign DrawCircleLines :: fn(centerX: s32, centerY: s32, radius: float32, color: Color) -> void;
#foreign DrawCircleLinesV :: fn(center: Vector2, radius: float32, color: Color) -> void;
#foreign DrawEllipse :: fn(centerX: s32, centerY: s32, radiusH: float32, radiusV: float32, color: Color) -> void;
#foreign DrawEllipseLines :: fn(centerX: s32, centerY: s32, radiusH: float32, radiusV: float32, color: Color) -> void;
#foreign DrawRing :: fn(center: Vector2, innerRadius: float32, outerRadius: float32, startAngle: float32, endAngle: float32, segments: s32, color: Color) -> void;
#foreign DrawRingLines :: fn(center: Vector2, innerRadius: float32, outerRadius: float32, startAngle: float32, endAngle: float32, segments: s32, color: Color) -> void;
#foreign DrawRectangle :: fn(posX: s32, posY: s32, width: s32, height: s32, color: Color) -> void;
#foreign DrawRectangleV :: fn(position: Vector2, size: Vector2, color: Color) -> void;
#foreign DrawRectangleRec :: fn(rec: Rectangle, color: Color) -> void;
#foreign DrawRectanglePro :: fn(rec: Rectangle, origin: Vector2, rotation: float32, color: Color) -> void;
#foreign DrawRectangleGradientV :: fn(posX: s32, posY: s32, width: s32, height: s32, top: Color, bottom: Color) -> void;
#foreign DrawRectangleGradientH :: fn(posX: s32, posY: s32, width: s32, height: s32, left: Color, right: Color) -> void;
#foreign DrawRectangleGradientEx :: fn(rec: Rectangle, topLeft: Color, bottomLeft: Color, topRight: Color, bottomRight: Color) -> void;
#foreign DrawRectangleLines :: fn(posX: s32, posY: s32, width: s32, height: s32, color: Color) -> void;
#foreign DrawRectangleLinesEx :: fn(rec: Rectangle, lineThick: float32, color: Color) -> void;
#foreign DrawRectangleRounded :: fn(rec: Rectangle, roundness: float32, segments: s32, color: Color) -> void;
#foreign DrawRectangleRoundedLines :: fn(rec: Rectangle, roundness: float32, segments: s32, color: Color) -> void;
#foreign DrawRectangleRoundedLinesEx :: fn(rec: Rectangle, roundness: float32, segments: s32, lineThick: float32, color: Color) -> void;
#foreign DrawTriangle :: fn(v1: Vector2, v2: Vector2, v3: Vector2, color: Color) -> void;
#foreign DrawTriangleLines :: fn(v1: Vector2, v2: Vector2, v3: Vector2, color: Color) -> void;
#foreign DrawTriangleFan :: fn(points: Vector2 *, pointCount: s32, color: Color) -> void;
#foreign DrawTriangleStrip :: fn(points: Vector2 *, pointCount: s32, color: Color) -> void;
#foreign DrawPoly :: fn(center: Vector2, sides: s32, radius: float32, rotation: float32, color: Color) -> void;
#foreign DrawPolyLines :: fn(center: Vector2, sides: s32, radius: float32, rotation: float32, color: Color) -> void;
#foreign DrawPolyLinesEx :: fn(center: Vector2, sides: s32, radius: float32, rotation: float32, lineThick: float32, color: Color) -> void;
#foreign DrawSplineLinear :: fn(points: Vector2 *, pointCount: s32, thick: float32, color: Color) -> void;
#foreign DrawSplineBasis :: fn(points: Vector2 *, pointCount: s32, thick: float32, color: Color) -> void;
#foreign DrawSplineCatmullRom :: fn(points: Vector2 *, pointCount: s32, thick: float32, color: Color) -> void;
#foreign DrawSplineBezierQuadratic :: fn(points: Vector2 *, pointCount: s32, thick: float32, color: Color) -> void;
#foreign DrawSplineBezierCubic :: fn(points: Vector2 *, pointCount: s32, thick: float32, color: Color) -> void;
#foreign DrawSplineSegmentLinear :: fn(p1: Vector2, p2: Vector2, thick: float32, color: Color) -> void;
#foreign DrawSplineSegmentBasis :: fn(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: float32, color: Color) -> void;
#foreign DrawSplineSegmentCatmullRom :: fn(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: float32, color: Color) -> void;
#foreign DrawSplineSegmentBezierQuadratic :: fn(p1: Vector2, c2: Vector2, p3: Vector2, thick: float32, color: Color) -> void;
#foreign DrawSplineSegmentBezierCubic :: fn(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, thick: float32, color: Color) -> void;
#foreign GetSplinePointLinear :: fn(startPos: Vector2, endPos: Vector2, t: float32) -> Vector2;
#foreign GetSplinePointBasis :: fn(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: float32) -> Vector2;
#foreign GetSplinePointCatmullRom :: fn(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: float32) -> Vector2;
#foreign GetSplinePointBezierQuad :: fn(p1: Vector2, c2: Vector2, p3: Vector2, t: float32) -> Vector2;
#foreign GetSplinePointBezierCubic :: fn(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, t: float32) -> Vector2;
#foreign CheckCollisionRecs :: fn(rec1: Rectangle, rec2: Rectangle) -> bool;
#foreign CheckCollisionCircles :: fn(center1: Vector2, radius1: float32, center2: Vector2, radius2: float32) -> bool;
#foreign CheckCollisionCircleRec :: fn(center: Vector2, radius: float32, rec: Rectangle) -> bool;
#foreign CheckCollisionCircleLine :: fn(center: Vector2, radius: float32, p1: Vector2, p2: Vector2) -> bool;
#foreign CheckCollisionPointRec :: fn(point: Vector2, rec: Rectangle) -> bool;
#foreign CheckCollisionPointCircle :: fn(point: Vector2, center: Vector2, radius: float32) -> bool;
#foreign CheckCollisionPointTriangle :: fn(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2) -> bool;
#foreign CheckCollisionPointLine :: fn(point: Vector2, p1: Vector2, p2: Vector2, threshold: s32) -> bool;
#foreign CheckCollisionPointPoly :: fn(point: Vector2, points: Vector2 *, pointCount: s32) -> bool;
#foreign CheckCollisionLines :: fn(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: Vector2, collisionPoint: Vector2 *) -> bool;
#foreign GetCollisionRec :: fn(rec1: Rectangle, rec2: Rectangle) -> Rectangle;
#foreign LoadImage :: fn(fileName: u8 *) -> Image;
#foreign LoadImageRaw :: fn(fileName: u8 *, width: s32, height: s32, format: s32, headerSize: s32) -> Image;
#foreign LoadImageAnim :: fn(fileName: u8 *, frames: s32 *) -> Image;
#foreign LoadImageAnimFromMemory :: fn(fileType: u8 *, fileData: u8 *, dataSize: s32, frames: s32 *) -> Image;
#foreign LoadImageFromMemory :: fn(fileType: u8 *, fileData: u8 *, dataSize: s32) -> Image;
#foreign LoadImageFromTexture :: fn(texture: Texture2D) -> Image;
#foreign LoadImageFromScreen :: fn() -> Image;
#foreign IsImageValid :: fn(image: Image) -> bool;
#foreign UnloadImage :: fn(image: Image) -> void;
#foreign ExportImage :: fn(image: Image, fileName: u8 *) -> bool;
#foreign ExportImageToMemory :: fn(image: Image, fileType: u8 *, fileSize: s32 *) -> u8 *;
#foreign ExportImageAsCode :: fn(image: Image, fileName: u8 *) -> bool;
#foreign GenImageColor :: fn(width: s32, height: s32, color: Color) -> Image;
#foreign GenImageGradientLinear :: fn(width: s32, height: s32, direction: s32, start: Color, end: Color) -> Image;
#foreign GenImageGradientRadial :: fn(width: s32, height: s32, density: float32, inner: Color, outer: Color) -> Image;
#foreign GenImageGradientSquare :: fn(width: s32, height: s32, density: float32, inner: Color, outer: Color) -> Image;
#foreign GenImageChecked :: fn(width: s32, height: s32, checksX: s32, checksY: s32, col1: Color, col2: Color) -> Image;
#foreign GenImageWhiteNoise :: fn(width: s32, height: s32, factor: float32) -> Image;
#foreign GenImagePerlinNoise :: fn(width: s32, height: s32, offsetX: s32, offsetY: s32, scale: float32) -> Image;
#foreign GenImageCellular :: fn(width: s32, height: s32, tileSize: s32) -> Image;
#foreign GenImageText :: fn(width: s32, height: s32, text: u8 *) -> Image;
#foreign ImageCopy :: fn(image: Image) -> Image;
#foreign ImageFromImage :: fn(image: Image, rec: Rectangle) -> Image;
#foreign ImageFromChannel :: fn(image: Image, selectedChannel: s32) -> Image;
#foreign ImageText :: fn(text: u8 *, fontSize: s32, color: Color) -> Image;
#foreign ImageTextEx :: fn(font: Font, text: u8 *, fontSize: float32, spacing: float32, tint: Color) -> Image;
#foreign ImageFormat :: fn(image: Image *, newFormat: s32) -> void;
#foreign ImageToPOT :: fn(image: Image *, fill: Color) -> void;
#foreign ImageCrop :: fn(image: Image *, crop: Rectangle) -> void;
#foreign ImageAlphaCrop :: fn(image: Image *, threshold: float32) -> void;
#foreign ImageAlphaClear :: fn(image: Image *, color: Color, threshold: float32) -> void;
#foreign ImageAlphaMask :: fn(image: Image *, alphaMask: Image) -> void;
#foreign ImageAlphaPremultiply :: fn(image: Image *) -> void;
#foreign ImageBlurGaussian :: fn(image: Image *, blurSize: s32) -> void;
#foreign ImageKernelConvolution :: fn(image: Image *, kernel: float32 *, kernelSize: s32) -> void;
#foreign ImageResize :: fn(image: Image *, newWidth: s32, newHeight: s32) -> void;
#foreign ImageResizeNN :: fn(image: Image *, newWidth: s32, newHeight: s32) -> void;
#foreign ImageResizeCanvas :: fn(image: Image *, newWidth: s32, newHeight: s32, offsetX: s32, offsetY: s32, fill: Color) -> void;
#foreign ImageMipmaps :: fn(image: Image *) -> void;
#foreign ImageDither :: fn(image: Image *, rBpp: s32, gBpp: s32, bBpp: s32, aBpp: s32) -> void;
#foreign ImageFlipVertical :: fn(image: Image *) -> void;
#foreign ImageFlipHorizontal :: fn(image: Image *) -> void;
#foreign ImageRotate :: fn(image: Image *, degrees: s32) -> void;
#foreign ImageRotateCW :: fn(image: Image *) -> void;
#foreign ImageRotateCCW :: fn(image: Image *) -> void;
#foreign ImageColorTint :: fn(image: Image *, color: Color) -> void;
#foreign ImageColorInvert :: fn(image: Image *) -> void;
#foreign ImageColorGrayscale :: fn(image: Image *) -> void;
#foreign ImageColorContrast :: fn(image: Image *, contrast: float32) -> void;
#foreign ImageColorBrightness :: fn(image: Image *, brightness: s32) -> void;
#foreign ImageColorReplace :: fn(image: Image *, color: Color, replace: Color) -> void;
#foreign LoadImageColors :: fn(image: Image) -> Color *;
#foreign LoadImagePalette :: fn(image: Image, maxPaletteSize: s32, colorCount: s32 *) -> Color *;
#foreign UnloadImageColors :: fn(colors: Color *) -> void;
#foreign UnloadImagePalette :: fn(colors: Color *) -> void;
#foreign GetImageAlphaBorder :: fn(image: Image, threshold: float32) -> Rectangle;
#foreign GetImageColor :: fn(image: Image, x: s32, y: s32) -> Color;
#foreign ImageClearBackground :: fn(dst: Image *, color: Color) -> void;
#foreign ImageDrawPixel :: fn(dst: Image *, posX: s32, posY: s32, color: Color) -> void;
#foreign ImageDrawPixelV :: fn(dst: Image *, position: Vector2, color: Color) -> void;
#foreign ImageDrawLine :: fn(dst: Image *, startPosX: s32, startPosY: s32, endPosX: s32, endPosY: s32, color: Color) -> void;
#foreign ImageDrawLineV :: fn(dst: Image *, start: Vector2, end: Vector2, color: Color) -> void;
#foreign ImageDrawLineEx :: fn(dst: Image *, start: Vector2, end: Vector2, thick: s32, color: Color) -> void;
#foreign ImageDrawCircle :: fn(dst: Image *, centerX: s32, centerY: s32, radius: s32, color: Color) -> void;
#foreign ImageDrawCircleV :: fn(dst: Image *, center: Vector2, radius: s32, color: Color) -> void;
#foreign ImageDrawCircleLines :: fn(dst: Image *, centerX: s32, centerY: s32, radius: s32, color: Color) -> void;
#foreign ImageDrawCircleLinesV :: fn(dst: Image *, center: Vector2, radius: s32, color: Color) -> void;
#foreign ImageDrawRectangle :: fn(dst: Image *, posX: s32, posY: s32, width: s32, height: s32, color: Color) -> void;
#foreign ImageDrawRectangleV :: fn(dst: Image *, position: Vector2, size: Vector2, color: Color) -> void;
#foreign ImageDrawRectangleRec :: fn(dst: Image *, rec: Rectangle, color: Color) -> void;
#foreign ImageDrawRectangleLines :: fn(dst: Image *, rec: Rectangle, thick: s32, color: Color) -> void;
#foreign ImageDrawTriangle :: fn(dst: Image *, v1: Vector2, v2: Vector2, v3: Vector2, color: Color) -> void;
#foreign ImageDrawTriangleEx :: fn(dst: Image *, v1: Vector2, v2: Vector2, v3: Vector2, c1: Color, c2: Color, c3: Color) -> void;
#foreign ImageDrawTriangleLines :: fn(dst: Image *, v1: Vector2, v2: Vector2, v3: Vector2, color: Color) -> void;
#foreign ImageDrawTriangleFan :: fn(dst: Image *, points: Vector2 *, pointCount: s32, color: Color) -> void;
#foreign ImageDrawTriangleStrip :: fn(dst: Image *, points: Vector2 *, pointCount: s32, color: Color) -> void;
#foreign ImageDraw :: fn(dst: Image *, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color) -> void;
#foreign ImageDrawText :: fn(dst: Image *, text: u8 *, posX: s32, posY: s32, fontSize: s32, color: Color) -> void;
#foreign ImageDrawTextEx :: fn(dst: Image *, font: Font, text: u8 *, position: Vector2, fontSize: float32, spacing: float32, tint: Color) -> void;
#foreign LoadTexture :: fn(fileName: u8 *) -> Texture2D;
#foreign LoadTextureFromImage :: fn(image: Image) -> Texture2D;
#foreign LoadTextureCubemap :: fn(image: Image, layout: s32) -> TextureCubemap;
#foreign LoadRenderTexture :: fn(width: s32, height: s32) -> RenderTexture2D;
#foreign IsTextureValid :: fn(texture: Texture2D) -> bool;
#foreign UnloadTexture :: fn(texture: Texture2D) -> void;
#foreign IsRenderTextureValid :: fn(target: RenderTexture2D) -> bool;
#foreign UnloadRenderTexture :: fn(target: RenderTexture2D) -> void;
#foreign UpdateTexture :: fn(texture: Texture2D, pixels: void *) -> void;
#foreign UpdateTextureRec :: fn(texture: Texture2D, rec: Rectangle, pixels: void *) -> void;
#foreign GenTextureMipmaps :: fn(texture: Texture2D *) -> void;
#foreign SetTextureFilter :: fn(texture: Texture2D, filter: s32) -> void;
#foreign SetTextureWrap :: fn(texture: Texture2D, wrap: s32) -> void;
#foreign DrawTexture :: fn(texture: Texture2D, posX: s32, posY: s32, tint: Color) -> void;
#foreign DrawTextureV :: fn(texture: Texture2D, position: Vector2, tint: Color) -> void;
#foreign DrawTextureEx :: fn(texture: Texture2D, position: Vector2, rotation: float32, scale: float32, tint: Color) -> void;
#foreign DrawTextureRec :: fn(texture: Texture2D, source: Rectangle, position: Vector2, tint: Color) -> void;
#foreign DrawTexturePro :: fn(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: float32, tint: Color) -> void;
#foreign DrawTextureNPatch :: fn(texture: Texture2D, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: float32, tint: Color) -> void;
#foreign ColorIsEqual :: fn(col1: Color, col2: Color) -> bool;
#foreign Fade :: fn(color: Color, alpha: float32) -> Color;
#foreign ColorToInt :: fn(color: Color) -> s32;
#foreign ColorNormalize :: fn(color: Color) -> Vector4;
#foreign ColorFromNormalized :: fn(normalized: Vector4) -> Color;
#foreign ColorToHSV :: fn(color: Color) -> Vector3;
#foreign ColorFromHSV :: fn(hue: float32, saturation: float32, value: float32) -> Color;
#foreign ColorTint :: fn(color: Color, tint: Color) -> Color;
#foreign ColorBrightness :: fn(color: Color, factor: float32) -> Color;
#foreign ColorContrast :: fn(color: Color, contrast: float32) -> Color;
#foreign ColorAlpha :: fn(color: Color, alpha: float32) -> Color;
#foreign ColorAlphaBlend :: fn(dst: Color, src: Color, tint: Color) -> Color;
#foreign ColorLerp :: fn(color1: Color, color2: Color, factor: float32) -> Color;
#foreign GetColor :: fn(hexValue: u32) -> Color;
#foreign GetPixelColor :: fn(srcPtr: void *, format: s32) -> Color;
#foreign SetPixelColor :: fn(dstPtr: void *, color: Color, format: s32) -> void;
#foreign GetPixelDataSize :: fn(width: s32, height: s32, format: s32) -> s32;
#foreign GetFontDefault :: fn() -> Font;
#foreign LoadFont :: fn(fileName: u8 *) -> Font;
#foreign LoadFontEx :: fn(fileName: u8 *, fontSize: s32, codepoints: s32 *, codepointCount: s32) -> Font;
#foreign LoadFontFromImage :: fn(image: Image, key: Color, firstChar: s32) -> Font;
#foreign LoadFontFromMemory :: fn(fileType: u8 *, fileData: u8 *, dataSize: s32, fontSize: s32, codepoints: s32 *, codepointCount: s32) -> Font;
#foreign IsFontValid :: fn(font: Font) -> bool;
#foreign LoadFontData :: fn(fileData: u8 *, dataSize: s32, fontSize: s32, codepoints: s32 *, codepointCount: s32, type: s32) -> GlyphInfo *;
#foreign GenImageFontAtlas :: fn(glyphs: GlyphInfo *, glyphRecs: Rectangle * *, glyphCount: s32, fontSize: s32, padding: s32, packMethod: s32) -> Image;
#foreign UnloadFontData :: fn(glyphs: GlyphInfo *, glyphCount: s32) -> void;
#foreign UnloadFont :: fn(font: Font) -> void;
#foreign ExportFontAsCode :: fn(font: Font, fileName: u8 *) -> bool;
#foreign DrawFPS :: fn(posX: s32, posY: s32) -> void;
#foreign DrawText :: fn(text: u8 *, posX: s32, posY: s32, fontSize: s32, color: Color) -> void;
#foreign DrawTextEx :: fn(font: Font, text: u8 *, position: Vector2, fontSize: float32, spacing: float32, tint: Color) -> void;
#foreign DrawTextPro :: fn(font: Font, text: u8 *, position: Vector2, origin: Vector2, rotation: float32, fontSize: float32, spacing: float32, tint: Color) -> void;
#foreign DrawTextCodepoint :: fn(font: Font, codepoint: s32, position: Vector2, fontSize: float32, tint: Color) -> void;
#foreign DrawTextCodepoints :: fn(font: Font, codepoints: s32 *, codepointCount: s32, position: Vector2, fontSize: float32, spacing: float32, tint: Color) -> void;
#foreign SetTextLineSpacing :: fn(spacing: s32) -> void;
#foreign MeasureText :: fn(text: u8 *, fontSize: s32) -> s32;
#foreign MeasureTextEx :: fn(font: Font, text: u8 *, fontSize: float32, spacing: float32) -> Vector2;
#foreign GetGlyphIndex :: fn(font: Font, codepoint: s32) -> s32;
#foreign GetGlyphInfo :: fn(font: Font, codepoint: s32) -> GlyphInfo;
#foreign GetGlyphAtlasRec :: fn(font: Font, codepoint: s32) -> Rectangle;
#foreign LoadUTF8 :: fn(codepoints: s32 *, length: s32) -> u8 *;
#foreign UnloadUTF8 :: fn(text: u8 *) -> void;
#foreign LoadCodepoints :: fn(text: u8 *, count: s32 *) -> s32 *;
#foreign UnloadCodepoints :: fn(codepoints: s32 *) -> void;
#foreign GetCodepointCount :: fn(text: u8 *) -> s32;
#foreign GetCodepoint :: fn(text: u8 *, codepointSize: s32 *) -> s32;
#foreign GetCodepointNext :: fn(text: u8 *, codepointSize: s32 *) -> s32;
#foreign GetCodepointPrevious :: fn(text: u8 *, codepointSize: s32 *) -> s32;
#foreign CodepointToUTF8 :: fn(codepoint: s32, utf8Size: s32 *) -> u8 *;
#foreign TextCopy :: fn(dst: u8 *, src: u8 *) -> s32;
#foreign TextIsEqual :: fn(text1: u8 *, text2: u8 *) -> bool;
#foreign TextLength :: fn(text: u8 *) -> u32;
#foreign TextFormat :: fn(text: u8 *) -> u8 *;
#foreign TextSubtext :: fn(text: u8 *, position: s32, length: s32) -> u8 *;
#foreign TextReplace :: fn(text: u8 *, replace: u8 *, by: u8 *) -> u8 *;
#foreign TextInsert :: fn(text: u8 *, insert: u8 *, position: s32) -> u8 *;
#foreign TextJoin :: fn(textList: u8 * *, count: s32, delimiter: u8 *) -> u8 *;
#foreign TextSplit :: fn(text: u8 *, delimiter: u8, count: s32 *) -> u8 * *;
#foreign TextAppend :: fn(text: u8 *, append: u8 *, position: s32 *) -> void;
#foreign TextFindIndex :: fn(text: u8 *, find: u8 *) -> s32;
#foreign TextToUpper :: fn(text: u8 *) -> u8 *;
#foreign TextToLower :: fn(text: u8 *) -> u8 *;
#foreign TextToPascal :: fn(text: u8 *) -> u8 *;
#foreign TextToSnake :: fn(text: u8 *) -> u8 *;
#foreign TextToCamel :: fn(text: u8 *) -> u8 *;
#foreign TextToInteger :: fn(text: u8 *) -> s32;
#foreign TextToFloat :: fn(text: u8 *) -> float32;
#foreign DrawLine3D :: fn(startPos: Vector3, endPos: Vector3, color: Color) -> void;
#foreign DrawPoint3D :: fn(position: Vector3, color: Color) -> void;
#foreign DrawCircle3D :: fn(center: Vector3, radius: float32, rotationAxis: Vector3, rotationAngle: float32, color: Color) -> void;
#foreign DrawTriangle3D :: fn(v1: Vector3, v2: Vector3, v3: Vector3, color: Color) -> void;
#foreign DrawTriangleStrip3D :: fn(points: Vector3 *, pointCount: s32, color: Color) -> void;
#foreign DrawCube :: fn(position: Vector3, width: float32, height: float32, length: float32, color: Color) -> void;
#foreign DrawCubeV :: fn(position: Vector3, size: Vector3, color: Color) -> void;
#foreign DrawCubeWires :: fn(position: Vector3, width: float32, height: float32, length: float32, color: Color) -> void;
#foreign DrawCubeWiresV :: fn(position: Vector3, size: Vector3, color: Color) -> void;
#foreign DrawSphere :: fn(centerPos: Vector3, radius: float32, color: Color) -> void;
#foreign DrawSphereEx :: fn(centerPos: Vector3, radius: float32, rings: s32, slices: s32, color: Color) -> void;
#foreign DrawSphereWires :: fn(centerPos: Vector3, radius: float32, rings: s32, slices: s32, color: Color) -> void;
#foreign DrawCylinder :: fn(position: Vector3, radiusTop: float32, radiusBottom: float32, height: float32, slices: s32, color: Color) -> void;
#foreign DrawCylinderEx :: fn(startPos: Vector3, endPos: Vector3, startRadius: float32, endRadius: float32, sides: s32, color: Color) -> void;
#foreign DrawCylinderWires :: fn(position: Vector3, radiusTop: float32, radiusBottom: float32, height: float32, slices: s32, color: Color) -> void;
#foreign DrawCylinderWiresEx :: fn(startPos: Vector3, endPos: Vector3, startRadius: float32, endRadius: float32, sides: s32, color: Color) -> void;
#foreign DrawCapsule :: fn(startPos: Vector3, endPos: Vector3, radius: float32, slices: s32, rings: s32, color: Color) -> void;
#foreign DrawCapsuleWires :: fn(startPos: Vector3, endPos: Vector3, radius: float32, slices: s32, rings: s32, color: Color) -> void;
#foreign DrawPlane :: fn(centerPos: Vector3, size: Vector2, color: Color) -> void;
#foreign DrawRay :: fn(ray: Ray, color: Color) -> void;
#foreign DrawGrid :: fn(slices: s32, spacing: float32) -> void;
#foreign LoadModel :: fn(fileName: u8 *) -> Model;
#foreign LoadModelFromMesh :: fn(mesh: Mesh) -> Model;
#foreign IsModelValid :: fn(model: Model) -> bool;
#foreign UnloadModel :: fn(model: Model) -> void;
#foreign GetModelBoundingBox :: fn(model: Model) -> BoundingBox;
#foreign DrawModel :: fn(model: Model, position: Vector3, scale: float32, tint: Color) -> void;
#foreign DrawModelEx :: fn(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: float32, scale: Vector3, tint: Color) -> void;
#foreign DrawModelWires :: fn(model: Model, position: Vector3, scale: float32, tint: Color) -> void;
#foreign DrawModelWiresEx :: fn(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: float32, scale: Vector3, tint: Color) -> void;
#foreign DrawModelPoints :: fn(model: Model, position: Vector3, scale: float32, tint: Color) -> void;
#foreign DrawModelPointsEx :: fn(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: float32, scale: Vector3, tint: Color) -> void;
#foreign DrawBoundingBox :: fn(box: BoundingBox, color: Color) -> void;
#foreign DrawBillboard :: fn(camera: Camera, texture: Texture2D, position: Vector3, scale: float32, tint: Color) -> void;
#foreign DrawBillboardRec :: fn(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color) -> void;
#foreign DrawBillboardPro :: fn(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: float32, tint: Color) -> void;
#foreign UploadMesh :: fn(mesh: Mesh *, dynamic: bool) -> void;
#foreign UpdateMeshBuffer :: fn(mesh: Mesh, index: s32, data: void *, dataSize: s32, offset: s32) -> void;
#foreign UnloadMesh :: fn(mesh: Mesh) -> void;
#foreign DrawMesh :: fn(mesh: Mesh, material: Material, transform: Matrix) -> void;
#foreign DrawMeshInstanced :: fn(mesh: Mesh, material: Material, transforms: Matrix *, instances: s32) -> void;
#foreign GetMeshBoundingBox :: fn(mesh: Mesh) -> BoundingBox;
#foreign GenMeshTangents :: fn(mesh: Mesh *) -> void;
#foreign ExportMesh :: fn(mesh: Mesh, fileName: u8 *) -> bool;
#foreign ExportMeshAsCode :: fn(mesh: Mesh, fileName: u8 *) -> bool;
#foreign GenMeshPoly :: fn(sides: s32, radius: float32) -> Mesh;
#foreign GenMeshPlane :: fn(width: float32, length: float32, resX: s32, resZ: s32) -> Mesh;
#foreign GenMeshCube :: fn(width: float32, height: float32, length: float32) -> Mesh;
#foreign GenMeshSphere :: fn(radius: float32, rings: s32, slices: s32) -> Mesh;
#foreign GenMeshHemiSphere :: fn(radius: float32, rings: s32, slices: s32) -> Mesh;
#foreign GenMeshCylinder :: fn(radius: float32, height: float32, slices: s32) -> Mesh;
#foreign GenMeshCone :: fn(radius: float32, height: float32, slices: s32) -> Mesh;
#foreign GenMeshTorus :: fn(radius: float32, size: float32, radSeg: s32, sides: s32) -> Mesh;
#foreign GenMeshKnot :: fn(radius: float32, size: float32, radSeg: s32, sides: s32) -> Mesh;
#foreign GenMeshHeightmap :: fn(heightmap: Image, size: Vector3) -> Mesh;
#foreign GenMeshCubicmap :: fn(cubicmap: Image, cubeSize: Vector3) -> Mesh;
#foreign LoadMaterials :: fn(fileName: u8 *, materialCount: s32 *) -> Material *;
#foreign LoadMaterialDefault :: fn() -> Material;
#foreign IsMaterialValid :: fn(material: Material) -> bool;
#foreign UnloadMaterial :: fn(material: Material) -> void;
#foreign SetMaterialTexture :: fn(material: Material *, mapType: s32, texture: Texture2D) -> void;
#foreign SetModelMeshMaterial :: fn(model: Model *, meshId: s32, materialId: s32) -> void;
#foreign LoadModelAnimations :: fn(fileName: u8 *, animCount: s32 *) -> ModelAnimation *;
#foreign UpdateModelAnimation :: fn(model: Model, anim: ModelAnimation, frame: s32) -> void;
#foreign UpdateModelAnimationBones :: fn(model: Model, anim: ModelAnimation, frame: s32) -> void;
#foreign UnloadModelAnimation :: fn(anim: ModelAnimation) -> void;
#foreign UnloadModelAnimations :: fn(animations: ModelAnimation *, animCount: s32) -> void;
#foreign IsModelAnimationValid :: fn(model: Model, anim: ModelAnimation) -> bool;
#foreign CheckCollisionSpheres :: fn(center1: Vector3, radius1: float32, center2: Vector3, radius2: float32) -> bool;
#foreign CheckCollisionBoxes :: fn(box1: BoundingBox, box2: BoundingBox) -> bool;
#foreign CheckCollisionBoxSphere :: fn(box: BoundingBox, center: Vector3, radius: float32) -> bool;
#foreign GetRayCollisionSphere :: fn(ray: Ray, center: Vector3, radius: float32) -> RayCollision;
#foreign GetRayCollisionBox :: fn(ray: Ray, box: BoundingBox) -> RayCollision;
#foreign GetRayCollisionMesh :: fn(ray: Ray, mesh: Mesh, transform: Matrix) -> RayCollision;
#foreign GetRayCollisionTriangle :: fn(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3) -> RayCollision;
#foreign GetRayCollisionQuad :: fn(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3) -> RayCollision;
#alias AudioCallback :: fn*(void *, u32) -> void;
#foreign InitAudioDevice :: fn() -> void;
#foreign CloseAudioDevice :: fn() -> void;
#foreign IsAudioDeviceReady :: fn() -> bool;
#foreign SetMasterVolume :: fn(volume: float32) -> void;
#foreign GetMasterVolume :: fn() -> float32;
#foreign LoadWave :: fn(fileName: u8 *) -> Wave;
#foreign LoadWaveFromMemory :: fn(fileType: u8 *, fileData: u8 *, dataSize: s32) -> Wave;
#foreign IsWaveValid :: fn(wave: Wave) -> bool;
#foreign LoadSound :: fn(fileName: u8 *) -> Sound;
#foreign LoadSoundFromWave :: fn(wave: Wave) -> Sound;
#foreign LoadSoundAlias :: fn(source: Sound) -> Sound;
#foreign IsSoundValid :: fn(sound: Sound) -> bool;
#foreign UpdateSound :: fn(sound: Sound, data: void *, sampleCount: s32) -> void;
#foreign UnloadWave :: fn(wave: Wave) -> void;
#foreign UnloadSound :: fn(sound: Sound) -> void;
#foreign UnloadSoundAlias :: fn(alias: Sound) -> void;
#foreign ExportWave :: fn(wave: Wave, fileName: u8 *) -> bool;
#foreign ExportWaveAsCode :: fn(wave: Wave, fileName: u8 *) -> bool;
#foreign PlaySound :: fn(sound: Sound) -> void;
#foreign StopSound :: fn(sound: Sound) -> void;
#foreign PauseSound :: fn(sound: Sound) -> void;
#foreign ResumeSound :: fn(sound: Sound) -> void;
#foreign IsSoundPlaying :: fn(sound: Sound) -> bool;
#foreign SetSoundVolume :: fn(sound: Sound, volume: float32) -> void;
#foreign SetSoundPitch :: fn(sound: Sound, pitch: float32) -> void;
#foreign SetSoundPan :: fn(sound: Sound, pan: float32) -> void;
#foreign WaveCopy :: fn(wave: Wave) -> Wave;
#foreign WaveCrop :: fn(wave: Wave *, initFrame: s32, finalFrame: s32) -> void;
#foreign WaveFormat :: fn(wave: Wave *, sampleRate: s32, sampleSize: s32, channels: s32) -> void;
#foreign LoadWaveSamples :: fn(wave: Wave) -> float32 *;
#foreign UnloadWaveSamples :: fn(samples: float32 *) -> void;
#foreign LoadMusicStream :: fn(fileName: u8 *) -> Music;
#foreign LoadMusicStreamFromMemory :: fn(fileType: u8 *, data: u8 *, dataSize: s32) -> Music;
#foreign IsMusicValid :: fn(music: Music) -> bool;
#foreign UnloadMusicStream :: fn(music: Music) -> void;
#foreign PlayMusicStream :: fn(music: Music) -> void;
#foreign IsMusicStreamPlaying :: fn(music: Music) -> bool;
#foreign UpdateMusicStream :: fn(music: Music) -> void;
#foreign StopMusicStream :: fn(music: Music) -> void;
#foreign PauseMusicStream :: fn(music: Music) -> void;
#foreign ResumeMusicStream :: fn(music: Music) -> void;
#foreign SeekMusicStream :: fn(music: Music, position: float32) -> void;
#foreign SetMusicVolume :: fn(music: Music, volume: float32) -> void;
#foreign SetMusicPitch :: fn(music: Music, pitch: float32) -> void;
#foreign SetMusicPan :: fn(music: Music, pan: float32) -> void;
#foreign GetMusicTimeLength :: fn(music: Music) -> float32;
#foreign GetMusicTimePlayed :: fn(music: Music) -> float32;
#foreign LoadAudioStream :: fn(sampleRate: u32, sampleSize: u32, channels: u32) -> AudioStream;
#foreign IsAudioStreamValid :: fn(stream: AudioStream) -> bool;
#foreign UnloadAudioStream :: fn(stream: AudioStream) -> void;
#foreign UpdateAudioStream :: fn(stream: AudioStream, data: void *, frameCount: s32) -> void;
#foreign IsAudioStreamProcessed :: fn(stream: AudioStream) -> bool;
#foreign PlayAudioStream :: fn(stream: AudioStream) -> void;
#foreign PauseAudioStream :: fn(stream: AudioStream) -> void;
#foreign ResumeAudioStream :: fn(stream: AudioStream) -> void;
#foreign IsAudioStreamPlaying :: fn(stream: AudioStream) -> bool;
#foreign StopAudioStream :: fn(stream: AudioStream) -> void;
#foreign SetAudioStreamVolume :: fn(stream: AudioStream, volume: float32) -> void;
#foreign SetAudioStreamPitch :: fn(stream: AudioStream, pitch: float32) -> void;
#foreign SetAudioStreamPan :: fn(stream: AudioStream, pan: float32) -> void;
#foreign SetAudioStreamBufferSizeDefault :: fn(size: s32) -> void;
#foreign SetAudioStreamCallback :: fn(stream: AudioStream, callback: AudioCallback) -> void;
#foreign AttachAudioStreamProcessor :: fn(stream: AudioStream, processor: AudioCallback) -> void;
#foreign DetachAudioStreamProcessor :: fn(stream: AudioStream, processor: AudioCallback) -> void;
#foreign AttachAudioMixedProcessor :: fn(processor: AudioCallback) -> void;
#foreign DetachAudioMixedProcessor :: fn(processor: AudioCallback) -> void;
