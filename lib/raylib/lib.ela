#import math;

#include "_raybindings.ela";

// NOTE: 
// If you use static libraries in your .ela library, you should provide that dependency in your lib/ dir, and just link against it as such.
// do not use -lsome_system_library, or you will have a terrible library.
#c_flags " /usr/local/lib/ela/raylib/libraylib.a "


impl Color {
  scaled_rgb :: fn(self, scale: float32) -> #self {
    return {
      r: clamp((self.r as float32) * scale as u8, 0, 255) as u8,
      g: clamp((self.g as float32) * scale as u8, 0, 255) as u8,
      b: clamp((self.b as float32) * scale as u8, 0, 255) as u8,
      a: self.a,
    };
  }
  with_alpha :: fn(self, a: u8) -> Color {
    return {
      r: self.r as u8,
      g: self.g as u8,
      b: self.b as u8,
      a: a,
    };
  }
  lerp :: fn(a: #self, b: #self, t: float32) -> #self {
    return {
      r: (a.r + (b.r - a.r) * t) as u8,
      g: (a.g + (b.g - a.g) * t) as u8,
      b: (a.b + (b.b - a.b) * t) as u8,
      a: (a.a + (b.a - a.a) * t) as u8,
    };
  }

  to_string :: fn(self*) -> c_string {
    return $"Color(r: {self.r}, g: {self.g}, b: {self.b}, a: {self.a})";
  }
}

CLEAR: Color;
WHITE: Color = { r: 255 as u8, g: 255 as u8, b: 255 as u8, a: 255 as u8 };
BLACK: Color = { r: 0 as u8, g: 0 as u8, b: 0 as u8, a: 255 as u8 };
RED: Color = { r: 255 as u8, g: 0 as u8, b: 0 as u8, a: 255 as u8 };
GREEN: Color = { r: 0 as u8, g: 255 as u8, b: 0 as u8, a: 255 as u8 };
BLUE: Color = { r: 0 as u8, g: 0 as u8, b: 255 as u8, a: 255 as u8 };
YELLOW: Color = { r: 255 as u8, g: 255 as u8, b: 0 as u8, a: 255 as u8 };
PURPLE: Color = { r: 255 as u8, g: 0 as u8, b: 255 as u8, a: 255 as u8 };
ORANGE: Color = { r: 255 as u8, g: 165 as u8, b: 0 as u8, a: 255 as u8 };
GRAY: Color = { r: 128 as u8, g: 128 as u8, b: 128 as u8, a: 255 as u8 };
DARKGRAY: Color = { r: 80 as u8, g: 80 as u8, b: 80 as u8, a: 255 as u8 };
LIGHTGRAY: Color = { r: 200 as u8, g: 200 as u8, b: 200 as u8, a: 255 as u8 };
BROWN: Color = { r: 165 as u8, g: 42 as u8, b: 42 as u8, a: 255 as u8 };
PINK: Color = { r: 255 as u8, g: 192 as u8, b: 203 as u8, a: 255 as u8 };
LIME: Color = { r: 0 as u8, g: 255 as u8, b: 0 as u8, a: 255 as u8 };
DARKGREEN: Color = { r: 0 as u8, g: 100 as u8, b: 0 as u8, a: 255 as u8 };
SKYBLUE: Color = { r: 135 as u8, g: 206 as u8, b: 235 as u8, a: 255 as u8 };
VIOLET: Color = { r: 238 as u8, g: 130 as u8, b: 238 as u8, a: 255 as u8 };
GOLD: Color = { r: 255 as u8, g: 215 as u8, b: 0 as u8, a: 255 as u8 };
BEIGE: Color = { r: 245 as u8, g: 245 as u8, b: 220 as u8, a: 255 as u8 };
MAGENTA: Color = { r: 255 as u8, g: 0 as u8, b: 255 as u8, a: 255 as u8 };
MAROON: Color = { r: 128 as u8, g: 0 as u8, b: 0 as u8, a: 255 as u8 };
DARKBLUE: Color = { r: 0 as u8, g: 0 as u8, b: 139 as u8, a: 255 as u8 };
DARKPURPLE: Color = { r: 139 as u8, g: 0 as u8, b: 139 as u8, a: 255 as u8 };
DARKBROWN: Color = { r: 101 as u8, g: 67 as u8, b: 33 as u8, a: 255 as u8 };
CYAN: Color = { r: 0 as u8, g: 255 as u8, b: 255 as u8, a: 255 as u8 };
DARKCYAN: Color = { r: 0 as u8, g: 139 as u8, b: 139 as u8, a: 255 as u8 };
LIGHTCYAN: Color = { r: 224 as u8, g: 255 as u8, b: 255 as u8, a: 255 as u8 };

// Exclude black and white.
All_Colors := fn() -> List![Color] {
  list : List![Color];
  list.push(WHITE);
  list.push(RED);
  list.push(GREEN);
  list.push(BLUE);
  list.push(YELLOW);
  list.push(PURPLE);
  list.push(ORANGE);
  list.push(GRAY);
  list.push(DARKGRAY);
  list.push(LIGHTGRAY);
  list.push(BROWN);
  list.push(PINK);
  list.push(LIME);
  list.push(DARKGREEN);
  list.push(SKYBLUE);
  list.push(VIOLET);
  list.push(GOLD);
  list.push(BEIGE);
  list.push(MAGENTA);
  list.push(MAROON);
  list.push(DARKBLUE);
  list.push(DARKPURPLE);
  list.push(DARKBROWN);
  list.push(CYAN);
  list.push(DARKCYAN);
  list.push(LIGHTCYAN);
  return list;
}();


impl Rectangle {
  to_string :: fn(self*) -> c_string {
    return $"Rectangle(x: {self.x}, y: {self.y}, width: {self.width}, height: {self.height})";
  }
}

impl Vector2 {
  to_string :: fn(self*) -> c_string {
    return $"Vector2(x: {self.x}, y: {self.y})";
  }
  zero :: fn() -> #self {
    return { x: 0.0, y: 0.0 };
  }

  one :: fn() -> #self {
    return { x: 1.0, y: 1.0 };
  }

  scalar :: fn(value: float32) -> #self {
    return { x: value, y: value };
  }

  add :: fn(self, other: #self) -> #self {
    return { x: self.x + other.x, y: self.y + other.y };
  }

  sub :: fn(self, other: #self) -> #self {
    return { x: self.x - other.x, y: self.y - other.y };
  }

  mul :: fn(self, scalar: float32) -> #self {
    return { x: self.x * scalar, y: self.y * scalar };
  }

  div :: fn(self, scalar: float32) -> #self {
    return { x: self.x / scalar, y: self.y / scalar };
  }

  length :: fn(self) -> float32 {
    return sqrt(self.x * self.x + self.y * self.y) as float32;
  }

  length_sqr :: fn(self) -> float32 {
    return self.x * self.x + self.y * self.y;
  }

  normalize :: fn(self) -> #self {
    len := self.length();
    return { x: self.x / len, y: self.y / len };
  }

  dot :: fn(self, other: #self) -> float32 {
    return self.x * other.x + self.y * other.y;
  }

  scale :: fn(self, scalar: float32) -> #self {
    return { x: self.x * scalar, y: self.y * scalar };
  }

  equals :: fn(self, other: #self) -> bool {
    return self.x == other.x && self.y == other.y;
  }

  distance :: fn(self, other: #self) -> float32 {
    return sqrt((self.x - other.x) * (self.x - other.x) + (self.y - other.y) * (self.y - other.y)) as float32;
  }
}

impl Vector3 {
  to_string :: fn(self*) -> c_string {
    return $"Vector3(x: {self.x}, y: {self.y}, z: {self.z})";
  }
  zero :: fn() -> #self {
    return { x: 0.0, y: 0.0, z: 0.0 };
  }

  one :: fn() -> #self {
    return { x: 1.0, y: 1.0, z: 1.0 };
  }

  scalar :: fn(value: float32) -> #self {
    return { x: value, y: value, z: value };
  }

  add :: fn(self, other: #self) -> #self {
    return { x: self.x + other.x, y: self.y + other.y, z: self.z + other.z };
  }

  sub :: fn(self, other: #self) -> #self {
    return { x: self.x - other.x, y: self.y - other.y, z: self.z - other.z };
  }

  mul :: fn(self, scalar: float32) -> #self {
    return { x: self.x * scalar, y: self.y * scalar, z: self.z * scalar };
  }

  div :: fn(self, scalar: float32) -> #self {
    return { x: self.x / scalar, y: self.y / scalar, z: self.z / scalar };
  }

  length :: fn(self) -> float32 {
    return sqrt(self.x * self.x + self.y * self.y + self.z * self.z) as float32;
  }

  length_sqr :: fn(self) -> float32 {
    return self.x * self.x + self.y * self.y + self.z * self.z;
  }


  normalize :: fn(self) -> #self {
    len := self.length();
    return { x: self.x / len, y: self.y / len, z: self.z / len };
  }

  dot :: fn(self, other: #self) -> float32 {
    return self.x * other.x + self.y * other.y + self.z * other.z;
  }

  cross :: fn(self, other: #self) -> #self {
    return {
      x: self.y * other.z - self.z * other.y,
      y: self.z * other.x - self.x * other.z,
      z: self.x * other.y - self.y * other.x
    };
  }

  scale :: fn(self, scalar: float32) -> #self {
    return { x: self.x * scalar, y: self.y * scalar, z: self.z * scalar };
  }

  equals :: fn(self, other: #self) -> bool {
    return self.x == other.x && self.y == other.y && self.z == other.z;
  }

  distance :: fn(self, other: #self) -> float32 {
    return sqrt((self.x - other.x) * (self.x - other.x) + (self.y - other.y) * (self.y - other.y) + (self.z - other.z) * (self.z - other.z)) as float32;
  }
}

impl Vector4 {
  to_string :: fn(self*) -> c_string {
    return $"Vector4(x: {self.x}, y: {self.y}, z: {self.z}, w: {self.w})";
  }

  zero :: fn() -> #self {
    return { x: 0.0, y: 0.0, z: 0.0, w: 0.0 };
  }

  one :: fn() -> #self {
    return { x: 1.0, y: 1.0, z: 1.0, w: 1.0 };
  }

  scalar :: fn(value: float32) -> #self {
    return { x: value, y: value, z: value, w: value };
  }

  add :: fn(self, other: #self) -> #self {
    return { x: self.x + other.x, y: self.y + other.y, z: self.z + other.z, w: self.w + other.w };
  }

  sub :: fn(self, other: #self) -> #self {
    return { x: self.x - other.x, y: self.y - other.y, z: self.z - other.z, w: self.w - other.w };
  }

  mul :: fn(self, scalar: float32) -> #self {
    return { x: self.x * scalar, y: self.y * scalar, z: self.z * scalar, w: self.w * scalar };
  }

  div :: fn(self, scalar: float32) -> #self {
    return { x: self.x / scalar, y: self.y / scalar, z: self.z / scalar, w: self.w / scalar };
  }

  length :: fn(self) -> float32 {
    return sqrt(self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w) as float32;
  }

  length_sqr :: fn(self) -> float32 {
    return self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w;
  }

  normalize :: fn(self) -> #self {
    len := self.length();
    return { x: self.x / len, y: self.y / len, z: self.z / len, w: self.w / len };
  }

  dot :: fn(self, other: #self) -> float32 {
    return self.x * other.x + self.y * other.y + self.z * other.z + self.w * other.w;
  }

  scale :: fn(self, scalar: float32) -> #self {
    return { x: self.x * scalar, y: self.y * scalar, z: self.z * scalar, w: self.w * scalar };
  }

  equals :: fn(self, other: #self) -> bool {
    return self.x == other.x && self.y == other.y && self.z == other.z && self.w == other.w;
  }

  distance :: fn(self, other: #self) -> float32 {
    return sqrt((self.x - other.x) * (self.x - other.x) + (self.y - other.y) * (self.y - other.y) + (self.z - other.z) * (self.z - other.z) + (self.w - other.w) * (self.w - other.w)) as float32;
  }
}

impl Color {
  random :: fn(max: u8) -> #self {
    return {
      r: GetRandomValue(0, max) as u8,
      g: GetRandomValue(0, max) as u8,
      b: GetRandomValue(0, max) as u8,
      a: 255 as u8,
    };
  }

}
