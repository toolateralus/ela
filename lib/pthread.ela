#alias pthread_t :: u64;

pthread_attr_t :: union;

#alias ThreadFunction :: fn* ();
#alias ThreadStartRoutine :: fn* (void*)-> void*;

#foreign pthread_create :: fn(thread: pthread_t*, attr: pthread_attr_t*, start_routine: ThreadStartRoutine, arg: void*) -> int;
#foreign pthread_join :: fn(thread: pthread_t*, retval: void**) -> int;

/* forward */ 
start_thread :: fn(arg: void*) -> void*;

/* Simple thread struct */
Thread :: struct {
  handle: pthread_t;
  start_function: ThreadFunction;
}

impl Thread {
  start :: fn(function: ThreadFunction, arg: void*) -> #self {
    self: #self;
    self.start_function = function;
    pthread_create(&self.handle, null, &start_thread, arg);
    return self;
  }
  join :: fn(self*) -> void* {
    #static n : void* = null; // this is discarded.
    pthread_join(&self.handle, &n);
    return n;
  }
}

/* wrapper calback to init Thread struct. */ 
start_thread :: fn(arg: void*) -> void* {
  thread : Thread* = arg;
  if (thread.start_function != null) {
    // @Cleanup remove this hack.
    fun := thread.start_function;
    fun();
  }
  return null;
}

#alias pthread_mutex_t :: u64;
#foreign pthread_mutex_init :: fn(mutex: pthread_mutex_t*, attr: void*) -> int;
#foreign pthread_mutex_lock :: fn(mutex: pthread_mutex_t*) -> int;
#foreign pthread_mutex_unlock :: fn(mutex: pthread_mutex_t*) -> int;
#foreign pthread_mutex_destroy :: fn(mutex: pthread_mutex_t*) -> int;

/* Simple mutex */
Mutex :: struct {
  handle: pthread_mutex_t;
}

impl Mutex {
  create :: fn() -> #self {
    self: #self;
    pthread_mutex_init(&self.handle, null);
    return self;
  }
  lock :: fn(self*) {
    pthread_mutex_lock(&self.handle);
  }
  unlock :: fn(self*) {
    pthread_mutex_unlock(&self.handle);
  }
  free :: fn(self*) {
    pthread_mutex_destroy(&self.handle);
  }
  // #dtor :: fn(self*) {
  // }
}

