
/*
  ## net module ##
  Internet utilities.

  Very basic, and needs a lot of additions to be usable.
  Right now, it barely provides enough to establish a TCP Client & Server connection
  and send messages back and forth.
*/


/*
  These bindings were auto generated by 'ela-bindings-generator', from '/usr/include/arpa/inet.h' at 2025-01-15 13:12:54. 
*/

#alias __u_char :: u8;
#alias __u_short :: u16;
#alias __u_int :: u32;
#alias __u_long :: u64;
#alias __int8_t :: s8;
#alias __uint8_t :: u8;
#alias __int16_t :: s16;
#alias __uint16_t :: u16;
#alias __int32_t :: s32;
#alias __uint32_t :: u32;
#alias __int64_t :: s64;
#alias __uint64_t :: u64;
#alias __int_least8_t :: __int8_t;
#alias __uint_least8_t :: __uint8_t;
#alias __int_least16_t :: __int16_t;
#alias __uint_least16_t :: __uint16_t;
#alias __int_least32_t :: __int32_t;
#alias __uint_least32_t :: __uint32_t;
#alias __int_least64_t :: __int64_t;
#alias __uint_least64_t :: __uint64_t;
#alias __quad_t :: s64;
#alias __u_quad_t :: u64;
#alias __intmax_t :: s64;
#alias __uintmax_t :: u64;
#alias __dev_t :: u64;
#alias __uid_t :: u32;
#alias __gid_t :: u32;
#alias __ino_t :: u64;
#alias __ino64_t :: u64;
#alias __mode_t :: u32;
#alias __nlink_t :: u64;
#alias __off_t :: s64;
#alias __off64_t :: s64;
#alias __pid_t :: s32;

#alias __clock_t :: s64;
#alias __rlim_t :: u64;
#alias __rlim64_t :: u64;
#alias __id_t :: u32;
#alias __time_t :: s64;
#alias __useconds_t :: u32;
#alias __suseconds_t :: s64;
#alias __suseconds64_t :: s64;
#alias __daddr_t :: s32;
#alias __key_t :: s32;
#alias __clockid_t :: s32;
#alias __timer_t :: void *;
#alias __blksize_t :: s64;
#alias __blkcnt_t :: s64;
#alias __blkcnt64_t :: s64;
#alias __fsblkcnt_t :: u64;
#alias __fsblkcnt64_t :: u64;
#alias __fsfilcnt_t :: u64;
#alias __fsfilcnt64_t :: u64;
#alias __fsword_t :: s64;
#alias __ssize_t :: s64;
#alias __syscall_slong_t :: s64;
#alias __syscall_ulong_t :: u64;
#alias __loff_t :: __off64_t;
#alias __caddr_t :: u8 *;
#alias __intptr_t :: s64;
#alias __socklen_t :: u32;
#alias __sig_atomic_t :: s32;
#alias uint8_t :: __uint8_t;
#alias uint16_t :: __uint16_t;
#alias uint32_t :: __uint32_t;
#alias uint64_t :: __uint64_t;
#alias size_t :: u64;
iovec :: struct {
  iov_base : void *;
  iov_len : u64;
};
#alias u_char :: __u_char;
#alias u_short :: __u_short;
#alias u_int :: __u_int;
#alias u_long :: __u_long;
#alias quad_t :: __quad_t;
#alias u_quad_t :: __u_quad_t;
#alias loff_t :: __loff_t;
#alias ino_t :: __ino_t;
#alias dev_t :: __dev_t;
#alias gid_t :: __gid_t;
#alias mode_t :: __mode_t;
#alias nlink_t :: __nlink_t;
#alias uid_t :: __uid_t;
#alias off_t :: __off_t;
#alias pid_t :: __pid_t;
#alias id_t :: __id_t;
#alias ssize_t :: __ssize_t;
#alias daddr_t :: __daddr_t;
#alias caddr_t :: __caddr_t;
#alias key_t :: __key_t;
#alias clock_t :: __clock_t;
#alias clockid_t :: __clockid_t;
#alias time_t :: __time_t;
#alias timer_t :: __timer_t;
#alias ulong :: u64;
#alias ushort :: u16;
#alias uint :: u32;
#alias int8_t :: __int8_t;
#alias int16_t :: __int16_t;
#alias int32_t :: __int32_t;
#alias int64_t :: __int64_t;
#alias u_int8_t :: __uint8_t;
#alias u_int16_t :: __uint16_t;
#alias u_int32_t :: __uint32_t;
#alias u_int64_t :: __uint64_t;
#alias register_t :: s64;
#foreign __bswap_16 :: fn(__bsx: __uint16_t) -> __uint16_t;
#foreign __bswap_32 :: fn(__bsx: __uint32_t) -> __uint32_t;
#foreign __bswap_64 :: fn(__bsx: __uint64_t) -> __uint64_t;
#foreign __uint16_identity :: fn(__x: __uint16_t) -> __uint16_t;
#foreign __uint32_identity :: fn(__x: __uint32_t) -> __uint32_t;
#foreign __uint64_identity :: fn(__x: __uint64_t) -> __uint64_t;

__sigset_t :: struct {
  __val : u64[16];
};
#alias sigset_t :: __sigset_t;

timeval :: struct {
  tv_sec : __time_t;
  tv_usec : __suseconds_t;
};
timespec :: struct {
  tv_sec : __time_t;
  tv_nsec : __syscall_slong_t;
};

#alias suseconds_t :: __suseconds_t;
#alias __fd_mask :: s64;

fd_set :: struct {
  __fds_bits : __fd_mask[16];
};

#alias fd_mask :: __fd_mask;
#foreign select :: fn(__nfds: s32, __readfds: fd_set *, __writefds: fd_set *, __exceptfds: fd_set *, __timeout: timeval *) -> s32;
#foreign pselect :: fn(__nfds: s32, __readfds: fd_set *, __writefds: fd_set *, __exceptfds: fd_set *, __timeout: timespec *, __sigmask: __sigset_t *) -> s32;
#alias blksize_t :: __blksize_t;
#alias blkcnt_t :: __blkcnt_t;
#alias fsblkcnt_t :: __fsblkcnt_t;
#alias fsfilcnt_t :: __fsfilcnt_t;

#alias socklen_t :: __socklen_t;
__socket_type :: enum {
  SOCK_STREAM = 1,
  SOCK_DGRAM = 2,
  SOCK_RAW = 3,
  SOCK_RDM = 4,
  SOCK_SEQPACKET = 5,
  SOCK_DCCP = 6,
  SOCK_PACKET = 10,
  SOCK_CLOEXEC = 524288,
  SOCK_NONBLOCK = 2048,
};
#alias sa_family_t :: u16;
sockaddr :: struct {
  sa_family : sa_family_t;
  sa_data : u8[14];
};
sockaddr_storage :: struct {
  ss_family : sa_family_t;
  __ss_padding : u8[118];
  __ss_align : u64;
};

MSG_OOB :: 1;
MSG_PEEK :: 2;
MSG_DONTROUTE :: 4;
MSG_CTRUNC :: 8;
MSG_PROXY :: 16;
MSG_TRUNC :: 32;
MSG_DONTWAIT :: 64;
MSG_EOR :: 128;
MSG_WAITALL :: 256;
MSG_FIN :: 512;
MSG_SYN :: 1024;
MSG_CONFIRM :: 2048;
MSG_RST :: 4096;
MSG_ERRQUEUE :: 8192;
MSG_NOSIGNAL :: 16384;
MSG_MORE :: 32768;
MSG_WAITFORONE :: 65536;
MSG_BATCH :: 262144;
MSG_ZEROCOPY :: 67108864;
MSG_FASTOPEN :: 536870912;
MSG_CMSG_CLOEXEC :: 1073741824;

msghdr :: struct {
  msg_name : void *;
  msg_namelen : socklen_t;
  msg_iov : iovec *;
  msg_iovlen : u64;
  msg_control : void *;
  msg_controllen : u64;
  msg_flags : s32;
};
cmsghdr :: struct {
  cmsg_len : u64;
  cmsg_level : s32;
  cmsg_type : s32;
  __cmsg_data : List![char];
};
#foreign __cmsg_nxthdr :: fn(__mhdr: msghdr *, __cmsg: cmsghdr *) -> cmsghdr *;

SCM_RIGHTS :: 1;

__kernel_fd_set :: struct {
  fds_bits : u64[16];
};
#alias __kernel_sighandler_t :: fn*(s32) -> void;
#alias __kernel_key_t :: s32;
#alias __kernel_mqd_t :: s32;
#alias __kernel_old_uid_t :: u16;
#alias __kernel_old_gid_t :: u16;
#alias __kernel_old_dev_t :: u64;
#alias __kernel_long_t :: s64;
#alias __kernel_ulong_t :: u64;
#alias __kernel_ino_t :: __kernel_ulong_t;
#alias __kernel_mode_t :: u32;
#alias __kernel_pid_t :: s32;
#alias __kernel_ipc_pid_t :: s32;
#alias __kernel_uid_t :: u32;
#alias __kernel_gid_t :: u32;
#alias __kernel_suseconds_t :: __kernel_long_t;
#alias __kernel_daddr_t :: s32;
#alias __kernel_uid32_t :: u32;
#alias __kernel_gid32_t :: u32;
#alias __kernel_size_t :: __kernel_ulong_t;
#alias __kernel_ssize_t :: __kernel_long_t;
#alias __kernel_ptrdiff_t :: __kernel_long_t;
__kernel_fsid_t :: struct {
  val : s32[2];
};
#alias __kernel_off_t :: __kernel_long_t;
#alias __kernel_loff_t :: s64;
#alias __kernel_old_time_t :: __kernel_long_t;
#alias __kernel_time_t :: __kernel_long_t;
#alias __kernel_time64_t :: s64;
#alias __kernel_clock_t :: __kernel_long_t;
#alias __kernel_timer_t :: s32;
#alias __kernel_clockid_t :: s32;
#alias __kernel_caddr_t :: u8 *;
#alias __kernel_uid16_t :: u16;
#alias __kernel_gid16_t :: u16;
linger :: struct {
  l_onoff : s32;
  l_linger : s32;
};
osockaddr :: struct {
  sa_family : u16;
  sa_data : u8[14];
};

SHUT_RD :: 0;
SHUT_WR :: 1;
SHUT_RDWR :: 2;


#foreign socket :: fn(__domain: s32, __type: s32, __protocol: s32) -> s32;
#foreign socketpair :: fn(__domain: s32, __type: s32, __protocol: s32, __fds: s32*) -> s32;
#foreign bind :: fn(__fd: s32, __addr: sockaddr *, __len: socklen_t) -> s32;
#foreign getsockname :: fn(__fd: s32, __addr: sockaddr *, __len: socklen_t *) -> s32;
#foreign connect :: fn(__fd: s32, __addr: sockaddr *, __len: socklen_t) -> s32;
#foreign getpeername :: fn(__fd: s32, __addr: sockaddr *, __len: socklen_t *) -> s32;
#foreign send :: fn(__fd: s32, __buf: void *, __n: u64, __flags: s32) -> s64;
#foreign recv :: fn(__fd: s32, __buf: void *, __n: u64, __flags: s32) -> s64;
#foreign sendto :: fn(__fd: s32, __buf: void *, __n: u64, __flags: s32, __addr: sockaddr *, __addr_len: socklen_t) -> s64;
#foreign recvfrom :: fn(__fd: s32, __buf: void *, __n: u64, __flags: s32, __addr: sockaddr *, __addr_len: socklen_t *) -> s64;
#foreign sendmsg :: fn(__fd: s32, __message: msghdr *, __flags: s32) -> s64;
#foreign recvmsg :: fn(__fd: s32, __message: msghdr *, __flags: s32) -> s64;
#foreign getsockopt :: fn(__fd: s32, __level: s32, __optname: s32, __optval: void *, __optlen: socklen_t *) -> s32;
#foreign setsockopt :: fn(__fd: s32, __level: s32, __optname: s32, __optval: void *, __optlen: socklen_t) -> s32;
#foreign listen :: fn(__fd: s32, __n: s32) -> s32;
#foreign accept :: fn(__fd: s32, __addr: sockaddr *, __addr_len: socklen_t *) -> s32;
#foreign shutdown :: fn(__fd: s32, __how: s32) -> s32;
#foreign sockatmark :: fn(__fd: s32) -> s32;
#foreign isfdtype :: fn(__fd: s32, __fdtype: s32) -> s32;
#alias in_addr_t :: u32;
in_addr :: struct {
  s_addr : in_addr_t;
};
ip_opts :: struct {
  ip_dst : in_addr;
  opts : u8[40];
};
in_pktinfo :: struct {
  ipi_ifindex : s32;
  ipi_spec_dst : in_addr;
  ipi_addr : in_addr;
};
  IPPROTO_IP :: 0;
  IPPROTO_ICMP :: 1;
  IPPROTO_IGMP :: 2;
  IPPROTO_IPIP :: 4;
  IPPROTO_TCP :: 6;
  IPPROTO_EGP :: 8;
  IPPROTO_PUP :: 12;
  IPPROTO_UDP :: 17;
  IPPROTO_IDP :: 22;
  IPPROTO_TP :: 29;
  IPPROTO_DCCP :: 33;
  IPPROTO_IPV6 :: 41;
  IPPROTO_RSVP :: 46;
  IPPROTO_GRE :: 47;
  IPPROTO_ESP :: 50;
  IPPROTO_AH :: 51;
  IPPROTO_MTP :: 92;
  IPPROTO_BEETPH :: 94;
  IPPROTO_ENCAP :: 98;
  IPPROTO_PIM :: 103;
  IPPROTO_COMP :: 108;
  IPPROTO_L2TP :: 115;
  IPPROTO_SCTP :: 132;
  IPPROTO_UDPLITE :: 136;
  IPPROTO_MPLS :: 137;
  IPPROTO_ETHERNET :: 143;
  IPPROTO_RAW :: 255;
  IPPROTO_MPTCP :: 262;
  IPPROTO_MAX :: 263;


  IPPROTO_HOPOPTS :: 0;
  IPPROTO_ROUTING :: 43;
  IPPROTO_FRAGMENT :: 44;
  IPPROTO_ICMPV6 :: 58;
  IPPROTO_NONE :: 59;
  IPPROTO_DSTOPTS :: 60;
  IPPROTO_MH :: 135;

#alias in_port_t :: u16;
IPPORT_ECHO :: 7;
IPPORT_DISCARD :: 9;
IPPORT_SYSTAT :: 11;
IPPORT_DAYTIME :: 13;
IPPORT_NETSTAT :: 15;
IPPORT_FTP :: 21;
IPPORT_TELNET :: 23;
IPPORT_SMTP :: 25;
IPPORT_TIMESERVER :: 37;
IPPORT_NAMESERVER :: 42;
IPPORT_WHOIS :: 43;
IPPORT_MTP :: 57;
IPPORT_TFTP :: 69;
IPPORT_RJE :: 77;
IPPORT_FINGER :: 79;
IPPORT_TTYLINK :: 87;
IPPORT_SUPDUP :: 95;
IPPORT_EXECSERVER :: 512;
IPPORT_LOGINSERVER :: 513;
IPPORT_CMDSERVER :: 514;
IPPORT_EFSSERVER :: 520;
IPPORT_BIFFUDP :: 512;
IPPORT_WHOSERVER :: 513;
IPPORT_ROUTESERVER :: 520;
IPPORT_RESERVED :: 1024;
IPPORT_USERRESERVED :: 5000;

__bind_gen__anon_D10 :: union {
  __u6_addr8 : u8[16];
  __u6_addr16 : u16[8];
  __u6_addr32 : u32[4];
};

in6_addr :: struct {
  __in6_u : __bind_gen__anon_D10
};


in6addr_any: in6_addr;
in6addr_loopback: in6_addr;
sockaddr_in :: struct {
  sin_family : sa_family_t;
  sin_port : in_port_t;
  sin_addr : in_addr;
  sin_zero : u8[8];
};
sockaddr_in6 :: struct {
  sin6_family : sa_family_t;
  sin6_port : in_port_t;
  sin6_flowinfo : u32;
  sin6_addr : in6_addr;
  sin6_scope_id : u32;
};
ip_mreq :: struct {
  imr_multiaddr : in_addr;
  imr_interface : in_addr;
};
ip_mreqn :: struct {
  imr_multiaddr : in_addr;
  imr_address : in_addr;
  imr_ifindex : s32;
};
ip_mreq_source :: struct {
  imr_multiaddr : in_addr;
  imr_interface : in_addr;
  imr_sourceaddr : in_addr;
};
ipv6_mreq :: struct {
  ipv6mr_multiaddr : in6_addr;
  ipv6mr_interface : u32;
};
group_req :: struct {
  gr_interface : u32;
  gr_group : sockaddr_storage;
};
group_source_req :: struct {
  gsr_interface : u32;
  gsr_group : sockaddr_storage;
  gsr_source : sockaddr_storage;
};
ip_msfilter :: struct {
  imsf_multiaddr : in_addr;
  imsf_interface : in_addr;
  imsf_fmode : u32;
  imsf_numsrc : u32;
  imsf_slist : in_addr[1];
};
group_filter :: struct {
  gf_interface : u32;
  gf_group : sockaddr_storage;
  gf_fmode : u32;
  gf_numsrc : u32;
  gf_slist : sockaddr_storage[1];
};
#foreign ntohl :: fn(__netlong: u32) -> u32;
#foreign ntohs :: fn(__netshort: u16) -> u16;
#foreign htonl :: fn(__hostlong: u32) -> u32;
#foreign htons :: fn(__hostshort: u16) -> u16;
#foreign bindresvport :: fn(__sockfd: s32, __sock_in: sockaddr_in *) -> s32;
#foreign bindresvport6 :: fn(__sockfd: s32, __sock_in: sockaddr_in6 *) -> s32;
#foreign inet_addr :: fn(__cp: u8 *) -> in_addr_t;
#foreign inet_lnaof :: fn(__in: in_addr) -> in_addr_t;
#foreign inet_makeaddr :: fn(__net: in_addr_t, __host: in_addr_t) -> in_addr;
#foreign inet_netof :: fn(__in: in_addr) -> in_addr_t;
#foreign inet_network :: fn(__cp: u8 *) -> in_addr_t;
#foreign inet_ntoa :: fn(__in: in_addr) -> u8 *;
#foreign inet_pton :: fn(__af: s32, __cp: u8 *, __buf: void *) -> s32;
#foreign inet_ntop :: fn(__af: s32, __cp: void *, __buf: u8 *, __len: socklen_t) -> u8 *;
#foreign inet_aton :: fn(__cp: u8 *, __inp: in_addr *) -> s32;
#foreign inet_neta :: fn(__net: in_addr_t, __buf: u8 *, __len: u64) -> u8 *;
#foreign inet_net_ntop :: fn(__af: s32, __cp: void *, __bits: s32, __buf: u8 *, __len: u64) -> u8 *;
#foreign inet_net_pton :: fn(__af: s32, __cp: u8 *, __buf: void *, __len: u64) -> s32;
#foreign inet_nsap_addr :: fn(__cp: u8 *, __buf: u8 *, __len: s32) -> u32;
#foreign inet_nsap_ntoa :: fn(__len: s32, __cp: u8 *, __buf: u8 *) -> u8 *;

/* Protocol families.  */
PF_UNSPEC ::	0	/* Unspecified.  */;
PF_LOCAL ::	1	/* Local to host (pipes and file-domain).  */;
PF_UNIX := PF_LOCAL /* POSIX name for PF_LOCAL.  */;
PF_FILE := PF_LOCAL /* Another non-standard name for PF_LOCAL.  */;
PF_INET ::		2	/* IP protocol family.  */;
PF_AX25 ::		3	/* Amateur Radio AX.25.  */;
PF_IPX ::		4	/* Novell Internet Protocol.  */;
PF_APPLETALK ::	5	/* Appletalk DDP.  */;
PF_NETROM ::	6	/* Amateur radio NetROM.  */;
PF_BRIDGE ::	7	/* Multiprotocol bridge.  */;
PF_ATMPVC ::	8	/* ATM PVCs.  */;
PF_X25 ::		9	/* Reserved for X.25 project.  */;
PF_INET6 ::	10	/* IP version 6.  */;
PF_ROSE ::		11	/* Amateur Radio X.25 PLP.  */;
PF_DECnet ::	12	/* Reserved for DECnet project.  */;
PF_NETBEUI ::	13	/* Reserved for 802.2LLC project.  */;
PF_SECURITY ::	14	/* Security callback pseudo AF.  */;
PF_KEY ::		15	/* PF_KEY key management API.  */;
PF_NETLINK ::	16;
PF_ROUTE :=	PF_NETLINK /* Alias to emulate 4.4BSD.  */;
PF_PACKET ::	17	/* Packet family.  */;
PF_ASH ::		18	/* Ash.  */;
PF_ECONET ::	19	/* Acorn Econet.  */;
PF_ATMSVC ::	20	/* ATM SVCs.  */;
PF_RDS ::		21	/* RDS sockets.  */;
PF_SNA ::		22	/* Linux SNA Project */;
PF_IRDA ::		23	/* IRDA sockets.  */;
PF_PPPOX ::	24	/* PPPoX sockets.  */;
PF_WANPIPE ::	25	/* Wanpipe API sockets.  */;
PF_LLC ::		26	/* Linux LLC.  */;
PF_IB ::		27	/* Native InfiniBand address.  */;
PF_MPLS ::		28	/* MPLS.  */;
PF_CAN ::		29	/* Controller Area Network.  */;
PF_TIPC ::		30	/* TIPC sockets.  */;
PF_BLUETOOTH ::	31	/* Bluetooth sockets.  */;
PF_IUCV ::		32	/* IUCV sockets.  */;
PF_RXRPC ::	33	/* RxRPC sockets.  */;
PF_ISDN ::		34	/* mISDN sockets.  */;
PF_PHONET ::	35	/* Phonet sockets.  */;
PF_IEEE802154 ::	36	/* IEEE 802.15.4 sockets.  */;
PF_CAIF ::		37	/* CAIF sockets.  */;
PF_ALG ::		38	/* Algorithm sockets.  */;
PF_NFC ::		39	/* NFC sockets.  */;
PF_VSOCK ::	40	/* vSockets.  */;
PF_KCM ::		41	/* Kernel Connection Multiplexor.  */;
PF_QIPCRTR ::	42	/* Qualcomm IPC Router.  */;
PF_SMC ::		43	/* SMC sockets.  */;
PF_XDP ::		44	/* XDP sockets.  */;
PF_MCTP ::		45	/* Management component transport protocol.  */;
PF_MAX ::		46	/* For now..  */;

/* Address families.  */
AF_UNSPEC := PF_UNSPEC;
AF_LOCAL := PF_LOCAL;
AF_UNIX := PF_UNIX;
AF_FILE := PF_FILE;
AF_INET := PF_INET;
AF_AX25 := PF_AX25;
AF_IPX := PF_IPX;
AF_APPLETALK := PF_APPLETALK;
AF_NETROM := PF_NETROM;
AF_BRIDGE := PF_BRIDGE;
AF_ATMPVC := PF_ATMPVC;
AF_X25 := PF_X25;
AF_INET6 := PF_INET6;
AF_ROSE := PF_ROSE;
AF_DECnet := PF_DECnet;
AF_NETBEUI := PF_NETBEUI;
AF_SECURITY := PF_SECURITY;
AF_KEY := PF_KEY;
AF_NETLINK := PF_NETLINK;
AF_ROUTE := PF_ROUTE;
AF_PACKET := PF_PACKET;
AF_ASH := PF_ASH;
AF_ECONET := PF_ECONET;
AF_ATMSVC := PF_ATMSVC;
AF_RDS := PF_RDS;
AF_SNA := PF_SNA;
AF_IRDA := PF_IRDA;
AF_PPPOX := PF_PPPOX;
AF_WANPIPE := PF_WANPIPE;
AF_LLC := PF_LLC;
AF_IB := PF_IB;
AF_MPLS := PF_MPLS;
AF_CAN := PF_CAN;
AF_TIPC := PF_TIPC;
AF_BLUETOOTH := PF_BLUETOOTH;
AF_IUCV := PF_IUCV;
AF_RXRPC := PF_RXRPC;
AF_ISDN := PF_ISDN;
AF_PHONET := PF_PHONET;
AF_IEEE802154 := PF_IEEE802154;
AF_CAIF := PF_CAIF;
AF_ALG := PF_ALG;
AF_NFC := PF_NFC;
AF_VSOCK := PF_VSOCK;
AF_KCM := PF_KCM;
AF_QIPCRTR := PF_QIPCRTR;
AF_SMC := PF_SMC;
AF_XDP := PF_XDP;
AF_MCTP := PF_MCTP;
AF_MAX := PF_MAX;

/* Types of sockets.  */
SocketType :: enum{
  Stream = 1,		/* Sequenced, reliable, connection-based byte streams.  */
  Dgram = 2,		/* Connectionless, unreliable datagrams of fixed maximum length.  */
  Raw = 3,			/* Raw protocol interface.  */
  Rdm = 4,			/* Reliably-delivered messages.  */
  Seqpacket = 5,		/* Sequenced, reliable, connection-based, datagrams of fixed maximum length.  */
  Dccp = 6,		/* Datagram Congestion Control Protocol.  */
  Packet = 10,		/* Linux specific way of getting packets at the dev level.  For writing rarp and other similar things on the user level. */
  /* Flags to be ORed into the type parameter of socket and socketpair and used for the flags parameter of paccept.  */
  Cloexec = 02000000,	/* Atomically set close-on-exec flag for the new descriptor(s).  */
  Nonblock = 00004000	/* Atomically mark descriptor(s) as non-blocking.  */
};


INADDR_ANY        : in_addr_t = 0x00000000;
/* Address to send to all hosts.  */
INADDR_BROADCAST  : in_addr_t =	0xffffffff;
/* Address indicating an error return.  */
INADDR_NONE       : in_addr_t	=	0xffffffff;
/* Dummy address for source of ICMPv6 errors converted to IPv4 (RFC7600).  */
INADDR_DUMMY      :	in_addr_t =	0xc000000;

// Close the file descriptor FD.
#foreign close :: fn(__fd: int) ->  int;

// Read NBYTES into BUF from FD.  Return the number read, -1 for errors or 0 for EOF.
#foreign read :: fn(__fd: int, __buf: void*, __nbytes: u64) -> u64;

// Write N bytes of BUF to FD.  Return the number written, or -1.
#foreign write :: fn(__fd: int, __buf: void*, __n: u64) -> u64;

/* Create a new socket of type TYPE in domain DOMAIN, using
   protocol PROTOCOL.  If PROTOCOL is zero, one is chosen automatically.
   Returns a file descriptor for the new socket, or -1 for errors.  */
#foreign socket :: fn(__domain: int, __type: int, __protocol: int ) -> int;

/* Give the socket FD the local address ADDR (which is LEN bytes long).  */
#foreign bind :: fn(__fd: int, __addr: sockaddr*, __len: socklen_t) -> int;

/* Prepare to accept connections on socket FD.
   N connection requests will be queued before further requests are refused.
   Returns 0 on success, -1 for errors.  */
#foreign listen :: fn(__fd: int, __n: int) -> int;

/* Await a connection on socket FD.
   When a connection arrives, open a new socket to communicate with it,
   set *ADDR (which is *ADDR_LEN bytes long) to the address of the connecting
   peer and *ADDR_LEN to the address's actual length, and return the
   new socket's descriptor, or -1 for errors.
*/
#foreign accept :: fn(__fd: int, __addr: sockaddr*, __addr_len: socklen_t*) -> int;

/* Open a connection on socket FD to peer at ADDR (which LEN bytes long).
   For connectionless socket types, just set the default address to send to
   and the only address from which to accept transmissions.
   Return 0 on success, -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
#foreign connect :: fn(__fd: int, __addr: sockaddr*, __len: socklen_t ) -> int;
