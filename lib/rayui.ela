#import raylib;

// * ########### BUILTIN UI HELPERS ############### //

// * Style struct used for UI styling.
Style :: struct {
  foreground: Color,
  background: Color,
  highlighted: Color,
  font_size: int,
  use_jiggly_text: bool,
  jiggle_intensity : float,
  jiggle_rate : float,
}

// * Measure the width of a jiggly text of 'text' and 'style'
measure_jiggly_text :: fn(text: c_string, style: Style) -> float {
  if !text then return 0.0;
  length := strlen(text);
  total_width: float = 0.0;
  for i in 0..length {
    total_width += style.font_size;
  }
  return total_width;
}

// * Draw wavy jiggly text.
jiggly_text :: fn(text: c_string, rect: Rectangle, style: Style) {
  
  time: float = GetTime() as float;

  length := 0;
  if text then length = strlen(text);

  intensity := style.jiggle_intensity;
  rate := style.jiggle_rate;

  for i in 0..length {
    char_x := rect.x + (i * style.font_size) as float;
    char_y := rect.y + intensity * sin(rate * time + (i as float));
    temp : char[2] = { text[i], '\0' };
    DrawText(temp as c_string, char_x as int, char_y as int, style.font_size, style.foreground);
  }
}

// * Draw a button with that returns true for clicked, false for not clicked.
button :: fn(text: c_string, rect: Rectangle, style: Style) -> bool {
  position: Vector2 = { x: rect.x, y: rect.y};
  size: Vector2 = { x: rect.width, y: rect.height};

  text_width : float;
  if style.use_jiggly_text {
    text_width = measure_jiggly_text(text, style);
  } else {
    text_width = MeasureText(text, style.font_size);
  }

  text_height : float = style.font_size;

  if text_width > rect.width {
    size.x = text_width;
    position.x = rect.x - (text_width - rect.width) / 2;
  }

  new_rect : Rectangle = { x: position.x, y: position.y, width: size.x, height: size.y};

  text_x := position.x + (size.x - text_width) / 2;
  text_y := position.y + (size.y - text_height) / 2;

  mouse_over := CheckCollisionPointRec(GetMousePosition(), new_rect);

  if mouse_over {
    DrawRectangleV(position, size, style.highlighted);
    if (IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_LEFT)) {
    
      return true;
    }
  } else {
    DrawRectangleV(position, size, style.background);
  }

  if !style.use_jiggly_text {
    DrawText(text, text_x as int, text_y as int, style.font_size, style.foreground);
  } else {
    jiggly_text(text, { x: text_x, y: text_y, width: new_rect.width, height: new_rect.height}, style);
  }

  return false;
}


// * Draw a button with a click callback.
// * T* in the callback is a pointer to some of your state data, if you want to mutate it.
// * Just pass use 'void' for generic argument && pass null if you don't want to use that.

//! TODO: once we fix repro 63,
//! make this generic, and take fn*(T*) so we don'thave to void cast our data in our callback
button_pro :: fn(text: c_string, rect: Rectangle, style: Style, callback: fn* (void*) -> void, user_data : void*) -> bool {
  
  position: Vector2 = { x: rect.x, y: rect.y};
  size: Vector2 = { x: rect.width, y: rect.height};

  text_width : float;
  if style.use_jiggly_text {
    text_width = measure_jiggly_text(text, style);
  } else {
    text_width = MeasureText(text, style.font_size);
  }

  text_height : float = style.font_size;

  if text_width > rect.width {
    size.x = text_width;
    position.x = rect.x - (text_width - rect.width) / 2;
  }

  new_rect : Rectangle = { x: position.x, y: position.y, width: size.x, height: size.y};

  text_x := position.x + (size.x - text_width) / 2;
  text_y := position.y + (size.y - text_height) / 2;

  mouse_over := CheckCollisionPointRec(GetMousePosition(), new_rect);

  if mouse_over {
    DrawRectangleV(position, size, style.highlighted);
    if (IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_LEFT)) {
      callback(user_data);
      return true;
    }
  } else {
    DrawRectangleV(position, size, style.background);
  }

  if !style.use_jiggly_text {
    DrawText(text, text_x as int, text_y as int, style.font_size, style.foreground);
  } else {
    jiggly_text(text, { x: text_x, y: text_y, width: new_rect.width, height: new_rect.height}, style);
  }

  return false;
}

// *########### END BUILTIN UI HELPERS ############### */
// ? A simple timer that can be used in update loops to get a tick every N seconds.
// * interval: float = seconds between each tick.
Timer :: struct {
  interval : float,
  // Returns true if the timer has exceeded the interval time relative to the last tick time,
  last_tick_time: float,
}

impl Timer {
  tick :: fn(self*) -> bool {
    now := GetTime();
    if self.last_tick_time == 0 {
      self.last_tick_time = now;
      return true;
    }
    if now >= (self.last_tick_time + self.interval) {
      self.last_tick_time = now;
      return true;
    }
    return false;
  }
}

Slider :: struct![T] {
  text: c_string,
  rect: Rectangle,
  style: Style,
  min_value: T,
  max_value: T,
  value: T*,
  held : bool,
  digits_to_show: int,
}

impl![T] Slider![T] {
  adjust_slider_value :: fn(self*) {
    increment: T;
    if IsKeyDown(KeyboardKey::KEY_LEFT_SHIFT) {
      increment = (self.max_value - self.min_value) / 100;
    } else {
      increment = (self.max_value - self.min_value) / 50;
    }
    if IsKeyPressed(KeyboardKey::KEY_RIGHT) {
      *self.value = clamp(*self.value + increment, min![T](self.min_value, self.max_value), max![T](self.min_value, self.max_value));
    } else if IsKeyPressed(KeyboardKey::KEY_LEFT) {
      *self.value = clamp(*self.value - increment, min![T](self.min_value, self.max_value), max![T](self.min_value, self.max_value));
    }

    // Handle mouse input
    mouse_pos := GetMousePosition();
    if CheckCollisionPointRec(mouse_pos, self.rect) {
      if IsMouseButtonDown(MouseButton::MOUSE_BUTTON_LEFT) {
        self.held = true;
      }
    }

    if self.held {
      if !IsMouseButtonDown(MouseButton::MOUSE_BUTTON_LEFT) {
        self.held = false;
      } else {
        new_value := self.min_value + ((mouse_pos.x - self.rect.x) / self.rect.width) * (self.max_value - self.min_value);
        *self.value = clamp(new_value, min![T](self.min_value, self.max_value), max![T](self.min_value, self.max_value));
      }
    }
  }

  draw :: fn(self*) {
    DrawRectangleV(Vector2{ x: self.rect.x, y: self.rect.y}, Vector2{ x: self.rect.width, y: self.rect.height}, self.style.background);

    v_f := (*self.value) as float;
    min_f := self.min_value as float;
    max_f := self.max_value as float;

    slider_width : float = self.rect.width * clamp(abs(v_f - min_f) / abs(max_f - min_f), 0.0, 1.0);

    slider_rect : Rectangle = {
      x: self.rect.x,
      y: self.rect.y,
      width: slider_width,
      height: self.rect.height
    };

    DrawRectangleV(Vector2{ x: slider_rect.x, y: slider_rect.y}, Vector2{ x: slider_rect.width, y: slider_rect.height}, self.style.foreground);

    DrawRectangleLines(self.rect.x as int, self.rect.y as int, self.rect.width as int, self.rect.height as int, self.style.highlighted);

    text_x := self.rect.x + (self.rect.width - MeasureText(self.text, self.style.font_size)) / 2;
    text_y := self.rect.y + (self.rect.height - self.style.font_size) / 2;
    DrawText(self.text, text_x as int, text_y as int, self.style.font_size, self.style.highlighted);

    value_text := $"{*self.value}";
    value_text[self.digits_to_show] = '\0';
    value_text_x := text_x + MeasureText(self.text, self.style.font_size) + 10; // 10 pixels padding
    DrawText(value_text, value_text_x as int, text_y as int, self.style.font_size, self.style.highlighted);
    free(value_text);

    self.adjust_slider_value();
  }
}

CheckButton :: struct {
  value: bool,
  rect: Rectangle,
  style: Style,
  text: c_string,
  allow_hold : bool,
}

impl CheckButton {
  draw :: fn(self*) {
    if self.value {
      DrawRectangleV(Vector2{ x: self.rect.x, y: self.rect.y}, Vector2{ x: self.rect.width, y: self.rect.height}, self.style.highlighted);
    } else {
      DrawRectangleV(Vector2{ x: self.rect.x, y: self.rect.y}, Vector2{ x: self.rect.width, y: self.rect.height}, self.style.background);
    }

    if self.text {
      text_x := self.rect.x + (self.rect.width - MeasureText(self.text, self.style.font_size)) / 2;
      text_y := self.rect.y + (self.rect.height - self.style.font_size) / 2;
      DrawText(self.text, text_x as int, text_y as int, self.style.font_size, self.style.foreground);
    }

    hit := CheckCollisionPointRec(GetMousePosition(), self.rect);

    if hit {
      DrawRectangleLines(self.rect.x as int, self.rect.y as int, self.rect.width as int, self.rect.height as int, ORANGE);
    }

    left := false;
    right := false;

    if self.allow_hold {
      left = IsMouseButtonDown(MouseButton::MOUSE_BUTTON_LEFT);
      right = IsMouseButtonDown(MouseButton::MOUSE_BUTTON_RIGHT);
      if hit && left {
        self.value = true;
      } else if hit && right {
        self.value = false;
      }
    } else if hit && IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_LEFT) {
      self.value = !self.value;
    }
  }
}

DropDown :: struct {
  options: c_string[],
  rect: Rectangle,
  style: Style,
  selected_index: int,
  is_open: bool,
  on_selected: fn*(int),
  on_open: fn*(),
  label: c_string,
  show_selected_option: bool,
}

impl DropDown {
  draw :: fn(self*) {
    // Draw the dropdown box
    DrawRectangleV(Vector2{ x: self.rect.x, y: self.rect.y}, Vector2{ x: self.rect.width, y: self.rect.height}, self.style.background);

    if self.selected_index >= 0 && self.selected_index < self.options.length && self.show_selected_option {
      // Draw the selected option
      text_x := self.rect.x + (self.rect.width - MeasureText(self.options[self.selected_index], self.style.font_size)) / 2;
      text_y := self.rect.y + (self.rect.height - self.style.font_size) / 2;
      DrawText(self.options[self.selected_index], text_x as int, text_y as int, self.style.font_size, self.style.foreground);
    } else {
      // Draw the label
      text_x := self.rect.x + (self.rect.width - MeasureText(self.label, self.style.font_size)) / 2;
      text_y := self.rect.y + (self.rect.height - self.style.font_size) / 2;
      DrawText(self.label, text_x as int, text_y as int, self.style.font_size, self.style.foreground);
    }

    hit := CheckCollisionPointRec(GetMousePosition(), self.rect);
    if hit && IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_LEFT) {
      self.is_open = !self.is_open;
      if self.is_open && self.on_open {
        self.on_open();
      }
    }

    hit_option := false;
    if self.is_open {
      option_rect := self.rect;
      option_rect.y += self.rect.height;
      for i in 0..self.options.length {
        option_color := self.style.background;
        if CheckCollisionPointRec(GetMousePosition(), option_rect) {
          option_color = self.style.highlighted;
          hit_option = true;
        }
        DrawRectangleV(Vector2{ x: option_rect.x, y: option_rect.y}, Vector2{ x: option_rect.width, y: option_rect.height}, option_color);
        text_x := option_rect.x + (option_rect.width - MeasureText(self.options[i], self.style.font_size)) / 2;
        text_y := option_rect.y + (option_rect.height - self.style.font_size) / 2;
        DrawText(self.options[i], text_x as int, text_y as int, self.style.font_size, self.style.foreground);

        if CheckCollisionPointRec(GetMousePosition(), option_rect) && IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_LEFT) {
          self.selected_index = i;
          self.is_open = false;
          if self.on_selected {
            self.on_selected(i as s32);
          }
        }
        option_rect.y += option_rect.height;
      }
    }

    if !hit && !hit_option {
      self.is_open = false;
    }
  }
}
