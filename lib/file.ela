_IO_FILE :: struct;
#alias FILE :: _IO_FILE;

EOF :: -1;

SeekPosition :: enum {
  // Seek from beginning of file.
  Begin,
  // Seek from current position.
  Current,
  // Seek from end of file.
  End,
}

#foreign fread :: fn(ptr: void *, size: u64, count: u64, stream: FILE *) -> u64;
#foreign fwrite :: fn(ptr: void *, size: u64, count: u64, stream: FILE *) -> u64;
#foreign fseek :: fn(stream: FILE *, offset: s64, origin: s32) -> int;
#foreign ftell :: fn(stream: FILE *) -> s64;
#foreign rewind :: fn(stream: FILE *) -> void;
#foreign fopen :: fn(fname: char *, flags: char *) -> FILE *;
#foreign fclose :: fn(file: FILE *) -> void;
#foreign fgetc :: fn(file: FILE *) -> u8;
#foreign putc :: fn(ch: u8, file: FILE *) -> void;
#foreign fprintf :: fn(stream: FILE *, format: char *, ...) -> int;
#foreign fflush :: fn(f: FILE *);

#alias FileError :: c_string;

// TODO: add a way to do Binary stuff.
#flags FileOpenFlags :: enum {
  Read,
  Write,
}

File :: struct {
  fd: FILE*,
}

impl File {
  flush :: fn(self*) {
    fflush(self.fd);
  }

  close :: fn(self*) -> void {
    fflush(self.fd);
    fclose(self.fd);
    self.fd = null;
  }

  length :: fn(file: FILE*) -> u32 {
    fseek(file, 0, SeekPosition::End);
    len := ftell(file);
    fseek(file, 0, SeekPosition::Begin);
    return len as u32;
  }

  read_all :: fn(filename: char*) -> (FileError, c_string) {
    file := fopen(filename, "r");

    if !file then return ($"Couldn't open file {filename}", null);
    
    str: char*;
    length := 0;
    c: char;
    while ((c = fgetc(file)) != EOF) {
      if length != 0 { 
        str = $"{str}{c}";
      }
      else {
        str = $"{c}";
      }
      length = strlen(str);
    }
    fclose(file);
    return (null, str);
  }

  read_bytes :: fn(filename: c_string) -> List![u8] {
    file := fopen(filename, "r");
    if !file then return {};
    result: List![u8];
    c: char;
    while ((c = fgetc(file)) != EOF) {
      result.push(c as u8);
    }
    fclose(file);
    return result;
  }

  write_all :: fn(filename: c_string, data: c_string) -> FileError {
    file := fopen(filename, "w");
    if !file {
      return $"Unable to open file {filename}";
    }
    fwrite(data, sizeof(char), strlen(data), file);
    fclose(file);
    return null;
  }

  // Used to convert our flag enum to a string for fopen/fclose etc.
  flags_to_string :: fn(flags: int) -> c_string {
    s: c_string = null;
    if (flags & FileOpenFlags::Read != 0) 
      then s = "r";
    if (flags & FileOpenFlags::Write != 0)
      then s = $"{s}w";
    return s;
  }
}
