;

fn add_generic!<T>(a: T, b: T) -> T {
  return a + b;
}

fn generic_return!<T>() -> T {
  t: T;
  return t;
}

#test fn test_generic_add() {
  assert("generic_add_float failed", add_generic!<f32>(100.0, 100.0) == 200.0);
  assert("generic_add_int failed", add_generic!<s32>(5, 6) == 11);
  assert("generic_return failed", generic_return!<s32>() == 0);
  assert("generic_return failed", generic_return!<f32>() == 0.0);
}

struct Generic!<T> {
  t: T
}

fn generic_fn!<T>() {}

struct Other{}

impl!<T> Generic!<T> {
  fn dont(*const self) -> T {
    t: T;
    return t;
  }
}

struct My_Struct {
  a: Other
}

#test fn test_generic_dependencies() {
  a : Generic!<My_Struct>;
  generic_fn!<Other>();
  b := a.dont();
}