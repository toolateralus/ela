#import core;


#test test_string :: fn() {
  my_string : string = "Xaryu Baryu";
  assert("string length failed to equal expected value", my_string.length == 11);
}

#test test_array :: fn() {
  array : int[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  assert("array length failed to equal expected value", array.length == 11);
}


Xaryu :: struct {
  value: int;
}

impl Xaryu {
  to_string :: fn(self) -> string {
    return "XarBar";
  }
}

#test test_string_interpolation :: fn() {
  xarbar: Xaryu;
  interp: string = $"{xarbar}";
  assert("unexpected interpolated string value", strcmp(interp.data, "XarBar") == 0);
  interp = $"{(1 + 1) * 2}";
  assert("unexpected interpolated string value", strcmp(interp.data, "4") == 0);
}



/* 
  These operators will be removed as soon as we finish this massive rewrite.
  Where [] array is implemented in ela, and we can just have generic methods for these operations.
*/
#test test_array_concat_operator :: fn() {
  array: int[];
  array ~= 10;
  assert("concat operator failed", array.length == 1);
}

#test test_array_pop_operator :: fn() {
  array: int[];
  for i in 0..100 {
    array ~= 10;
  }
  n: int;
  for i in 0..100 {
    n = ~array;
  }
  assert("pop operator failed", array.length == 0 && n == 10);
}

#test test_array_erase_operator :: fn() {
  array: int[] ;
  array ~= 10;
  array ~~ 10;
  assert("failed to erase element from array with ~~", array.length == 0);
}



#test test_multidimensional_arrays :: fn() {
  array: int[5][5];
  for x in 0..5 {
    for y in 0..5 {
      array[x][y] = x * y;
    }
  }

  for x in 0..5 {
    for y in 0..5 {
      assert("multidimensional failure", array[x][y] == x * y);
    }
  }

  dynamic : s64[][];
  for x in 0..5 {
    dynamic ~= #make(s64[]);
    for y in 0..5 {
      dynamic[x] ~= x * y;
    }
  }

  assert("length failed", dynamic.length == 5);

  for x in 0..5 {
    for y in 0..5 {
      assert("multidimensional failure", dynamic[x][y] == x * y);
    }
  }
}

#test test_map_aka_associative_array :: fn() {
  variables: int[string];
  map1: int*[char*];

  str1 := #make(string, "Key1");
  str2 := #make(string, "Key2");
  str3 := #make(string, "shouldn't exist");

  variables[str1] = 100;
  variables[str2] = 200;

  assert("Expected: 100", variables[str1] == 100);
  assert("Expected: 200", variables[str2] == 200);

  // assert("Didn't contain known key.", variables.contains(str1));
  // assert("Map contained incorrect key.", !variables.contains(str3));

  variables[str1] = 300;
  assert("Expected: 300", variables[str1] == 300);

  variables[str1] = 0;
  assert("Expected: 0", variables[str1] == 0);

  ptr := malloc(sizeof(int)) as int*;
  *ptr = 200;
  map1["Something"] = ptr;
  assert("Expected: 200", *map1["Something"] == 200);

  *map1["Something"] = 400;
  assert("Expected: 400", *map1["Something"] == 400);

  ptr = malloc(sizeof(int)) as int*;
  *ptr = 500;
  map1["Another"] = ptr;
  assert("Expected: 500", *map1["Another"] == 500);

  free(map1["Something"]);
  free(map1["Another"]);

  // ! BUG : Cannot use multi-dimensional maps. It's terribly designed and needs a rework.
  // ! really, maps should be eliminated and be replaced once generics are back in the language.
}


#test subscript_string :: fn() {
  s: string = #make(string, "0,1,2,3");
  s[0] = 10;
}

#test test_range_var :: fn() {
  r : Range = 0..10;
  assert("range variable failed", r.first == 0 && r.last == 10);

  i: int;
  for z in r {
    assert("range iteration failed", i == z);
    i++;
  }
}

#test test_slicing_array :: fn() {
  arr := #make(s64[], 1000);
  assert("Length", arr.length == 1000);

  /*
    Ranges are always max-exclusive right now.
    0..10 == 0->9;
    We don't currently have a way to represent max inclusive ranges.
  */
  for i in 0..10 {
    arr[i] = 100;
  }

  subarr := arr[0..10];

  for i in 0..10 {
    assert("Slice failed", subarr[i] == arr[i]);
  }

  assert("Slice failed", subarr.length == 10);
}

