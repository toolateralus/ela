;


#test test_string :: fn() {
  my_string : string = string::from("Xaryu Baryu");
  assert("string length failed to equal expected value"c, my_string.length == 11);
}

#test test_array :: fn() {
  array : int[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  assert("array length failed to equal expected value"c, array.length == 11);
}


Xaryu :: struct {
  value: int;
}

impl Xaryu {
  to_string :: fn(self) -> c_string {
    return "XarBar";
  }
}

#test test_string_interpolation :: fn() {
  xarbar: Xaryu;
  interp: string = string::from($"{xarbar}");
  assert("unexpected interpolated string value"c, strcmp(interp.data, "XarBar"c) == 0);
  interp = string::from($"{(1 + 1) * 2}");
  assert("unexpected interpolated string value"c, strcmp(interp.data, "4"c) == 0);
}



/* 
  These operators will be removed as soon as we finish this massive rewrite.
  Where [] array is implemented in ela, and we can just have generic methods for these operations.
*/
#test test_array_concat_operator :: fn() {
  array: int[];
  array ~= 10;
  assert("concat operator failed"c, array.length == 1);
}

#test test_array_pop_operator :: fn() {
  array: int[];
  for i in 0..100 {
    array ~= 10;
  }
  n: int;
  for i in 0..100 {
    n = ~array;
  }
  assert("pop operator failed"c, array.length == 0 && n == 10);
}

#test test_array_erase_operator :: fn() {
  array: int[] ;
  array ~= 10;
  array ~~ 10;
  assert("failed to erase element from array with ~~"c, array.length == 0);
}



#test test_multidimensional_arrays :: fn() {
  array: int[5][5];
  for x in 0..5 {
    for y in 0..5 {
      array[x][y] = x * y;
    }
  }

  for x in 0..5 {
    for y in 0..5 {
      assert("multidimensional failure"c, array[x][y] == x * y);
    }
  }

  dynamic : s64[][];
  for x in 0..5 {
    dynamic ~= {};
    for y in 0..5 {
      dynamic[x] ~= x * y;
    }
  }

  assert("length failed"c, dynamic.length == 5);

  for x in 0..5 {
    for y in 0..5 {
      assert("multidimensional failure"c, dynamic[x][y] == x * y);
    }
  }
}


#test subscript_string :: fn() {
  s: string = string::from("0,1,2,3");
  s[0] = 10;
  assert("subscript assign string failed"c, s[0] == (10 as char));
}

#test test_range_var :: fn() {
  r : Range = 0..10;
  assert("range variable failed"c, r.first == 0 && r.last == 10);

  i: int;
  for z in r {
    assert("range iteration failed"c, i == z);
    i++;
  }
}

#test test_slicing_array :: fn() {
  arr := s64[] {
    0, 0, 0,
    0, 0, 0,
    0, 0, 0,
    0, 0,
  };
  
  assert("Length"c, arr.length == 11);

  for i in 0..10 {
    arr[i] = 100;
  }

  subarr := arr[0..10];

  for i in 0..10 {
    assert("Slice failed"c, subarr[i] == arr[i]);
  }

  assert("Slice failed"c, subarr.length == 10);
}

