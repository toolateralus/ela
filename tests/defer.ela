#import core;


/* 
 * :: Important :: 
  - Some of these value based returns from defers may be surprising that they do not mutate the variables.
  - This is because the defer is always executed after the return value is already obtained: they are merely for mutating state on exit,
    such as calling cleanup functions, not changing the value of the return value post return.
*/


nested_defer_test :: fn() -> int {
  x := 0;
  defer {
    x += 1;
  }
  if (true) {
    defer {
      x += 2;
    }
  }
  return x;
}

#test test_nested_defer :: fn() {
  assert("nested defer failed", nested_defer_test() == 2);
}

loop_defer_test :: fn() -> int {
  x := 0;
  for i in 0..3 {
    defer {
      x += i;
    }
  }
  return x;
}

#test test_loop_defer :: fn() {
  assert("loop defer failed", loop_defer_test() == 3);
}

early_return_defer_test :: fn() -> int {
  x := 0;
  defer {
    x += 1;
  }
  if (true) {
    defer {
      x += 2;
    }
    return x;
  }
  return x;
}

#test test_early_return_defer :: fn() {
  assert("early return defer failed", early_return_defer_test() == 0);
}

DeferCleanup :: struct {
  ptr : void*;
}

// Return statements are evaluated BEFORE the defer, so
// do not try to change a non-pointer, or what a pointer points to,
// and expect that to propogate to the caller via return.

// here we show that the ptr as a u64 is passed back to the caller before it's set to null
// in the defer block. which is absolutely expected behaviour.
defer_cleanup_routine :: fn(c: DeferCleanup*) -> u64 {
  defer {
    free(c.ptr);
    c.ptr = null;
  }
  assert("defer cleanup got null input", c.ptr != null);
  return c.ptr as u64;
}

#test test_defer_cleanup_routine :: fn() {
  ptr := malloc(8);
  cleanup := DeferCleanup {
    ptr: ptr
  };
  ptr_as_int : u64 = ptr as u64;
  n := defer_cleanup_routine(&cleanup);
  assert("yep", n == ptr_as_int);
  assert("cleanup on defer failed", cleanup.ptr == null);
}
