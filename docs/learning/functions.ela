
/* functions are simply defined with NAME :: fn(parameters) -> RETURN_TYPE {..block..} syntax. */
add :: fn(a: s32, b: s32) -> s32 {
  return a + b;
}

// Note: for all generics, (structs, functions, unions, tagged unions, interfaces)
// the syntax will always be the same. ![T, T1, T2];

// No function overloading. Use generics instead, as such:
generic :: fn![T](t: T) -> T {
  return t * 2;
}

generic1 :: fn![T, T1](t: T, t1: T1) -> T {
  return t * t1;
}


// For functions (or control flow) that return perform a single expression, you can use 'expression body'.
// this is basically an implicit returning body.

getter :: fn() -> s32 => 10;
print_something :: fn() => println("swoop");


main :: fn() {
  generic(10); // infers.
  generic(20); // infers.

  // To specify explicitly
  generic![s32](10);
  generic![s32, f32](10, 10.0);
}


